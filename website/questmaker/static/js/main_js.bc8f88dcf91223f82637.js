/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./assets sync recursive \\.(svg%7Cpng%7Cjpe?g%7Cgif%7Cico)(\\?.*)?$/":
/*!*****************************************************************!*\
  !*** ./assets/ sync \.(svg%7Cpng%7Cjpe?g%7Cgif%7Cico)(\?.*)?$/ ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var map = {\n\t\"./img/favicon.ico\": \"./assets/img/favicon.ico\",\n\t\"./img/img1.jpg\": \"./assets/img/img1.jpg\",\n\t\"./img/profile_defolt.png\": \"./assets/img/profile_defolt.png\",\n\t\"./img/telegram_scrin_on_phone.jpg\": \"./assets/img/telegram_scrin_on_phone.jpg\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./assets sync recursive \\\\.(svg%7Cpng%7Cjpe?g%7Cgif%7Cico)(\\\\?.*)?$/\";\n\n//# sourceURL=webpack://questmaker/./assets/_sync_\\.(svg%257Cpng%257Cjpe?");

/***/ }),

/***/ "./assets/js/blockRedactor.js":
/*!************************************!*\
  !*** ./assets/js/blockRedactor.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BlockRedactor\": () => (/* binding */ BlockRedactor)\n/* harmony export */ });\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nvar BlockRedactor = /*#__PURE__*/function () {\n  function BlockRedactor() {\n    _classCallCheck(this, BlockRedactor);\n  }\n\n  _createClass(BlockRedactor, null, [{\n    key: \"addTextRedactor\",\n    value: function addTextRedactor(form, label, text) {\n      form.innerHTML += \"<label for=\\\"formControlTextarea\\\" class=\\\"form-label\\\">\" + label + \"</label>\" + \"<textarea class=\\\"form-control\\\" id=\\\"formControlTextarea\\\" rows=\\\"3\\\"> \" + text + \"</textarea>\";\n    }\n  }, {\n    key: \"addAnswerForOpenQuestion\",\n    value: function addAnswerForOpenQuestion(form, answer) {\n      form.innerHTML += \"<div class='col-8'>\" + \"<input type=\\\"text\\\" class=\\\"form-control\\\" id=\\\"answerText\\\"\" + \" value=\" + answer.text + \">\" + \"</div>\" + \"<div class=\\\"col-3\\\">\" + \"<div class=\\\"input-group\\\">\" + \"<span class=\\\"input-group-text\\\"> Очки </span>\" + \"<input type=\\\"text\\\" class=\\\"form-control\\\" id=\\\"answerPoints\\\"\" + \" value=\" + answer.points + \">\" + \"</div>\" + \"</div>\" + \"<div class=\\\"col-1\\\">\" + \"<button class=\\\"btn btn-danger\\\">-</button>\" + \"</div>\";\n    }\n  }, {\n    key: \"addMovementForMovementBlock\",\n    value: function addMovementForMovementBlock(form, question) {\n      form.innerHTML += \"<div class='col-8'>\" + \"<div class='input-group'>\" + \"<span class=\\\"input-group-text\\\"> Координаты </span>\" + \"<input type=\\\"text\\\" class=\\\"form-control\\\" id=\\\"moveCoords\\\" value=\" + question.movements[0].place.coords + \">\" + \"</div>\" + \"</div>\" + \"<div class='col-8'>\" + \"<div class='input-group'>\" + \"<span class=\\\"input-group-text\\\"> Радиус(м) </span>\" + \"<input type=\\\"text\\\" class=\\\"form-control\\\" id=\\\"moveRadius\\\"  value=\" + question.movements[0].place.radius + \">\" + \"</div>\" + \"</div>\" + \"<div class=\\\"col-8\\\">\" + \"<div class='input-group'>\" + \"<span class=\\\"input-group-text\\\"> Очки </span>\" + \"<input type=\\\"text\\\" class=\\\"form-control\\\" id=\\\"movePoints\\\"  value=\" + question.answer_options[0].points + \">\" + \"</div>\" + \"</div>\";\n    }\n  }, {\n    key: \"createStartRedactor\",\n    value: function createStartRedactor(form, question) {\n      this.addTextRedactor(form, \"Приветственное сообщение:\", question.text);\n\n      document.getElementById(\"update\").onclick = function () {\n        question.text = document.getElementById(\"formControlTextarea\").value;\n        document.getElementById(question.question_id).getElementsByClassName(\"card-text\")[0].textContent = question.text;\n      };\n    }\n  }, {\n    key: \"createFinishRedactor\",\n    value: function createFinishRedactor(form, question) {\n      this.addTextRedactor(form, \"Прощальное сообщение:\", question.text);\n\n      document.getElementById(\"update\").onclick = function () {\n        question.text = document.getElementById(\"formControlTextarea\").value;\n        document.getElementById(question.question_id).getElementsByClassName(\"card-text\")[0].textContent = question.text;\n      };\n    }\n  }, {\n    key: \"createOpenQuestionRedactor\",\n    value: function createOpenQuestionRedactor(form, question) {\n      this.addTextRedactor(form, \"Вопрос\", question.text);\n      form.innerHTML += \"<hr><label for=\\\"formControlTextarea\\\" class=\\\"form-label\\\">Ответы:</label>\";\n\n      var _iterator = _createForOfIteratorHelper(question.answer_options),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var answer = _step.value;\n          this.addAnswerForOpenQuestion(form, answer);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      form.innerHTML += \"<div class='col-auto'><button type='button' class='btn btn-primary'>Добавить ответ</button></div>\";\n\n      document.getElementById(\"update\").onclick = function () {\n        question.text = document.getElementById(\"formControlTextarea\").value;\n        document.getElementById(question.question_id).getElementsByClassName(\"card-text\")[0].textContent = question.text;\n\n        var _iterator2 = _createForOfIteratorHelper(question.answer_options),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var answer = _step2.value;\n            var answerId = answer.answer_option_id;\n            answer.text = document.getElementById(\"answerText\").value;\n            answer.points = document.getElementById(\"answerPoints\").value;\n            document.getElementById(\"answer\" + answerId).innerText = document.getElementById(\"answerText\").value;\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      };\n    }\n  }, {\n    key: \"createMovementRedactor\",\n    value: function createMovementRedactor(form, question) {\n      BlockRedactor.addTextRedactor(form, \"Перемещение\", question.text);\n      form.innerHTML += '<div class=\"z-depth-1-half map-container\" style=\"height: 500px\" id=\"map\"></div>';\n      var myMap;\n      var mapId = document.getElementById(\"map\");\n      console.log(mapId);\n      ymaps.ready(function () {\n        myMap = new ymaps.Map(\"map\", {\n          center: [57.5262, 38.3061],\n          zoom: 11\n        }, {\n          balloonMaxWidth: 200,\n          searchControlProvider: 'yandex#search'\n        });\n        console.log(myMap);\n        myMap.events.add('click', function (e) {\n          if (!myMap.balloon.isOpen()) {\n            var coords = e.get('coords');\n            myMap.balloon.open(coords, {\n              contentHeader: 'Новое место квеста',\n              contentBody: '<p></p>' + '<p>Координаты точки: ' + [coords[0].toPrecision(6), coords[1].toPrecision(6)].join(', ') + '</p>',\n              contentFooter: '<sup>Вы можете выбрать новую точку</sup>'\n            }); //console.log(coords[0]);\n\n            question.movements[0].place.coords = \"(\" + coords[0].toString() + \",\" + coords[1].toString() + \")\";\n            console.log(question.movements[0].place.coords);\n            document.getElementById(\"moveCoords\").value = question.movements[0].place.coords;\n          } else {\n            myMap.balloon.close();\n          }\n        });\n        myMap.events.add('balloonopen', function (e) {\n          myMap.hint.close();\n        });\n        ;\n      });\n      console.log(myMap);\n      BlockRedactor.addMovementForMovementBlock(form, question);\n\n      document.getElementById(\"update\").onclick = function () {\n        question.text = document.getElementById(\"formControlTextarea\").value;\n        document.getElementById(question.question_id).getElementsByClassName(\"card-text\")[0].textContent = question.text;\n        question.movements[0].place.coords = document.getElementById(\"moveCoords\").value;\n        question.movements[0].place.radius = document.getElementById(\"moveRadius\").value;\n        question.answer_options[0].points = document.getElementById(\"movePoints\").value;\n      };\n    }\n  }, {\n    key: \"showRedactor\",\n    value: function showRedactor(question) {\n      var modal = new bootstrap.Modal(document.getElementById(\"redactor\"));\n      var form = document.getElementById(\"redactorForm\");\n      form.innerHTML = \"\";\n\n      switch (question.type) {\n        case \"start\":\n          BlockRedactor.createStartRedactor(form, question);\n          break;\n\n        case \"end\":\n          BlockRedactor.createFinishRedactor(form, question);\n          break;\n\n        case \"open\":\n          BlockRedactor.createOpenQuestionRedactor(form, question);\n          break;\n\n        case \"movement\":\n          BlockRedactor.createMovementRedactor(form, question);\n          break;\n\n        case \"choice\":\n          //TODO: change this to function for \"choice\"\n          BlockRedactor.createOpenQuestionRedactor(form, question);\n          break;\n\n        default:\n          break;\n      }\n\n      modal.show();\n    }\n  }]);\n\n  return BlockRedactor;\n}();\n\n//# sourceURL=webpack://questmaker/./assets/js/blockRedactor.js?");

/***/ }),

/***/ "./assets/js/constructor.js":
/*!**********************************!*\
  !*** ./assets/js/constructor.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _jsplumb_browser_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jsplumb/browser-ui */ \"./node_modules/@jsplumb/browser-ui/js/jsplumb.browser-ui.es.js\");\n/* harmony import */ var _jsplumb_connector_flowchart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jsplumb/connector-flowchart */ \"./node_modules/@jsplumb/connector-flowchart/js/jsplumb.connector-flowchart.es.js\");\n/* harmony import */ var _quest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./quest */ \"./assets/js/quest.js\");\n/* harmony import */ var _render__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./render */ \"./assets/js/render.js\");\n/* harmony import */ var _css_index_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../css/index.css */ \"./assets/css/index.css\");\n\n //import { Render } from \"./render\"\n\n\n\n // load static images\n\n__webpack_require__(\"./assets sync recursive \\\\.(svg%7Cpng%7Cjpe?g%7Cgif%7Cico)(\\\\?.*)?$/\");\n\nvar containerElement = document.getElementById(\"container\");\nvar instance = (0,_jsplumb_browser_ui__WEBPACK_IMPORTED_MODULE_0__.newInstance)({\n  container: containerElement\n});\nvar sourceEndpoint = {\n  endpoint: {\n    type: \"Dot\",\n    options: {\n      radius: 5\n    }\n  },\n  connector: {\n    type: \"Flowchart\",\n    options: {\n      cornerRadius: 2\n    }\n  },\n  source: true\n};\nvar targetEndpoint = {\n  endpoint: {\n    type: \"Rectangle\"\n  },\n  //paintStyle: { fill: \"green\" },\n  maxConnections: -1,\n  source: false,\n  target: true,\n  connectionsDetachable: true,\n  anchor: [0.5, 0, 0, -1]\n};\n_quest__WEBPACK_IMPORTED_MODULE_2__.Quest.loadQuest(1).then(function (newQuest) {\n  var quest = newQuest;\n  _render__WEBPACK_IMPORTED_MODULE_3__.Render.render(quest, instance, sourceEndpoint, targetEndpoint);\n  return quest;\n});\n/*export function createNewBlock(type, text, renderFunction){\r\n    console.log(text);\r\n    let max = quest.data.questions.reduce((acc, curr) => acc.question_id > curr.question_id ? acc : curr);\r\n    let newBlockId = max.question_id + 1;\r\n    console.log(newBlockId);\r\n    quest.data.questions.push( {\r\n        \"answer_options\": [\r\n            {\r\n                \"next_question_id\": undefined,\r\n                \"points\": 0,\r\n                \"text\": \"Ответ\"\r\n            }\r\n        ],\r\n       \"files\": [],\r\n       \"hints\": [],\r\n       \"movements\": [],\r\n       \"question_id\": newBlockId,\r\n       \"text\": text,\r\n       \"type\": type\r\n   });\r\n   console.log(quest.data.questions.slice(-1)[0]);\r\n   renderFunction(quest, quest.data.questions.slice(-1)[0], instance, sourceEndpoint, targetEndpoint);\r\n   return quest.data.questions.slice(-1)[0];\r\n}\r\n document.getElementById(\"addMBtn\").onclick = () => {\r\n    let movements = quest.data.questions.filter(item => item.type == \"movement\");\r\n    console.log(movements);\r\n    let maxMovement = movements.reduce((acc, curr) =>\r\n    acc.movements[0].movement_id >= curr.movements[0].movement_id  ? acc : curr);\r\n    console.log(maxMovement == undefined);\r\n    let maxId = (maxMovement != undefined ? maxMovement.movements[0].movement_id+1 : 1);\r\n    console.log(maxId);\r\n    createNewBlock(\"movement\", \"Новое перемещение\", Render.renderMovement);\r\n    console.log(quest.data.questions);\r\n    quest.data.questions.slice(-1)[0].movements.push({\r\n        \"movement_id\": maxId,\r\n        \"next_question_id\": undefined,\r\n        \"place\": {\r\n            \"coords\": \"(0.0,0.0)\",\r\n            \"place_id\": undefined,\r\n            \"radius\": 0,\r\n            \"time_close\": \"Sun, 12 Aug 2001 19:00:00 GMT\",\r\n            \"time_open\": \"Sun, 12 Aug 2001 09:00:00 GMT\"\r\n        }\r\n    });\r\n}\r\n\r\ndocument.getElementById(\"addQBtn\").onclick = () => {\r\n    createNewBlock(\"open\", \"Новый открытый вопрос\", Render.renderOpenQuestion);\r\n}\r\n*/\n\n//# sourceURL=webpack://questmaker/./assets/js/constructor.js?");

/***/ }),

/***/ "./assets/js/quest.js":
/*!****************************!*\
  !*** ./assets/js/quest.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Quest\": () => (/* binding */ Quest)\n/* harmony export */ });\n/* harmony import */ var _jsplumb_browser_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jsplumb/browser-ui */ \"./node_modules/@jsplumb/browser-ui/js/jsplumb.browser-ui.es.js\");\n/* harmony import */ var _render__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./render */ \"./assets/js/render.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n //import { Render } from \"./render\"\n\n\nvar Quest = /*#__PURE__*/function () {\n  function Quest(data) {\n    _classCallCheck(this, Quest);\n\n    this.data = data;\n  }\n\n  _createClass(Quest, [{\n    key: \"showQuest\",\n    value: function showQuest() {\n      var containerElement = document.getElementById(\"container\");\n      var instance = (0,_jsplumb_browser_ui__WEBPACK_IMPORTED_MODULE_0__.newInstance)({\n        container: containerElement\n      });\n      var sourceEndpoint = {\n        endpoint: {\n          type: \"Dot\",\n          options: {\n            radius: 5\n          }\n        },\n        connector: {\n          type: \"Flowchart\",\n          options: {\n            cornerRadius: 2\n          }\n        },\n        source: true\n      };\n      var targetEndpoint = {\n        endpoint: {\n          type: \"Rectangle\"\n        },\n        maxConnections: -1,\n        source: false,\n        target: true,\n        connectionsDetachable: true,\n        anchor: [0.5, 0, 0, -1]\n      };\n      _render__WEBPACK_IMPORTED_MODULE_1__.Render.render(this, instance, sourceEndpoint, targetEndpoint);\n    }\n  }], [{\n    key: \"makeLoadRequest\",\n    value: function makeLoadRequest(url) {\n      return new Promise(function (resolve, reject) {\n        var xmlhttp = new XMLHttpRequest();\n\n        xmlhttp.onreadystatechange = function () {\n          if (xmlhttp.readyState === XMLHttpRequest.DONE) {\n            if (xmlhttp.status === 200) {\n              resolve(xmlhttp.responseText);\n            } else {\n              reject(xmlhttp.status);\n            }\n          }\n        };\n\n        xmlhttp.open(\"GET\", url, true);\n        xmlhttp.send();\n      });\n    }\n  }, {\n    key: \"loadQuest\",\n    value: function loadQuest(id) {\n      var _this = this;\n\n      var url = '/api/db/quest/' + id.toString();\n      return new Promise(function (resolve, reject) {\n        resolve(_this.makeLoadRequest(url).then(function (data) {\n          console.log(\"success\");\n          return new Quest(JSON.parse(data));\n        }));\n      });\n    }\n  }]);\n\n  return Quest;\n}();\n\n//# sourceURL=webpack://questmaker/./assets/js/quest.js?");

/***/ }),

/***/ "./assets/js/render.js":
/*!*****************************!*\
  !*** ./assets/js/render.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Render\": () => (/* binding */ Render)\n/* harmony export */ });\n/* harmony import */ var _blockRedactor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./blockRedactor */ \"./assets/js/blockRedactor.js\");\n/* harmony import */ var _jsplumb_browser_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jsplumb/browser-ui */ \"./node_modules/@jsplumb/browser-ui/js/jsplumb.browser-ui.es.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\n\nvar Render = /*#__PURE__*/function () {\n  function Render() {\n    _classCallCheck(this, Render);\n  }\n\n  _createClass(Render, null, [{\n    key: \"renderBlockBase\",\n    value: function renderBlockBase(question, width, title, position) {\n      var block = document.createElement(\"div\");\n      block.id = question.question_id;\n      block.className = \"position-absolute border-2 card\";\n      block.style.width = width;\n      block.style.top = position[0];\n      block.style.left = position[1];\n      var blockBody = document.createElement(\"div\");\n      blockBody.className = \"card-body\";\n      blockBody.innerHTML = \"<h5 class=\\\"card-title text-center\\\">\" + title + \"</h5>\" + \"<hr>\" + \"<p class=\\\"card-text text-center text-truncate\\\">\" + question.text + \"</p>\";\n      block.append(blockBody);\n\n      block.ondblclick = function () {\n        _blockRedactor__WEBPACK_IMPORTED_MODULE_0__.BlockRedactor.showRedactor(question);\n      };\n\n      document.getElementById(\"container\").append(block);\n      return block;\n    }\n  }, {\n    key: \"addDeleteButton\",\n    value: function addDeleteButton(quest, block, instance, answerElements) {\n      var deleteButton = document.createElement(\"button\");\n      deleteButton.id = \"btn\" + block.id;\n      deleteButton.className = \"btn-close btn-danger\";\n      deleteButton.style.position = \"absolute\";\n      deleteButton.style.top = \"0\";\n      deleteButton.style.right = \"0\";\n\n      deleteButton.onclick = function () {\n        if (answerElements !== undefined) {\n          var _iterator = _createForOfIteratorHelper(answerElements),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var answerElement = _step.value;\n              instance.deleteConnectionsForElement(answerElement);\n              instance.selectEndpoints({\n                element: answerElement\n              }).deleteAll();\n              delete instance.getManagedElements()[answerElement.id];\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n\n        instance.deleteConnectionsForElement(block);\n        instance.selectEndpoints({\n          element: block\n        }).deleteAll();\n        delete instance.getManagedElements()[block.id];\n        block.parentElement.removeChild(block);\n        var questions = quest.data.questions;\n        questions.splice(questions.indexOf(questions.find(function (question) {\n          return question.question_id == block.id;\n        })), 1);\n      };\n\n      block.append(deleteButton);\n    }\n  }, {\n    key: \"renderStart\",\n    value: function renderStart(question, instance, sourceEndpoint, position) {\n      var block = this.renderBlockBase(question, \"10rem\", \"Начало\", position);\n      instance.manage(block, block.id);\n      instance.addEndpoint(block, sourceEndpoint);\n      return block;\n    }\n  }, {\n    key: \"renderFinish\",\n    value: function renderFinish(question, instance, targetEndpoint, position) {\n      var block = this.renderBlockBase(question, \"10rem\", \"Конец\", position);\n      instance.manage(block, block.id);\n      instance.addEndpoint(block, targetEndpoint);\n      return block;\n    }\n  }, {\n    key: \"renderOpenQuestion\",\n    value: function renderOpenQuestion(quest, question, instance, sourceEndpoint, targetEndpoint, position) {\n      var block = Render.renderBlockBase(question, \"15rem\", \"Открытый вопрос\", position);\n      var answerTable = document.createElement(\"ul\");\n      answerTable.className = \"list-group list-group-flush\";\n      block.append(answerTable);\n\n      var _iterator2 = _createForOfIteratorHelper(question.answer_options),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var answer = _step2.value;\n          var tableElement = document.createElement(\"li\");\n          tableElement.innerHTML = answer.text;\n          tableElement.className = \"list-group-item\";\n          tableElement.id = \"answer\" + answer.answer_option_id;\n          answerTable.append(tableElement);\n          instance.addEndpoint(tableElement, {\n            anchor: [\"Right\", \"Left\"]\n          }, sourceEndpoint);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      Render.addDeleteButton(quest, block, instance, answerTable.childNodes);\n      instance.addEndpoint(block, {\n        anchor: \"Top\"\n      }, targetEndpoint);\n      return block;\n    }\n  }, {\n    key: \"renderMovement\",\n    value: function renderMovement(quest, question, instance, sourceEndpoint, targetEndpoint, position) {\n      var block = Render.renderBlockBase(question, \"15rem\", \"Перемещение\", position);\n      Render.addDeleteButton(quest, block, instance);\n      instance.addEndpoint(block, {\n        anchor: \"Top\"\n      }, targetEndpoint);\n      instance.addEndpoint(block, {\n        anchor: \"Bottom\"\n      }, sourceEndpoint);\n      return block;\n    }\n  }, {\n    key: \"render\",\n    value: function render(quest, instance, sourceEndpoint, targetEndpoint) {\n      var position = [0, 0];\n\n      var _iterator3 = _createForOfIteratorHelper(quest.data.questions),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var question = _step3.value;\n          var block = void 0;\n\n          switch (question.type) {\n            case \"start\":\n              block = Render.renderStart(question, instance, sourceEndpoint, position);\n              break;\n\n            case \"end\":\n              block = Render.renderFinish(question, instance, targetEndpoint, position);\n              break;\n\n            case \"open\":\n              block = Render.renderOpenQuestion(quest, question, instance, sourceEndpoint, targetEndpoint, position);\n              break;\n\n            case \"movement\":\n              block = Render.renderMovement(quest, question, instance, sourceEndpoint, targetEndpoint, position);\n              break;\n\n            case \"choice\":\n              //TODO: change this to function for \"choice\"\n              block = Render.renderOpenQuestion(quest, question, instance, sourceEndpoint, targetEndpoint, position);\n              break;\n\n            default:\n              break;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var _iterator4 = _createForOfIteratorHelper(quest.data.questions),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _question = _step4.value;\n\n          if (_question.type === \"start\") {\n            instance.connect({\n              source: instance.selectEndpoints({\n                element: document.getElementById(_question.question_id)\n              }).get(0),\n              target: instance.selectEndpoints({\n                element: document.getElementById(_question.answer_options[0].next_question_id)\n              }).get(0)\n            });\n          } else if (_question.type === \"movement\") {\n            instance.connect({\n              source: instance.selectEndpoints({\n                element: document.getElementById(_question.question_id)\n              }).get(1),\n              target: instance.selectEndpoints({\n                element: document.getElementById(_question.answer_options[0].next_question_id)\n              }).get(0)\n            });\n          } else if (_question.type !== \"end\") {\n            var _iterator5 = _createForOfIteratorHelper(_question.answer_options),\n                _step5;\n\n            try {\n              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                var answer = _step5.value;\n                instance.connect({\n                  source: instance.selectEndpoints({\n                    element: document.getElementById(\"answer\" + answer.answer_option_id)\n                  }).get(0),\n                  target: instance.selectEndpoints({\n                    element: document.getElementById(answer.next_question_id)\n                  }).get(0)\n                });\n              }\n            } catch (err) {\n              _iterator5.e(err);\n            } finally {\n              _iterator5.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }]);\n\n  return Render;\n}();\n\n//# sourceURL=webpack://questmaker/./assets/js/render.js?");

/***/ }),

/***/ "./node_modules/@jsplumb/browser-ui/js/jsplumb.browser-ui.es.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@jsplumb/browser-ui/js/jsplumb.browser-ui.es.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ATTRIBUTE_CONTAINER\": () => (/* binding */ ATTRIBUTE_CONTAINER),\n/* harmony export */   \"ATTRIBUTE_GROUP_CONTENT\": () => (/* binding */ ATTRIBUTE_GROUP_CONTENT),\n/* harmony export */   \"ATTRIBUTE_JTK_ENABLED\": () => (/* binding */ ATTRIBUTE_JTK_ENABLED),\n/* harmony export */   \"ATTRIBUTE_JTK_SCOPE\": () => (/* binding */ ATTRIBUTE_JTK_SCOPE),\n/* harmony export */   \"BrowserJsPlumbInstance\": () => (/* binding */ BrowserJsPlumbInstance),\n/* harmony export */   \"CLASS_DELEGATED_DRAGGABLE\": () => (/* binding */ CLASS_DELEGATED_DRAGGABLE),\n/* harmony export */   \"CLASS_DRAGGABLE\": () => (/* binding */ CLASS_DRAGGABLE),\n/* harmony export */   \"CLASS_DRAGGED\": () => (/* binding */ CLASS_DRAGGED),\n/* harmony export */   \"CLASS_DRAG_ACTIVE\": () => (/* binding */ CLASS_DRAG_ACTIVE),\n/* harmony export */   \"CLASS_DRAG_CONTAINER\": () => (/* binding */ CLASS_DRAG_CONTAINER),\n/* harmony export */   \"CLASS_DRAG_HOVER\": () => (/* binding */ CLASS_DRAG_HOVER),\n/* harmony export */   \"CLASS_GHOST_PROXY\": () => (/* binding */ CLASS_GHOST_PROXY),\n/* harmony export */   \"CONNECTION\": () => (/* binding */ CONNECTION),\n/* harmony export */   \"Collicat\": () => (/* binding */ Collicat),\n/* harmony export */   \"ContainmentType\": () => (/* binding */ ContainmentType),\n/* harmony export */   \"Drag\": () => (/* binding */ Drag),\n/* harmony export */   \"DragManager\": () => (/* binding */ DragManager),\n/* harmony export */   \"ELEMENT\": () => (/* binding */ ELEMENT),\n/* harmony export */   \"ELEMENT_DIV\": () => (/* binding */ ELEMENT_DIV),\n/* harmony export */   \"ENDPOINT\": () => (/* binding */ ENDPOINT),\n/* harmony export */   \"EVENT_BEFORE_START\": () => (/* binding */ EVENT_BEFORE_START),\n/* harmony export */   \"EVENT_CLICK\": () => (/* binding */ EVENT_CLICK),\n/* harmony export */   \"EVENT_CONNECTION_ABORT\": () => (/* binding */ EVENT_CONNECTION_ABORT),\n/* harmony export */   \"EVENT_CONNECTION_CLICK\": () => (/* binding */ EVENT_CONNECTION_CLICK),\n/* harmony export */   \"EVENT_CONNECTION_CONTEXTMENU\": () => (/* binding */ EVENT_CONNECTION_CONTEXTMENU),\n/* harmony export */   \"EVENT_CONNECTION_DBL_CLICK\": () => (/* binding */ EVENT_CONNECTION_DBL_CLICK),\n/* harmony export */   \"EVENT_CONNECTION_DBL_TAP\": () => (/* binding */ EVENT_CONNECTION_DBL_TAP),\n/* harmony export */   \"EVENT_CONNECTION_DRAG\": () => (/* binding */ EVENT_CONNECTION_DRAG),\n/* harmony export */   \"EVENT_CONNECTION_MOUSEDOWN\": () => (/* binding */ EVENT_CONNECTION_MOUSEDOWN),\n/* harmony export */   \"EVENT_CONNECTION_MOUSEOUT\": () => (/* binding */ EVENT_CONNECTION_MOUSEOUT),\n/* harmony export */   \"EVENT_CONNECTION_MOUSEOVER\": () => (/* binding */ EVENT_CONNECTION_MOUSEOVER),\n/* harmony export */   \"EVENT_CONNECTION_MOUSEUP\": () => (/* binding */ EVENT_CONNECTION_MOUSEUP),\n/* harmony export */   \"EVENT_CONNECTION_TAP\": () => (/* binding */ EVENT_CONNECTION_TAP),\n/* harmony export */   \"EVENT_CONTEXTMENU\": () => (/* binding */ EVENT_CONTEXTMENU),\n/* harmony export */   \"EVENT_DBL_CLICK\": () => (/* binding */ EVENT_DBL_CLICK),\n/* harmony export */   \"EVENT_DBL_TAP\": () => (/* binding */ EVENT_DBL_TAP),\n/* harmony export */   \"EVENT_DRAG\": () => (/* binding */ EVENT_DRAG),\n/* harmony export */   \"EVENT_DRAG_MOVE\": () => (/* binding */ EVENT_DRAG_MOVE),\n/* harmony export */   \"EVENT_DRAG_START\": () => (/* binding */ EVENT_DRAG_START),\n/* harmony export */   \"EVENT_DRAG_STOP\": () => (/* binding */ EVENT_DRAG_STOP),\n/* harmony export */   \"EVENT_DROP\": () => (/* binding */ EVENT_DROP),\n/* harmony export */   \"EVENT_ELEMENT_CLICK\": () => (/* binding */ EVENT_ELEMENT_CLICK),\n/* harmony export */   \"EVENT_ELEMENT_CONTEXTMENU\": () => (/* binding */ EVENT_ELEMENT_CONTEXTMENU),\n/* harmony export */   \"EVENT_ELEMENT_DBL_CLICK\": () => (/* binding */ EVENT_ELEMENT_DBL_CLICK),\n/* harmony export */   \"EVENT_ELEMENT_DBL_TAP\": () => (/* binding */ EVENT_ELEMENT_DBL_TAP),\n/* harmony export */   \"EVENT_ELEMENT_MOUSE_DOWN\": () => (/* binding */ EVENT_ELEMENT_MOUSE_DOWN),\n/* harmony export */   \"EVENT_ELEMENT_MOUSE_MOVE\": () => (/* binding */ EVENT_ELEMENT_MOUSE_MOVE),\n/* harmony export */   \"EVENT_ELEMENT_MOUSE_OUT\": () => (/* binding */ EVENT_ELEMENT_MOUSE_OUT),\n/* harmony export */   \"EVENT_ELEMENT_MOUSE_OVER\": () => (/* binding */ EVENT_ELEMENT_MOUSE_OVER),\n/* harmony export */   \"EVENT_ELEMENT_MOUSE_UP\": () => (/* binding */ EVENT_ELEMENT_MOUSE_UP),\n/* harmony export */   \"EVENT_ELEMENT_TAP\": () => (/* binding */ EVENT_ELEMENT_TAP),\n/* harmony export */   \"EVENT_ENDPOINT_CLICK\": () => (/* binding */ EVENT_ENDPOINT_CLICK),\n/* harmony export */   \"EVENT_ENDPOINT_DBL_CLICK\": () => (/* binding */ EVENT_ENDPOINT_DBL_CLICK),\n/* harmony export */   \"EVENT_ENDPOINT_DBL_TAP\": () => (/* binding */ EVENT_ENDPOINT_DBL_TAP),\n/* harmony export */   \"EVENT_ENDPOINT_MOUSEDOWN\": () => (/* binding */ EVENT_ENDPOINT_MOUSEDOWN),\n/* harmony export */   \"EVENT_ENDPOINT_MOUSEOUT\": () => (/* binding */ EVENT_ENDPOINT_MOUSEOUT),\n/* harmony export */   \"EVENT_ENDPOINT_MOUSEOVER\": () => (/* binding */ EVENT_ENDPOINT_MOUSEOVER),\n/* harmony export */   \"EVENT_ENDPOINT_MOUSEUP\": () => (/* binding */ EVENT_ENDPOINT_MOUSEUP),\n/* harmony export */   \"EVENT_ENDPOINT_TAP\": () => (/* binding */ EVENT_ENDPOINT_TAP),\n/* harmony export */   \"EVENT_FOCUS\": () => (/* binding */ EVENT_FOCUS),\n/* harmony export */   \"EVENT_MOUSEDOWN\": () => (/* binding */ EVENT_MOUSEDOWN),\n/* harmony export */   \"EVENT_MOUSEENTER\": () => (/* binding */ EVENT_MOUSEENTER),\n/* harmony export */   \"EVENT_MOUSEEXIT\": () => (/* binding */ EVENT_MOUSEEXIT),\n/* harmony export */   \"EVENT_MOUSEMOVE\": () => (/* binding */ EVENT_MOUSEMOVE),\n/* harmony export */   \"EVENT_MOUSEOUT\": () => (/* binding */ EVENT_MOUSEOUT),\n/* harmony export */   \"EVENT_MOUSEOVER\": () => (/* binding */ EVENT_MOUSEOVER),\n/* harmony export */   \"EVENT_MOUSEUP\": () => (/* binding */ EVENT_MOUSEUP),\n/* harmony export */   \"EVENT_OUT\": () => (/* binding */ EVENT_OUT),\n/* harmony export */   \"EVENT_OVER\": () => (/* binding */ EVENT_OVER),\n/* harmony export */   \"EVENT_REVERT\": () => (/* binding */ EVENT_REVERT),\n/* harmony export */   \"EVENT_START\": () => (/* binding */ EVENT_START),\n/* harmony export */   \"EVENT_STOP\": () => (/* binding */ EVENT_STOP),\n/* harmony export */   \"EVENT_TAP\": () => (/* binding */ EVENT_TAP),\n/* harmony export */   \"ElementDragHandler\": () => (/* binding */ ElementDragHandler),\n/* harmony export */   \"EventManager\": () => (/* binding */ EventManager),\n/* harmony export */   \"PROPERTY_POSITION\": () => (/* binding */ PROPERTY_POSITION),\n/* harmony export */   \"SELECTOR_CONNECTOR\": () => (/* binding */ SELECTOR_CONNECTOR),\n/* harmony export */   \"SELECTOR_ENDPOINT\": () => (/* binding */ SELECTOR_ENDPOINT),\n/* harmony export */   \"SELECTOR_GROUP\": () => (/* binding */ SELECTOR_GROUP),\n/* harmony export */   \"SELECTOR_GROUP_CONTAINER\": () => (/* binding */ SELECTOR_GROUP_CONTAINER),\n/* harmony export */   \"SELECTOR_OVERLAY\": () => (/* binding */ SELECTOR_OVERLAY),\n/* harmony export */   \"addClass\": () => (/* binding */ addClass),\n/* harmony export */   \"compoundEvent\": () => (/* binding */ compoundEvent),\n/* harmony export */   \"consume\": () => (/* binding */ consume),\n/* harmony export */   \"createElement\": () => (/* binding */ createElement),\n/* harmony export */   \"createElementNS\": () => (/* binding */ createElementNS),\n/* harmony export */   \"findParent\": () => (/* binding */ findParent),\n/* harmony export */   \"getClass\": () => (/* binding */ getClass),\n/* harmony export */   \"getEventSource\": () => (/* binding */ getEventSource),\n/* harmony export */   \"getPositionOnElement\": () => (/* binding */ getPositionOnElement),\n/* harmony export */   \"getTouch\": () => (/* binding */ getTouch),\n/* harmony export */   \"groupDragConstrain\": () => (/* binding */ groupDragConstrain),\n/* harmony export */   \"hasClass\": () => (/* binding */ hasClass),\n/* harmony export */   \"isArrayLike\": () => (/* binding */ isArrayLike),\n/* harmony export */   \"isInsideParent\": () => (/* binding */ isInsideParent),\n/* harmony export */   \"isNodeList\": () => (/* binding */ isNodeList),\n/* harmony export */   \"matchesSelector\": () => (/* binding */ matchesSelector$1),\n/* harmony export */   \"newInstance\": () => (/* binding */ newInstance),\n/* harmony export */   \"offsetRelativeToRoot\": () => (/* binding */ offsetRelativeToRoot),\n/* harmony export */   \"pageLocation\": () => (/* binding */ pageLocation),\n/* harmony export */   \"ready\": () => (/* binding */ ready),\n/* harmony export */   \"registerEndpointRenderer\": () => (/* binding */ registerEndpointRenderer),\n/* harmony export */   \"removeClass\": () => (/* binding */ removeClass),\n/* harmony export */   \"size\": () => (/* binding */ size),\n/* harmony export */   \"toggleClass\": () => (/* binding */ toggleClass),\n/* harmony export */   \"touchCount\": () => (/* binding */ touchCount),\n/* harmony export */   \"touches\": () => (/* binding */ touches)\n/* harmony export */ });\n/* harmony import */ var _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jsplumb/core */ \"./node_modules/@jsplumb/core/js/jsplumb.core.es.js\");\n/* harmony import */ var _jsplumb_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jsplumb/util */ \"./node_modules/@jsplumb/util/js/jsplumb.util.es.js\");\n/* harmony import */ var _jsplumb_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jsplumb/common */ \"./node_modules/@jsplumb/common/js/jsplumb.common.es.js\");\n\n\n\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction matchesSelector$1(el, selector, ctx) {\n  ctx = ctx || el.parentNode;\n  var possibles = ctx.querySelectorAll(selector);\n\n  for (var i = 0; i < possibles.length; i++) {\n    if (possibles[i] === el) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction consume(e, doNotPreventDefault) {\n  if (e.stopPropagation) {\n    e.stopPropagation();\n  } else {\n    e.returnValue = false;\n  }\n\n  if (!doNotPreventDefault && e.preventDefault) {\n    e.preventDefault();\n  }\n}\n\nfunction findParent(el, selector, container, matchOnElementAlso) {\n  if (matchOnElementAlso && matchesSelector$1(el, selector, container)) {\n    return el;\n  } else {\n    el = el.parentNode;\n  }\n\n  while (el != null && el !== container) {\n    if (matchesSelector$1(el, selector)) {\n      return el;\n    } else {\n      el = el.parentNode;\n    }\n  }\n}\n\nfunction getEventSource(e) {\n  return e.srcElement || e.target;\n}\n\nfunction _setClassName(el, cn, classList) {\n  cn = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.fastTrim)(cn);\n\n  if (typeof el.className.baseVal !== \"undefined\") {\n    el.className.baseVal = cn;\n  } else {\n    el.className = cn;\n  }\n\n  try {\n    var cl = el.classList;\n\n    if (cl != null) {\n      while (cl.length > 0) {\n        cl.remove(cl.item(0));\n      }\n\n      for (var i = 0; i < classList.length; i++) {\n        if (classList[i]) {\n          cl.add(classList[i]);\n        }\n      }\n    }\n  } catch (e) {\n    (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.log)(\"JSPLUMB: cannot set class list\", e);\n  }\n}\n\nfunction _getClassName(el) {\n  return el.className != null ? typeof el.className.baseVal === \"undefined\" ? el.className : el.className.baseVal : \"\";\n}\n\nfunction _classManip(el, classesToAdd, classesToRemove) {\n  var cta = classesToAdd == null ? [] : Array.isArray(classesToAdd) ? classesToAdd : classesToAdd.split(/\\s+/);\n  var ctr = classesToRemove == null ? [] : Array.isArray(classesToRemove) ? classesToRemove : classesToRemove.split(/\\s+/);\n\n  var className = _getClassName(el),\n      curClasses = className.split(/\\s+/);\n\n  var _oneSet = function _oneSet(add, classes) {\n    for (var i = 0; i < classes.length; i++) {\n      if (add) {\n        if (curClasses.indexOf(classes[i]) === -1) {\n          curClasses.push(classes[i]);\n        }\n      } else {\n        var idx = curClasses.indexOf(classes[i]);\n\n        if (idx !== -1) {\n          curClasses.splice(idx, 1);\n        }\n      }\n    }\n  };\n\n  _oneSet(true, cta);\n\n  _oneSet(false, ctr);\n\n  _setClassName(el, curClasses.join(\" \"), curClasses);\n}\n\nfunction isNodeList(el) {\n  return !(0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.isString)(el) && !Array.isArray(el) && el.length != null && el.documentElement == null && el.nodeType == null;\n}\n\nfunction isArrayLike(el) {\n  return !(0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.isString)(el) && (Array.isArray(el) || isNodeList(el));\n}\n\nfunction getClass(el) {\n  return _getClassName(el);\n}\n\nfunction addClass(el, clazz) {\n  var _one = function _one(el, clazz) {\n    if (el != null && clazz != null && clazz.length > 0) {\n      if (el.classList) {\n        var parts = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.fastTrim)(clazz).split(/\\s+/);\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(parts, function (part) {\n          el.classList.add(part);\n        });\n      } else {\n        _classManip(el, clazz);\n      }\n    }\n  };\n\n  if (isNodeList(el)) {\n    (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(el, function (el) {\n      return _one(el, clazz);\n    });\n  } else {\n    _one(el, clazz);\n  }\n}\n\nfunction hasClass(el, clazz) {\n  if (el.classList) {\n    return el.classList.contains(clazz);\n  } else {\n    return _getClassName(el).indexOf(clazz) !== -1;\n  }\n}\n\nfunction removeClass(el, clazz) {\n  var _one = function _one(el, clazz) {\n    if (el != null && clazz != null && clazz.length > 0) {\n      if (el.classList) {\n        var parts = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.fastTrim)(clazz).split(/\\s+/);\n        parts.forEach(function (part) {\n          el.classList.remove(part);\n        });\n      } else {\n        _classManip(el, null, clazz);\n      }\n    }\n  };\n\n  if (isNodeList(el)) {\n    (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(el, function (el) {\n      return _one(el, clazz);\n    });\n  } else {\n    _one(el, clazz);\n  }\n}\n\nfunction toggleClass(el, clazz) {\n  var _this = this;\n\n  var _one = function _one(el, clazz) {\n    if (el != null && clazz != null && clazz.length > 0) {\n      if (el.classList) {\n        el.classList.toggle(clazz);\n      } else {\n        if (_this.hasClass(el, clazz)) {\n          _this.removeClass(el, clazz);\n        } else {\n          _this.addClass(el, clazz);\n        }\n      }\n    }\n  };\n\n  if (isNodeList(el)) {\n    (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(el, function (el) {\n      return _one(el, clazz);\n    });\n  } else {\n    _one(el, clazz);\n  }\n}\n\nfunction createElement(tag, style, clazz, atts) {\n  return createElementNS(null, tag, style, clazz, atts);\n}\n\nfunction createElementNS(ns, tag, style, clazz, atts) {\n  var e = ns == null ? document.createElement(tag) : document.createElementNS(ns, tag);\n  var i;\n  style = style || {};\n\n  for (i in style) {\n    e.style[i] = style[i];\n  }\n\n  if (clazz) {\n    e.className = clazz;\n  }\n\n  atts = atts || {};\n\n  for (i in atts) {\n    e.setAttribute(i, \"\" + atts[i]);\n  }\n\n  return e;\n}\n\nfunction offsetRelativeToRoot(el) {\n  var box = el.getBoundingClientRect(),\n      body = document.body,\n      docElem = document.documentElement,\n      scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,\n      scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,\n      clientTop = docElem.clientTop || body.clientTop || 0,\n      clientLeft = docElem.clientLeft || body.clientLeft || 0,\n      top = box.top + scrollTop - clientTop,\n      left = box.left + scrollLeft - clientLeft;\n  return {\n    x: Math.round(left),\n    y: Math.round(top)\n  };\n}\n\nfunction size(el) {\n  return {\n    w: el.offsetWidth,\n    h: el.offsetHeight\n  };\n}\n\nvar svgAttributeMap = {\n  \"stroke-linejoin\": \"stroke-linejoin\",\n  \"stroke-dashoffset\": \"stroke-dashoffset\",\n  \"stroke-linecap\": \"stroke-linecap\"\n};\nvar STROKE_DASHARRAY = \"stroke-dasharray\";\nvar DASHSTYLE = \"dashstyle\";\nvar FILL = \"fill\";\nvar STROKE = \"stroke\";\nvar STROKE_WIDTH = \"stroke-width\";\nvar LINE_WIDTH = \"strokeWidth\";\nvar ELEMENT_SVG = \"svg\";\nvar ELEMENT_PATH = \"path\";\nvar ns = {\n  svg: \"http://www.w3.org/2000/svg\"\n};\n\nfunction _attr(node, attributes) {\n  for (var i in attributes) {\n    node.setAttribute(i, \"\" + attributes[i]);\n  }\n}\n\nfunction _node(name, attributes) {\n  attributes = attributes || {};\n  attributes.version = \"1.1\";\n  attributes.xmlns = ns.svg;\n  return createElementNS(ns.svg, name, null, null, attributes);\n}\n\nfunction _pos(d) {\n  return \"position:absolute;left:\" + d[0] + \"px;top:\" + d[1] + \"px\";\n}\n\nfunction _applyStyles(parent, node, style) {\n  node.setAttribute(FILL, style.fill ? style.fill : _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.NONE);\n  node.setAttribute(STROKE, style.stroke ? style.stroke : _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.NONE);\n\n  if (style.strokeWidth) {\n    node.setAttribute(STROKE_WIDTH, style.strokeWidth);\n  }\n\n  if (style[DASHSTYLE] && style[LINE_WIDTH] && !style[STROKE_DASHARRAY]) {\n    var sep = style[DASHSTYLE].indexOf(\",\") === -1 ? \" \" : \",\",\n        parts = style[DASHSTYLE].split(sep),\n        styleToUse = \"\";\n    (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(parts, function (p) {\n      styleToUse += Math.floor(p * style.strokeWidth) + sep;\n    });\n    node.setAttribute(STROKE_DASHARRAY, styleToUse);\n  } else if (style[STROKE_DASHARRAY]) {\n    node.setAttribute(STROKE_DASHARRAY, style[STROKE_DASHARRAY]);\n  }\n\n  for (var i in svgAttributeMap) {\n    if (style[i]) {\n      node.setAttribute(svgAttributeMap[i], style[i]);\n    }\n  }\n}\n\nfunction _appendAtIndex(svg, path, idx) {\n  if (svg.childNodes.length > idx) {\n    svg.insertBefore(path, svg.childNodes[idx]);\n  } else {\n    svg.appendChild(path);\n  }\n}\n\nfunction _size(svg, x, y, w, h) {\n  svg.style.width = w + \"px\";\n  svg.style.height = h + \"px\";\n  svg.style.left = x + \"px\";\n  svg.style.top = y + \"px\";\n  svg.height = h;\n  svg.width = w;\n}\n\nfunction compoundEvent(stem, event, subevent) {\n  var a = [stem, event];\n\n  if (subevent) {\n    a.push(subevent);\n  }\n\n  return a.join(\":\");\n}\n\nvar ATTRIBUTE_CONTAINER = \"data-jtk-container\";\nvar ATTRIBUTE_GROUP_CONTENT = \"data-jtk-group-content\";\nvar ATTRIBUTE_JTK_ENABLED = \"data-jtk-enabled\";\nvar ATTRIBUTE_JTK_SCOPE = \"data-jtk-scope\";\nvar ENDPOINT = \"endpoint\";\nvar ELEMENT = \"element\";\nvar CONNECTION = \"connection\";\nvar ELEMENT_DIV = \"div\";\nvar EVENT_CLICK = \"click\";\nvar EVENT_CONTEXTMENU = \"contextmenu\";\nvar EVENT_DBL_CLICK = \"dblclick\";\nvar EVENT_DBL_TAP = \"dbltap\";\nvar EVENT_FOCUS = \"focus\";\nvar EVENT_MOUSEDOWN = \"mousedown\";\nvar EVENT_MOUSEENTER = \"mouseenter\";\nvar EVENT_MOUSEEXIT = \"mouseexit\";\nvar EVENT_MOUSEMOVE = \"mousemove\";\nvar EVENT_MOUSEUP = \"mouseup\";\nvar EVENT_MOUSEOUT = \"mouseout\";\nvar EVENT_MOUSEOVER = \"mouseover\";\nvar EVENT_TAP = \"tap\";\nvar EVENT_DRAG_MOVE = \"drag:move\";\nvar EVENT_DRAG_STOP = \"drag:stop\";\nvar EVENT_DRAG_START = \"drag:start\";\nvar EVENT_REVERT = \"revert\";\nvar EVENT_CONNECTION_ABORT = \"connection:abort\";\nvar EVENT_CONNECTION_DRAG = \"connection:drag\";\nvar EVENT_ELEMENT_CLICK = compoundEvent(ELEMENT, EVENT_CLICK);\nvar EVENT_ELEMENT_DBL_CLICK = compoundEvent(ELEMENT, EVENT_DBL_CLICK);\nvar EVENT_ELEMENT_DBL_TAP = compoundEvent(ELEMENT, EVENT_DBL_TAP);\nvar EVENT_ELEMENT_MOUSE_OUT = compoundEvent(ELEMENT, EVENT_MOUSEOUT);\nvar EVENT_ELEMENT_MOUSE_OVER = compoundEvent(ELEMENT, EVENT_MOUSEOVER);\nvar EVENT_ELEMENT_MOUSE_MOVE = compoundEvent(ELEMENT, EVENT_MOUSEMOVE);\nvar EVENT_ELEMENT_MOUSE_UP = compoundEvent(ELEMENT, EVENT_MOUSEUP);\nvar EVENT_ELEMENT_MOUSE_DOWN = compoundEvent(ELEMENT, EVENT_MOUSEDOWN);\nvar EVENT_ELEMENT_CONTEXTMENU = compoundEvent(ELEMENT, EVENT_CONTEXTMENU);\nvar EVENT_ELEMENT_TAP = compoundEvent(ELEMENT, EVENT_TAP);\nvar EVENT_ENDPOINT_CLICK = compoundEvent(ENDPOINT, EVENT_CLICK);\nvar EVENT_ENDPOINT_DBL_CLICK = compoundEvent(ENDPOINT, EVENT_DBL_CLICK);\nvar EVENT_ENDPOINT_DBL_TAP = compoundEvent(ENDPOINT, EVENT_DBL_TAP);\nvar EVENT_ENDPOINT_MOUSEOUT = compoundEvent(ENDPOINT, EVENT_MOUSEOUT);\nvar EVENT_ENDPOINT_MOUSEOVER = compoundEvent(ENDPOINT, EVENT_MOUSEOVER);\nvar EVENT_ENDPOINT_MOUSEUP = compoundEvent(ENDPOINT, EVENT_MOUSEUP);\nvar EVENT_ENDPOINT_MOUSEDOWN = compoundEvent(ENDPOINT, EVENT_MOUSEDOWN);\nvar EVENT_ENDPOINT_TAP = compoundEvent(ENDPOINT, EVENT_TAP);\nvar EVENT_CONNECTION_CLICK = compoundEvent(CONNECTION, EVENT_CLICK);\nvar EVENT_CONNECTION_DBL_CLICK = compoundEvent(CONNECTION, EVENT_DBL_CLICK);\nvar EVENT_CONNECTION_DBL_TAP = compoundEvent(CONNECTION, EVENT_DBL_TAP);\nvar EVENT_CONNECTION_MOUSEOUT = compoundEvent(CONNECTION, EVENT_MOUSEOUT);\nvar EVENT_CONNECTION_MOUSEOVER = compoundEvent(CONNECTION, EVENT_MOUSEOVER);\nvar EVENT_CONNECTION_MOUSEUP = compoundEvent(CONNECTION, EVENT_MOUSEUP);\nvar EVENT_CONNECTION_MOUSEDOWN = compoundEvent(CONNECTION, EVENT_MOUSEDOWN);\nvar EVENT_CONNECTION_CONTEXTMENU = compoundEvent(CONNECTION, EVENT_CONTEXTMENU);\nvar EVENT_CONNECTION_TAP = compoundEvent(CONNECTION, EVENT_TAP);\nvar PROPERTY_POSITION = \"position\";\nvar SELECTOR_CONNECTOR = (0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.cls)(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.CLASS_CONNECTOR);\nvar SELECTOR_ENDPOINT = (0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.cls)(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.CLASS_ENDPOINT);\nvar SELECTOR_GROUP = (0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.att)(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.ATTRIBUTE_GROUP);\nvar SELECTOR_GROUP_CONTAINER = (0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.att)(ATTRIBUTE_GROUP_CONTENT);\nvar SELECTOR_OVERLAY = (0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.cls)(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.CLASS_OVERLAY);\n\nfunction _touch(target, pageX, pageY, screenX, screenY, clientX, clientY) {\n  return new Touch({\n    target: target,\n    identifier: (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.uuid)(),\n    pageX: pageX,\n    pageY: pageY,\n    screenX: screenX,\n    screenY: screenY,\n    clientX: clientX || screenX,\n    clientY: clientY || screenY\n  });\n}\n\nfunction _touchList() {\n  var list = [];\n  list.push.apply(list, arguments);\n\n  list.item = function (index) {\n    return this[index];\n  };\n\n  return list;\n}\n\nfunction _touchAndList(target, pageX, pageY, screenX, screenY, clientX, clientY) {\n  return _touchList(_touch(target, pageX, pageY, screenX, screenY, clientX, clientY));\n}\n\nfunction matchesSelector(el, selector, ctx) {\n  ctx = ctx || el.parentNode;\n  var possibles = ctx.querySelectorAll(selector);\n\n  for (var i = 0; i < possibles.length; i++) {\n    if (possibles[i] === el) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction _t(e) {\n  return e.srcElement || e.target;\n}\n\nfunction _pi(e, target, obj, doCompute) {\n  if (!doCompute) return {\n    path: [target],\n    end: 1\n  };else if (typeof e.path !== \"undefined\" && e.path.indexOf) {\n    return {\n      path: e.path,\n      end: e.path.indexOf(obj)\n    };\n  } else {\n    var out = {\n      path: [],\n      end: -1\n    },\n        _one = function _one(el) {\n      out.path.push(el);\n\n      if (el === obj) {\n        out.end = out.path.length - 1;\n      } else if (el.parentNode != null) {\n        _one(el.parentNode);\n      }\n    };\n\n    _one(target);\n\n    return out;\n  }\n}\n\nfunction _d(l, fn) {\n  var i = 0,\n      j;\n\n  for (i = 0, j = l.length; i < j; i++) {\n    if (l[i][0] === fn) {\n      break;\n    }\n  }\n\n  if (i < l.length) {\n    l.splice(i, 1);\n  }\n}\n\nvar guid = 1;\n\nfunction isTouchDevice() {\n  return \"ontouchstart\" in document.documentElement || navigator.maxTouchPoints != null && navigator.maxTouchPoints > 0;\n}\n\nfunction isMouseDevice() {\n  return \"onmousedown\" in document.documentElement;\n}\n\nvar touchMap = {\n  \"mousedown\": \"touchstart\",\n  \"mouseup\": \"touchend\",\n  \"mousemove\": \"touchmove\"\n};\nvar PAGE = \"page\";\nvar SCREEN = \"screen\";\nvar CLIENT = \"client\";\n\nfunction _genLoc(e, prefix) {\n  if (e == null) return {\n    x: 0,\n    y: 0\n  };\n  var ts = touches(e),\n      t = getTouch(ts, 0);\n  return {\n    x: t[prefix + \"X\"],\n    y: t[prefix + \"Y\"]\n  };\n}\n\nfunction pageLocation(e) {\n  return _genLoc(e, PAGE);\n}\n\nfunction screenLocation(e) {\n  return _genLoc(e, SCREEN);\n}\n\nfunction clientLocation(e) {\n  return _genLoc(e, CLIENT);\n}\n\nfunction getTouch(touches, idx) {\n  return touches.item ? touches.item(idx) : touches[idx];\n}\n\nfunction touches(e) {\n  return e.touches && e.touches.length > 0 ? e.touches : e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches : e.targetTouches && e.targetTouches.length > 0 ? e.targetTouches : [e];\n}\n\nfunction touchCount(e) {\n  return touches(e).length;\n}\n\nfunction _bind(obj, type, fn, originalFn, options) {\n  _store(obj, type, fn);\n\n  originalFn.__tauid = fn.__tauid;\n\n  if (obj.addEventListener) {\n    obj.addEventListener(type, fn, false, options);\n  } else if (obj.attachEvent) {\n    var key = type + fn.__tauid;\n    obj[\"e\" + key] = fn;\n\n    obj[key] = function () {\n      obj[\"e\" + key] && obj[\"e\" + key](window.event);\n    };\n\n    obj.attachEvent(\"on\" + type, obj[key]);\n  }\n}\n\nfunction _unbind(obj, type, fn) {\n  var _this = this;\n\n  if (fn == null) return;\n\n  _each$1(obj, function (_el) {\n    _unstore(_el, type, fn);\n\n    if (fn.__tauid != null) {\n      if (_el.removeEventListener) {\n        _el.removeEventListener(type, fn, false);\n\n        if (isTouchDevice() && touchMap[type]) _el.removeEventListener(touchMap[type], fn, false);\n      } else if (_this.detachEvent) {\n        var key = type + fn.__tauid;\n        _el[key] && _el.detachEvent(\"on\" + type, _el[key]);\n        _el[key] = null;\n        _el[\"e\" + key] = null;\n      }\n    }\n\n    if (fn.__taTouchProxy) {\n      _unbind(obj, fn.__taTouchProxy[1], fn.__taTouchProxy[0]);\n    }\n  });\n}\n\nfunction _each$1(obj, fn) {\n  if (obj == null) return;\n  var entries = typeof obj === \"string\" ? document.querySelectorAll(obj) : obj.length != null ? obj : [obj];\n\n  for (var i = 0; i < entries.length; i++) {\n    fn(entries[i]);\n  }\n}\n\nfunction _store(obj, event, fn) {\n  var g = guid++;\n  obj.__ta = obj.__ta || {};\n  obj.__ta[event] = obj.__ta[event] || {};\n  obj.__ta[event][g] = fn;\n  fn.__tauid = g;\n  return g;\n}\n\nfunction _unstore(obj, event, fn) {\n  obj.__ta && obj.__ta[event] && delete obj.__ta[event][fn.__tauid];\n\n  if (fn.__taExtra) {\n    for (var i = 0; i < fn.__taExtra.length; i++) {\n      _unbind(obj, fn.__taExtra[i][0], fn.__taExtra[i][1]);\n    }\n\n    fn.__taExtra.length = 0;\n  }\n\n  fn.__taUnstore && fn.__taUnstore();\n}\n\nvar NOT_SELECTOR_REGEX = /:not\\(([^)]+)\\)/;\n\nfunction _curryChildFilter(children, obj, fn, evt) {\n  if (children == null) {\n    return fn;\n  } else {\n    var c = children.split(\",\"),\n        pc = [],\n        nc = [];\n    (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(c, function (sel) {\n      var m = sel.match(NOT_SELECTOR_REGEX);\n\n      if (m != null) {\n        nc.push(m[1]);\n      } else {\n        pc.push(sel);\n      }\n    });\n\n    if (nc.length > 0 && pc.length === 0) {\n      pc.push(_jsplumb_common__WEBPACK_IMPORTED_MODULE_2__.WILDCARD);\n    }\n\n    var _fn = function _fn(e) {\n      _fn.__tauid = fn.__tauid;\n\n      var t = _t(e);\n\n      var done = false;\n      var target = t;\n\n      var pathInfo = _pi(e, t, obj, children != null);\n\n      if (pathInfo.end != -1) {\n        for (var p = 0; !done && p < pathInfo.end; p++) {\n          target = pathInfo.path[p];\n\n          for (var i = 0; i < nc.length; i++) {\n            if (matchesSelector(target, nc[i], obj)) {\n              return;\n            }\n          }\n\n          for (var _i = 0; !done && _i < pc.length; _i++) {\n            if (matchesSelector(target, pc[_i], obj)) {\n              fn.apply(target, [e, target]);\n              done = true;\n              break;\n            }\n          }\n        }\n      }\n    };\n\n    registerExtraFunction(fn, evt, _fn);\n    return _fn;\n  }\n}\n\nfunction registerExtraFunction(fn, evt, newFn) {\n  fn.__taExtra = fn.__taExtra || [];\n\n  fn.__taExtra.push([evt, newFn]);\n}\n\nvar DefaultHandler = function DefaultHandler(obj, evt, fn, children, options) {\n  if (isTouchDevice() && touchMap[evt]) {\n    var tfn = _curryChildFilter(children, obj, fn, touchMap[evt]);\n\n    _bind(obj, touchMap[evt], tfn, fn, options);\n  }\n\n  if (evt === EVENT_FOCUS && obj.getAttribute(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.ATTRIBUTE_TABINDEX) == null) {\n    obj.setAttribute(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.ATTRIBUTE_TABINDEX, \"1\");\n  }\n\n  _bind(obj, evt, _curryChildFilter(children, obj, fn, evt), fn, options);\n};\n\nvar _tapProfiles = {\n  \"tap\": {\n    touches: 1,\n    taps: 1\n  },\n  \"dbltap\": {\n    touches: 1,\n    taps: 2\n  },\n  \"contextmenu\": {\n    touches: 2,\n    taps: 1\n  }\n};\n\nfunction meeHelper(type, evt, obj, target) {\n  for (var i in obj.__tamee[type]) {\n    if (obj.__tamee[type].hasOwnProperty(i)) {\n      obj.__tamee[type][i].apply(target, [evt]);\n    }\n  }\n}\n\nvar TapHandler = function () {\n  function TapHandler() {\n    _classCallCheck(this, TapHandler);\n  }\n\n  _createClass(TapHandler, null, [{\n    key: \"generate\",\n    value: function generate(clickThreshold, dblClickThreshold) {\n      return function (obj, evt, fn, children) {\n        if (evt == EVENT_CONTEXTMENU && isMouseDevice()) DefaultHandler(obj, evt, fn, children);else {\n          if (obj.__taTapHandler == null) {\n            var tt = obj.__taTapHandler = {\n              tap: [],\n              dbltap: [],\n              down: false,\n              taps: 0,\n              downSelectors: []\n            };\n\n            var down = function down(e) {\n              var target = _t(e),\n                  pathInfo = _pi(e, target, obj, children != null),\n                  finished = false;\n\n              for (var p = 0; p < pathInfo.end; p++) {\n                if (finished) return;\n                target = pathInfo.path[p];\n\n                for (var i = 0; i < tt.downSelectors.length; i++) {\n                  if (tt.downSelectors[i] == null || matchesSelector(target, tt.downSelectors[i], obj)) {\n                    tt.down = true;\n                    setTimeout(clearSingle, clickThreshold);\n                    setTimeout(clearDouble, dblClickThreshold);\n                    finished = true;\n                    break;\n                  }\n                }\n              }\n            },\n                up = function up(e) {\n              if (tt.down) {\n                var target = _t(e),\n                    currentTarget,\n                    pathInfo;\n\n                tt.taps++;\n                var tc = touchCount(e);\n\n                for (var eventId in _tapProfiles) {\n                  if (_tapProfiles.hasOwnProperty(eventId)) {\n                    var p = _tapProfiles[eventId];\n\n                    if (p.touches === tc && (p.taps === 1 || p.taps === tt.taps)) {\n                      for (var i = 0; i < tt[eventId].length; i++) {\n                        pathInfo = _pi(e, target, obj, tt[eventId][i][1] != null);\n\n                        for (var pLoop = 0; pLoop < pathInfo.end; pLoop++) {\n                          currentTarget = pathInfo.path[pLoop];\n\n                          if (tt[eventId][i][1] == null || matchesSelector(currentTarget, tt[eventId][i][1], obj)) {\n                            tt[eventId][i][0].apply(currentTarget, [e, currentTarget]);\n                            break;\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            },\n                clearSingle = function clearSingle() {\n              tt.down = false;\n            },\n                clearDouble = function clearDouble() {\n              tt.taps = 0;\n            };\n\n            obj.__taTapHandler.downHandler = down;\n            obj.__taTapHandler.upHandler = up;\n            DefaultHandler(obj, EVENT_MOUSEDOWN, down);\n            DefaultHandler(obj, EVENT_MOUSEUP, up);\n          }\n\n          obj.__taTapHandler.downSelectors.push(children);\n\n          obj.__taTapHandler[evt].push([fn, children]);\n\n          fn.__taUnstore = function () {\n            if (obj.__taTapHandler != null) {\n              (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.removeWithFunction)(obj.__taTapHandler.downSelectors, function (ds) {\n                return ds === children;\n              });\n\n              _d(obj.__taTapHandler[evt], fn);\n\n              if (obj.__taTapHandler.downSelectors.length === 0) {\n                _unbind(obj, EVENT_MOUSEDOWN, obj.__taTapHandler.downHandler);\n\n                _unbind(obj, EVENT_MOUSEUP, obj.__taTapHandler.upHandler);\n\n                delete obj.__taTapHandler;\n              }\n            }\n          };\n        }\n      };\n    }\n  }]);\n\n  return TapHandler;\n}();\n\nvar MouseEnterExitHandler = function () {\n  function MouseEnterExitHandler() {\n    _classCallCheck(this, MouseEnterExitHandler);\n  }\n\n  _createClass(MouseEnterExitHandler, null, [{\n    key: \"generate\",\n    value: function generate() {\n      var activeElements = [];\n      return function (obj, evt, fn, children) {\n        if (!obj.__tamee) {\n          obj.__tamee = {\n            over: false,\n            mouseenter: [],\n            mouseexit: []\n          };\n\n          var over = function over(e) {\n            var t = _t(e);\n\n            if (children == null && t == obj && !obj.__tamee.over || matchesSelector(t, children, obj) && (t.__tamee == null || !t.__tamee.over)) {\n              meeHelper(EVENT_MOUSEENTER, e, obj, t);\n              t.__tamee = t.__tamee || {};\n              t.__tamee.over = true;\n              activeElements.push(t);\n            }\n          },\n              out = function out(e) {\n            var t = _t(e);\n\n            for (var i = 0; i < activeElements.length; i++) {\n              if (t == activeElements[i] && !matchesSelector(e.relatedTarget || e.toElement, \"*\", t)) {\n                t.__tamee.over = false;\n                activeElements.splice(i, 1);\n                meeHelper(EVENT_MOUSEEXIT, e, obj, t);\n              }\n            }\n          };\n\n          _bind(obj, EVENT_MOUSEOVER, _curryChildFilter(children, obj, over, EVENT_MOUSEOVER), over);\n\n          _bind(obj, EVENT_MOUSEOUT, _curryChildFilter(children, obj, out, EVENT_MOUSEOUT), out);\n        }\n\n        fn.__taUnstore = function () {\n          delete obj.__tamee[evt][fn.__tauid];\n        };\n\n        _store(obj, evt, fn);\n\n        obj.__tamee[evt][fn.__tauid] = fn;\n      };\n    }\n  }]);\n\n  return MouseEnterExitHandler;\n}();\n\nvar EventManager = function () {\n  function EventManager(params) {\n    _classCallCheck(this, EventManager);\n\n    _defineProperty(this, \"clickThreshold\", void 0);\n\n    _defineProperty(this, \"dblClickThreshold\", void 0);\n\n    _defineProperty(this, \"tapHandler\", void 0);\n\n    _defineProperty(this, \"mouseEnterExitHandler\", void 0);\n\n    params = params || {};\n    this.clickThreshold = params.clickThreshold || 250;\n    this.dblClickThreshold = params.dblClickThreshold || 450;\n    this.mouseEnterExitHandler = MouseEnterExitHandler.generate();\n    this.tapHandler = TapHandler.generate(this.clickThreshold, this.dblClickThreshold);\n  }\n\n  _createClass(EventManager, [{\n    key: \"_doBind\",\n    value: function _doBind(el, evt, fn, children, options) {\n      if (fn == null) return;\n      var jel = el;\n\n      if (evt === EVENT_TAP || evt === EVENT_DBL_TAP || evt === EVENT_CONTEXTMENU) {\n        this.tapHandler(jel, evt, fn, children, options);\n      } else if (evt === EVENT_MOUSEENTER || evt == EVENT_MOUSEEXIT) this.mouseEnterExitHandler(jel, evt, fn, children, options);else {\n        DefaultHandler(jel, evt, fn, children, options);\n      }\n    }\n  }, {\n    key: \"on\",\n    value: function on(el, event, children, fn, options) {\n      var _c = fn == null ? null : children,\n          _f = fn == null ? children : fn;\n\n      this._doBind(el, event, _f, _c, options);\n\n      return this;\n    }\n  }, {\n    key: \"off\",\n    value: function off(el, event, fn) {\n      _unbind(el, event, fn);\n\n      return this;\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(el, event, originalEvent, payload, detail) {\n      var originalIsMouse = isMouseDevice() && (typeof MouseEvent === \"undefined\" || originalEvent == null || originalEvent.constructor === MouseEvent);\n      var eventToBind = isTouchDevice() && !isMouseDevice() && touchMap[event] ? touchMap[event] : event,\n          bindingAMouseEvent = !(isTouchDevice() && !isMouseDevice() && touchMap[event]);\n      var pl = pageLocation(originalEvent),\n          sl = screenLocation(originalEvent),\n          cl = clientLocation(originalEvent);\n\n      _each$1(el, function (_el) {\n        var evt;\n        originalEvent = originalEvent || {\n          screenX: sl.x,\n          screenY: sl.y,\n          clientX: cl.x,\n          clientY: cl.y\n        };\n\n        var _decorate = function _decorate(_evt) {\n          if (payload) {\n            _evt.payload = payload;\n          }\n        };\n\n        var eventGenerators = {\n          \"TouchEvent\": function TouchEvent(evt) {\n            var touchList = _touchAndList(_el, pl.x, pl.y, sl.x, sl.y, cl.x, cl.y),\n                init = evt.initTouchEvent || evt.initEvent;\n\n            init(eventToBind, true, true, window, null, sl.x, sl.y, cl.x, cl.y, false, false, false, false, touchList, touchList, touchList, 1, 0);\n          },\n          \"MouseEvents\": function MouseEvents(evt) {\n            evt.initMouseEvent(eventToBind, true, true, window, detail == null ? 1 : detail, sl.x, sl.y, cl.x, cl.y, false, false, false, false, 1, _el);\n          }\n        };\n        var ite = !bindingAMouseEvent && !originalIsMouse && isTouchDevice() && touchMap[event],\n            evtName = ite ? \"TouchEvent\" : \"MouseEvents\";\n        evt = document.createEvent(evtName);\n        eventGenerators[evtName](evt);\n\n        _decorate(evt);\n\n        _el.dispatchEvent(evt);\n      });\n\n      return this;\n    }\n  }]);\n\n  return EventManager;\n}();\n\nfunction findDelegateElement(parentElement, childElement, selector) {\n  if (matchesSelector$1(childElement, selector, parentElement)) {\n    return childElement;\n  } else {\n    var currentParent = childElement.parentNode;\n\n    while (currentParent != null && currentParent !== parentElement) {\n      if (matchesSelector$1(currentParent, selector, parentElement)) {\n        return currentParent;\n      } else {\n        currentParent = currentParent.parentNode;\n      }\n    }\n  }\n}\n\nfunction _getPosition(el) {\n  return {\n    x: el.offsetLeft,\n    y: el.offsetTop\n  };\n}\n\nfunction _getSize(el) {\n  return {\n    w: el.offsetWidth,\n    h: el.offsetHeight\n  };\n}\n\nfunction _setPosition(el, pos) {\n  el.style.left = pos.x + \"px\";\n  el.style.top = pos.y + \"px\";\n}\n\nfunction _assignId(obj) {\n  if (typeof obj === \"function\") {\n    obj._katavorioId = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.uuid)();\n    return obj._katavorioId;\n  } else {\n    return obj;\n  }\n}\n\nfunction isInsideParent(instance, _el, pos) {\n  var p = _el.parentNode,\n      s = instance.getSize(p),\n      ss = instance.getSize(_el),\n      leftEdge = pos.x,\n      rightEdge = leftEdge + ss.w,\n      topEdge = pos.y,\n      bottomEdge = topEdge + ss.h;\n  return rightEdge > 0 && leftEdge < s.w && bottomEdge > 0 && topEdge < s.h;\n}\n\nfunction findMatchingSelector(availableSelectors, parentElement, childElement) {\n  var el = null;\n  var draggableId = parentElement.getAttribute(\"katavorio-draggable\"),\n      prefix = draggableId != null ? \"[katavorio-draggable='\" + draggableId + \"'] \" : \"\";\n\n  for (var i = 0; i < availableSelectors.length; i++) {\n    el = findDelegateElement(parentElement, childElement, prefix + availableSelectors[i].selector);\n\n    if (el != null) {\n      if (availableSelectors[i].filter) {\n        var matches = matchesSelector$1(childElement, availableSelectors[i].filter, el),\n            exclude = availableSelectors[i].filterExclude === true;\n\n        if (exclude && !matches || matches) {\n          return null;\n        }\n      }\n\n      return [availableSelectors[i], el];\n    }\n  }\n\n  return null;\n}\n\nvar EVENT_START = \"start\";\nvar EVENT_BEFORE_START = \"beforeStart\";\nvar EVENT_DRAG = \"drag\";\nvar EVENT_DROP = \"drop\";\nvar EVENT_OVER = \"over\";\nvar EVENT_OUT = \"out\";\nvar EVENT_STOP = \"stop\";\nvar ATTRIBUTE_DRAGGABLE = \"katavorio-draggable\";\nvar CLASS_DRAGGABLE$1 = ATTRIBUTE_DRAGGABLE;\nvar DEFAULT_GRID_X = 10;\nvar DEFAULT_GRID_Y = 10;\n\nvar TRUE = function TRUE() {\n  return true;\n};\n\nvar FALSE = function FALSE() {\n  return false;\n};\n\nvar _classes = {\n  delegatedDraggable: \"katavorio-delegated-draggable\",\n  draggable: CLASS_DRAGGABLE$1,\n  drag: \"katavorio-drag\",\n  selected: \"katavorio-drag-selected\",\n  noSelect: \"katavorio-drag-no-select\",\n  ghostProxy: \"katavorio-ghost-proxy\",\n  clonedDrag: \"katavorio-clone-drag\"\n};\nvar _events = [EVENT_STOP, EVENT_START, EVENT_DRAG, EVENT_DROP, EVENT_OVER, EVENT_OUT, EVENT_BEFORE_START];\n\nvar _devNull = function _devNull() {};\n\nvar _each = function _each(obj, fn) {\n  if (obj == null) return;\n  obj = !(0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.isString)(obj) && obj.tagName == null && obj.length != null ? obj : [obj];\n\n  for (var i = 0; i < obj.length; i++) {\n    fn.apply(obj[i], [obj[i]]);\n  }\n};\n\nvar _inputFilter = function _inputFilter(e, el, collicat) {\n  var t = e.srcElement || e.target;\n  return !matchesSelector$1(t, collicat.getInputFilterSelector(), el);\n};\n\nvar Base = function () {\n  function Base(el, k) {\n    _classCallCheck(this, Base);\n\n    this.el = el;\n    this.k = k;\n\n    _defineProperty(this, \"_class\", void 0);\n\n    _defineProperty(this, \"uuid\", (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.uuid)());\n\n    _defineProperty(this, \"enabled\", true);\n\n    _defineProperty(this, \"scopes\", []);\n  }\n\n  _createClass(Base, [{\n    key: \"setEnabled\",\n    value: function setEnabled(e) {\n      this.enabled = e;\n    }\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      return this.enabled;\n    }\n  }, {\n    key: \"toggleEnabled\",\n    value: function toggleEnabled() {\n      this.enabled = !this.enabled;\n    }\n  }, {\n    key: \"addScope\",\n    value: function addScope(scopes) {\n      var m = {};\n\n      _each(this.scopes, function (s) {\n        m[s] = true;\n      });\n\n      _each(scopes ? scopes.split(/\\s+/) : [], function (s) {\n        m[s] = true;\n      });\n\n      this.scopes.length = 0;\n\n      for (var i in m) {\n        this.scopes.push(i);\n      }\n    }\n  }, {\n    key: \"removeScope\",\n    value: function removeScope(scopes) {\n      var m = {};\n\n      _each(this.scopes, function (s) {\n        m[s] = true;\n      });\n\n      _each(scopes ? scopes.split(/\\s+/) : [], function (s) {\n        delete m[s];\n      });\n\n      this.scopes.length = 0;\n\n      for (var i in m) {\n        this.scopes.push(i);\n      }\n    }\n  }, {\n    key: \"toggleScope\",\n    value: function toggleScope(scopes) {\n      var m = {};\n\n      _each(this.scopes, function (s) {\n        m[s] = true;\n      });\n\n      _each(scopes ? scopes.split(/\\s+/) : [], function (s) {\n        if (m[s]) delete m[s];else m[s] = true;\n      });\n\n      this.scopes.length = 0;\n\n      for (var i in m) {\n        this.scopes.push(i);\n      }\n    }\n  }]);\n\n  return Base;\n}();\n\nfunction getConstrainingRectangle(el) {\n  return {\n    w: el.parentNode.offsetWidth + el.parentNode.scrollLeft,\n    h: el.parentNode.offsetHeight + el.parentNode.scrollTop\n  };\n}\n\nvar ContainmentType;\n\n(function (ContainmentType) {\n  ContainmentType[\"notNegative\"] = \"notNegative\";\n  ContainmentType[\"parent\"] = \"parent\";\n  ContainmentType[\"parentEnclosed\"] = \"parentEnclosed\";\n})(ContainmentType || (ContainmentType = {}));\n\nvar Drag = function (_Base) {\n  _inherits(Drag, _Base);\n\n  var _super = _createSuper(Drag);\n\n  function Drag(el, params, k) {\n    var _this;\n\n    _classCallCheck(this, Drag);\n\n    _this = _super.call(this, el, k);\n\n    _defineProperty(_assertThisInitialized(_this), \"_class\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"rightButtonCanDrag\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"consumeStartEvent\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"clone\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"scroll\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"trackScroll\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_downAt\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_posAtDown\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_pagePosAtDown\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_pageDelta\", {\n      x: 0,\n      y: 0\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_moving\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_lastPosition\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_lastScrollValues\", {\n      x: 0,\n      y: 0\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_initialScroll\", {\n      x: 0,\n      y: 0\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_size\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_currentParentPosition\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_ghostParentPosition\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_dragEl\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_multipleDrop\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_ghostProxyOffsets\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_ghostDx\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_ghostDy\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_isConstrained\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"_ghostProxyParent\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_useGhostProxy\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_ghostProxyFunction\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_activeSelectorParams\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_availableSelectors\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"_canDrag\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_consumeFilteredEvents\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_parent\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_ignoreZoom\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_filters\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"_constrainRect\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_elementToDrag\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"downListener\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"moveListener\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"upListener\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"scrollTracker\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"listeners\", {\n      \"start\": [],\n      \"drag\": [],\n      \"stop\": [],\n      \"over\": [],\n      \"out\": [],\n      \"beforeStart\": [],\n      \"revert\": []\n    });\n\n    _this._class = _this.k.css.draggable;\n    addClass(_this.el, _this._class);\n    _this.downListener = _this._downListener.bind(_assertThisInitialized(_this));\n    _this.upListener = _this._upListener.bind(_assertThisInitialized(_this));\n    _this.moveListener = _this._moveListener.bind(_assertThisInitialized(_this));\n    _this.rightButtonCanDrag = params.rightButtonCanDrag === true;\n    _this.consumeStartEvent = params.consumeStartEvent !== false;\n    _this._dragEl = _this.el;\n    _this.clone = params.clone === true;\n    _this.scroll = params.scroll === true;\n    _this.trackScroll = params.trackScroll !== false;\n    _this._multipleDrop = params.multipleDrop !== false;\n    _this._canDrag = params.canDrag || TRUE;\n    _this._consumeFilteredEvents = params.consumeFilteredEvents;\n    _this._parent = params.parent;\n    _this._ignoreZoom = params.ignoreZoom === true;\n    _this._ghostProxyParent = params.ghostProxyParent;\n\n    if (_this.trackScroll) {\n      _this.scrollTracker = _this._trackScroll.bind(_assertThisInitialized(_this));\n      document.addEventListener(\"scroll\", _this.scrollTracker);\n    }\n\n    if (params.ghostProxy === true) {\n      _this._useGhostProxy = TRUE;\n    } else {\n      if (params.ghostProxy && typeof params.ghostProxy === \"function\") {\n        _this._useGhostProxy = params.ghostProxy;\n      } else {\n        _this._useGhostProxy = function (container, dragEl) {\n          if (_this._activeSelectorParams && _this._activeSelectorParams.useGhostProxy) {\n            return _this._activeSelectorParams.useGhostProxy(container, dragEl);\n          } else {\n            return false;\n          }\n        };\n      }\n    }\n\n    if (params.makeGhostProxy) {\n      _this._ghostProxyFunction = params.makeGhostProxy;\n    } else {\n      _this._ghostProxyFunction = function (el) {\n        if (_this._activeSelectorParams && _this._activeSelectorParams.makeGhostProxy) {\n          return _this._activeSelectorParams.makeGhostProxy(el);\n        } else {\n          return el.cloneNode(true);\n        }\n      };\n    }\n\n    if (params.selector) {\n      var draggableId = _this.el.getAttribute(ATTRIBUTE_DRAGGABLE);\n\n      if (draggableId == null) {\n        draggableId = \"\" + new Date().getTime();\n\n        _this.el.setAttribute(\"katavorio-draggable\", draggableId);\n      }\n\n      _this._availableSelectors.push(params);\n    }\n\n    _this.k.eventManager.on(_this.el, EVENT_MOUSEDOWN, _this.downListener);\n\n    return _this;\n  }\n\n  _createClass(Drag, [{\n    key: \"_trackScroll\",\n    value: function _trackScroll(e) {\n      if (this._moving) {\n        var currentScrollValues = {\n          x: document.documentElement.scrollLeft,\n          y: document.documentElement.scrollTop\n        },\n            dsx = currentScrollValues.x - this._lastScrollValues.x,\n            dsy = currentScrollValues.y - this._lastScrollValues.y,\n            _pos = {\n          x: dsx + this._lastPosition.x,\n          y: dsy + this._lastPosition.y\n        },\n            dx = _pos.x - this._downAt.x,\n            dy = _pos.y - this._downAt.y,\n            _z = this._ignoreZoom ? 1 : this.k.getZoom();\n\n        if (this._dragEl && this._dragEl.parentNode) {\n          dx += this._dragEl.parentNode.scrollLeft - this._initialScroll.x;\n          dy += this._dragEl.parentNode.scrollTop - this._initialScroll.y;\n        }\n\n        dx /= _z;\n        dy /= _z;\n        this.moveBy(dx, dy, e);\n        this._lastPosition = _pos;\n        this._lastScrollValues = currentScrollValues;\n      }\n    }\n  }, {\n    key: \"on\",\n    value: function on(evt, fn) {\n      if (this.listeners[evt]) {\n        this.listeners[evt].push(fn);\n      }\n    }\n  }, {\n    key: \"off\",\n    value: function off(evt, fn) {\n      if (this.listeners[evt]) {\n        var l = [];\n\n        for (var i = 0; i < this.listeners[evt].length; i++) {\n          if (this.listeners[evt][i] !== fn) {\n            l.push(this.listeners[evt][i]);\n          }\n        }\n\n        this.listeners[evt] = l;\n      }\n    }\n  }, {\n    key: \"_upListener\",\n    value: function _upListener(e) {\n      if (this._downAt) {\n        this._downAt = null;\n        this.k.eventManager.off(document, EVENT_MOUSEMOVE, this.moveListener);\n        this.k.eventManager.off(document, EVENT_MOUSEUP, this.upListener);\n        removeClass(document.body, _classes.noSelect);\n        this.unmark(e);\n        this.stop(e);\n        this._moving = false;\n\n        if (this.clone) {\n          this._dragEl && this._dragEl.parentNode && this._dragEl.parentNode.removeChild(this._dragEl);\n          this._dragEl = null;\n        } else {\n          if (this._activeSelectorParams && this._activeSelectorParams.revertFunction) {\n            if (this._activeSelectorParams.revertFunction(this._dragEl, _getPosition(this._dragEl)) === true) {\n              _setPosition(this._dragEl, this._posAtDown);\n\n              this._dispatch(EVENT_REVERT, this._dragEl);\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_downListener\",\n    value: function _downListener(e) {\n      if (e.defaultPrevented) {\n        return;\n      }\n\n      var isNotRightClick = this.rightButtonCanDrag || e.which !== 3 && e.button !== 2;\n\n      if (isNotRightClick && this.isEnabled() && this._canDrag()) {\n        var _f = this._testFilter(e) && _inputFilter(e, this.el, this.k);\n\n        if (_f) {\n          this._activeSelectorParams = null;\n          this._elementToDrag = null;\n\n          if (this._availableSelectors.length === 0) {\n            console.log(\"JSPLUMB: no available drag selectors\");\n          }\n\n          var eventTarget = e.target || e.srcElement;\n          var match = findMatchingSelector(this._availableSelectors, this.el, eventTarget);\n\n          if (match != null) {\n            this._activeSelectorParams = match[0];\n            this._elementToDrag = match[1];\n          }\n\n          if (this._activeSelectorParams == null || this._elementToDrag == null) {\n            return;\n          }\n\n          var initial = this._activeSelectorParams.dragInit ? this._activeSelectorParams.dragInit(this._elementToDrag) : null;\n\n          if (initial != null) {\n            this._elementToDrag = initial;\n          }\n\n          if (this.clone) {\n            this._dragEl = this._elementToDrag.cloneNode(true);\n            addClass(this._dragEl, _classes.clonedDrag);\n\n            this._dragEl.setAttribute(\"id\", null);\n\n            this._dragEl.style.position = \"absolute\";\n\n            if (this._parent != null) {\n              var _p2 = _getPosition(this.el);\n\n              this._dragEl.style.left = _p2.x + \"px\";\n              this._dragEl.style.top = _p2.y + \"px\";\n\n              this._parent.appendChild(this._dragEl);\n            } else {\n              var b = offsetRelativeToRoot(this._elementToDrag);\n              this._dragEl.style.left = b.x + \"px\";\n              this._dragEl.style.top = b.y + \"px\";\n              document.body.appendChild(this._dragEl);\n            }\n          } else {\n            this._dragEl = this._elementToDrag;\n          }\n\n          if (this.consumeStartEvent) {\n            consume(e);\n          }\n\n          this._downAt = pageLocation(e);\n\n          if (this._dragEl && this._dragEl.parentNode) {\n            this._initialScroll = {\n              x: this._dragEl.parentNode.scrollLeft,\n              y: this._dragEl.parentNode.scrollTop\n            };\n          }\n\n          this._posAtDown = _getPosition(this._dragEl);\n          this._pagePosAtDown = offsetRelativeToRoot(this._dragEl);\n          this._pageDelta = {\n            x: this._pagePosAtDown.x - this._posAtDown.x,\n            y: this._pagePosAtDown.y - this._posAtDown.y\n          };\n          this._size = _getSize(this._dragEl);\n          this.k.eventManager.on(document, EVENT_MOUSEMOVE, this.moveListener);\n          this.k.eventManager.on(document, EVENT_MOUSEUP, this.upListener);\n          addClass(document.body, _classes.noSelect);\n\n          this._dispatch(EVENT_BEFORE_START, {\n            el: this.el,\n            pos: this._posAtDown,\n            e: e,\n            drag: this,\n            size: this._size\n          });\n        } else if (this._consumeFilteredEvents) {\n          consume(e);\n        }\n      }\n    }\n  }, {\n    key: \"_moveListener\",\n    value: function _moveListener(e) {\n      if (this._downAt) {\n        if (!this._moving) {\n          var dispatchResult = this._dispatch(EVENT_START, {\n            el: this.el,\n            pos: this._posAtDown,\n            e: e,\n            drag: this,\n            size: this._size\n          });\n\n          if (dispatchResult !== false) {\n            if (!this._downAt) {\n              return;\n            }\n\n            this.mark(dispatchResult);\n            this._moving = true;\n          } else {\n            this.abort();\n          }\n        }\n\n        if (this._downAt) {\n          var _pos2 = pageLocation(e),\n              dx = _pos2.x - this._downAt.x,\n              dy = _pos2.y - this._downAt.y,\n              _z2 = this._ignoreZoom ? 1 : this.k.getZoom();\n\n          this._lastPosition = {\n            x: _pos2.x,\n            y: _pos2.y\n          };\n          this._lastScrollValues = {\n            x: document.documentElement.scrollLeft,\n            y: document.documentElement.scrollTop\n          };\n\n          if (this._dragEl && this._dragEl.parentNode) {\n            dx += this._dragEl.parentNode.scrollLeft - this._initialScroll.x;\n            dy += this._dragEl.parentNode.scrollTop - this._initialScroll.y;\n          }\n\n          dx /= _z2;\n          dy /= _z2;\n          this.moveBy(dx, dy, e);\n        }\n      }\n    }\n  }, {\n    key: \"mark\",\n    value: function mark(payload) {\n      this._posAtDown = _getPosition(this._dragEl);\n      this._pagePosAtDown = offsetRelativeToRoot(this._dragEl);\n      this._pageDelta = {\n        x: this._pagePosAtDown.x - this._posAtDown.x,\n        y: this._pagePosAtDown.y - this._posAtDown.y\n      };\n      this._size = _getSize(this._dragEl);\n      addClass(this._dragEl, this.k.css.drag);\n      this._constrainRect = getConstrainingRectangle(this._dragEl);\n      this._ghostDx = 0;\n      this._ghostDy = 0;\n    }\n  }, {\n    key: \"unmark\",\n    value: function unmark(e) {\n      if (this._isConstrained && this._useGhostProxy(this._elementToDrag, this._dragEl)) {\n        this._ghostProxyOffsets = {\n          x: this._dragEl.offsetLeft - this._ghostDx,\n          y: this._dragEl.offsetTop - this._ghostDy\n        };\n\n        this._dragEl.parentNode.removeChild(this._dragEl);\n\n        this._dragEl = this._elementToDrag;\n      } else {\n        this._ghostProxyOffsets = null;\n      }\n\n      removeClass(this._dragEl, this.k.css.drag);\n      this._isConstrained = false;\n    }\n  }, {\n    key: \"moveBy\",\n    value: function moveBy(dx, dy, e) {\n      var desiredLoc = this.toGrid({\n        x: this._posAtDown.x + dx,\n        y: this._posAtDown.y + dy\n      }),\n          cPos = this._doConstrain(desiredLoc, this._dragEl, this._constrainRect, this._size);\n\n      if (this._useGhostProxy(this.el, this._dragEl)) {\n        if (desiredLoc.x !== cPos.x || desiredLoc.y !== cPos.y) {\n          if (!this._isConstrained) {\n            var gp = this._ghostProxyFunction(this._elementToDrag);\n\n            addClass(gp, _classes.ghostProxy);\n\n            if (this._ghostProxyParent) {\n              this._ghostProxyParent.appendChild(gp);\n\n              this._currentParentPosition = offsetRelativeToRoot(this._elementToDrag.parentNode);\n              this._ghostParentPosition = offsetRelativeToRoot(this._ghostProxyParent);\n              this._ghostDx = this._currentParentPosition.x - this._ghostParentPosition.x;\n              this._ghostDy = this._currentParentPosition.y - this._ghostParentPosition.y;\n            } else {\n              this._elementToDrag.parentNode.appendChild(gp);\n            }\n\n            this._dragEl = gp;\n            this._isConstrained = true;\n          }\n\n          cPos = desiredLoc;\n        } else {\n          if (this._isConstrained) {\n            this._dragEl.parentNode.removeChild(this._dragEl);\n\n            this._dragEl = this._elementToDrag;\n            this._isConstrained = false;\n            this._currentParentPosition = null;\n            this._ghostParentPosition = null;\n            this._ghostDx = 0;\n            this._ghostDy = 0;\n          }\n        }\n      }\n\n      _setPosition(this._dragEl, {\n        x: cPos.x + this._ghostDx,\n        y: cPos.y + this._ghostDy\n      });\n\n      this._dispatch(EVENT_DRAG, {\n        el: this.el,\n        pos: cPos,\n        e: e,\n        drag: this,\n        size: this._size,\n        originalPos: this._posAtDown\n      });\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      if (this._downAt != null) {\n        this._upListener();\n      }\n    }\n  }, {\n    key: \"getDragElement\",\n    value: function getDragElement(retrieveOriginalElement) {\n      return retrieveOriginalElement ? this._elementToDrag || this.el : this._dragEl || this.el;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop(e, force) {\n      if (force || this._moving) {\n        var positions = [],\n            dPos = _getPosition(this._dragEl);\n\n        positions.push([this._dragEl, dPos, this, this._size]);\n\n        this._dispatch(EVENT_STOP, {\n          el: this._dragEl,\n          pos: this._ghostProxyOffsets || dPos,\n          finalPos: dPos,\n          e: e,\n          drag: this,\n          selection: positions,\n          size: this._size,\n          originalPos: {\n            x: this._posAtDown.x,\n            y: this._posAtDown.y\n          }\n        });\n      } else if (!this._moving) {\n        this._activeSelectorParams.dragAbort ? this._activeSelectorParams.dragAbort(this._elementToDrag) : null;\n      }\n    }\n  }, {\n    key: \"_dispatch\",\n    value: function _dispatch(evt, value) {\n      var result = null;\n\n      if (this._activeSelectorParams && this._activeSelectorParams[evt]) {\n        result = this._activeSelectorParams[evt](value);\n      } else if (this.listeners[evt]) {\n        for (var i = 0; i < this.listeners[evt].length; i++) {\n          try {\n            var v = this.listeners[evt][i](value);\n\n            if (v != null) {\n              result = v;\n            }\n          } catch (e) {}\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"resolveGrid\",\n    value: function resolveGrid() {\n      var out = {\n        grid: null,\n        thresholdX: DEFAULT_GRID_X / 2,\n        thresholdY: DEFAULT_GRID_Y / 2\n      };\n\n      if (this._activeSelectorParams != null && this._activeSelectorParams.grid != null) {\n        out.grid = this._activeSelectorParams.grid;\n\n        if (this._activeSelectorParams.snapThreshold != null) {\n          out.thresholdX = this._activeSelectorParams.snapThreshold;\n          out.thresholdY = this._activeSelectorParams.snapThreshold;\n        }\n      }\n\n      return out;\n    }\n  }, {\n    key: \"toGrid\",\n    value: function toGrid(pos) {\n      var _this$resolveGrid = this.resolveGrid(),\n          grid = _this$resolveGrid.grid,\n          thresholdX = _this$resolveGrid.thresholdX,\n          thresholdY = _this$resolveGrid.thresholdY;\n\n      if (grid == null) {\n        return pos;\n      } else {\n        var tx = grid ? grid.w / 2 : thresholdX,\n            ty = grid ? grid.h / 2 : thresholdY;\n        return (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.snapToGrid)(pos, grid, tx, ty);\n      }\n    }\n  }, {\n    key: \"setUseGhostProxy\",\n    value: function setUseGhostProxy(val) {\n      this._useGhostProxy = val ? TRUE : FALSE;\n    }\n  }, {\n    key: \"_doConstrain\",\n    value: function _doConstrain(pos, dragEl, _constrainRect, _size) {\n      if (this._activeSelectorParams != null && this._activeSelectorParams.constrainFunction && typeof this._activeSelectorParams.constrainFunction === \"function\") {\n        return this._activeSelectorParams.constrainFunction(pos, dragEl, _constrainRect, _size);\n      } else {\n        return pos;\n      }\n    }\n  }, {\n    key: \"_testFilter\",\n    value: function _testFilter(e) {\n      for (var key in this._filters) {\n        var f = this._filters[key];\n        var rv = f[0](e);\n\n        if (f[1]) {\n          rv = !rv;\n        }\n\n        if (!rv) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"addFilter\",\n    value: function addFilter(f, _exclude) {\n      var _this2 = this;\n\n      if (f) {\n        var key = _assignId(f);\n\n        this._filters[key] = [function (e) {\n          var t = e.srcElement || e.target;\n          var m;\n\n          if ((0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.isString)(f)) {\n            m = matchesSelector$1(t, f, _this2.el);\n          } else if (typeof f === \"function\") {\n            m = f(e, _this2.el);\n          }\n\n          return m;\n        }, _exclude !== false];\n      }\n    }\n  }, {\n    key: \"removeFilter\",\n    value: function removeFilter(f) {\n      var key = typeof f === \"function\" ? f._katavorioId : f;\n      delete this._filters[key];\n    }\n  }, {\n    key: \"clearAllFilters\",\n    value: function clearAllFilters() {\n      this._filters = {};\n    }\n  }, {\n    key: \"addSelector\",\n    value: function addSelector(params, atStart) {\n      if (params.selector) {\n        if (atStart) {\n          this._availableSelectors.unshift(params);\n        } else {\n          this._availableSelectors.push(params);\n        }\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.k.eventManager.off(this.el, EVENT_MOUSEDOWN, this.downListener);\n      this.k.eventManager.off(document, EVENT_MOUSEMOVE, this.moveListener);\n      this.k.eventManager.off(document, EVENT_MOUSEUP, this.upListener);\n      this.downListener = null;\n      this.upListener = null;\n      this.moveListener = null;\n\n      if (this.scrollTracker != null) {\n        document.removeEventListener(\"scroll\", this.scrollTracker);\n      }\n    }\n  }]);\n\n  return Drag;\n}(Base);\n\nvar DEFAULT_INPUTS = [\"input\", \"textarea\", \"select\", \"button\", \"option\"];\nvar DEFAULT_INPUT_FILTER_SELECTOR = DEFAULT_INPUTS.join(\",\");\n\nvar Collicat = function () {\n  function Collicat(options) {\n    _classCallCheck(this, Collicat);\n\n    _defineProperty(this, \"eventManager\", void 0);\n\n    _defineProperty(this, \"zoom\", 1);\n\n    _defineProperty(this, \"css\", {});\n\n    _defineProperty(this, \"inputFilterSelector\", void 0);\n\n    options = options || {};\n    this.inputFilterSelector = options.inputFilterSelector || DEFAULT_INPUT_FILTER_SELECTOR;\n    this.eventManager = new EventManager();\n    this.zoom = options.zoom || 1;\n\n    var _c = options.css || {};\n\n    (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.extend)(this.css, _c);\n  }\n\n  _createClass(Collicat, [{\n    key: \"getZoom\",\n    value: function getZoom() {\n      return this.zoom;\n    }\n  }, {\n    key: \"setZoom\",\n    value: function setZoom(z) {\n      this.zoom = z;\n    }\n  }, {\n    key: \"_prepareParams\",\n    value: function _prepareParams(p) {\n      p = p || {};\n      var _p = {\n        events: {}\n      },\n          i;\n\n      for (i in p) {\n        _p[i] = p[i];\n      }\n\n      for (i = 0; i < _events.length; i++) {\n        _p.events[_events[i]] = p[_events[i]] || _devNull;\n      }\n\n      return _p;\n    }\n  }, {\n    key: \"getInputFilterSelector\",\n    value: function getInputFilterSelector() {\n      return this.inputFilterSelector;\n    }\n  }, {\n    key: \"setInputFilterSelector\",\n    value: function setInputFilterSelector(selector) {\n      this.inputFilterSelector = selector;\n      return this;\n    }\n  }, {\n    key: \"draggable\",\n    value: function draggable(el, params) {\n      if (el._katavorioDrag == null) {\n        var _p3 = this._prepareParams(params);\n\n        var d = new Drag(el, _p3, this);\n        addClass(el, _classes.delegatedDraggable);\n        el._katavorioDrag = d;\n        return d;\n      } else {\n        return el._katavorioDrag;\n      }\n    }\n  }, {\n    key: \"destroyDraggable\",\n    value: function destroyDraggable(el) {\n      if (el._katavorioDrag) {\n        el._katavorioDrag.destroy();\n\n        delete el._katavorioDrag;\n      }\n    }\n  }]);\n\n  return Collicat;\n}();\n\nvar CLASS_DRAG_SELECTED = \"jtk-drag-selected\";\n\nvar DragSelection = function () {\n  function DragSelection(instance) {\n    _classCallCheck(this, DragSelection);\n\n    this.instance = instance;\n\n    _defineProperty(this, \"_dragSelection\", []);\n\n    _defineProperty(this, \"_dragSizes\", new Map());\n\n    _defineProperty(this, \"_dragElements\", new Map());\n\n    _defineProperty(this, \"_dragElementStartPositions\", new Map());\n\n    _defineProperty(this, \"_dragElementPositions\", new Map());\n\n    _defineProperty(this, \"__activeSet\", void 0);\n  }\n\n  _createClass(DragSelection, [{\n    key: \"_activeSet\",\n    get: function get() {\n      if (this.__activeSet == null) {\n        return this._dragSelection;\n      } else {\n        return this.__activeSet;\n      }\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._dragSelection.length;\n    }\n  }, {\n    key: \"filterActiveSet\",\n    value: function filterActiveSet(fn) {\n      var _this = this;\n\n      this.__activeSet = [];\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(this._dragSelection, function (p) {\n        if (fn(p)) {\n          _this.__activeSet.push(p);\n        }\n      });\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this2 = this;\n\n      this.reset();\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(this._dragSelection, function (p) {\n        return _this2.instance.removeClass(p.jel, CLASS_DRAG_SELECTED);\n      });\n      this._dragSelection.length = 0;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._dragElementStartPositions.clear();\n\n      this._dragElementPositions.clear();\n\n      this._dragSizes.clear();\n\n      this._dragElements.clear();\n\n      this.__activeSet = null;\n    }\n  }, {\n    key: \"initialisePositions\",\n    value: function initialisePositions() {\n      var _this3 = this;\n\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(this._activeSet, function (p) {\n        var off = {\n          x: parseInt(\"\" + p.jel.offsetLeft, 10),\n          y: parseInt(\"\" + p.jel.offsetTop, 10)\n        };\n\n        _this3._dragElementStartPositions.set(p.id, off);\n\n        _this3._dragElementPositions.set(p.id, off);\n\n        _this3._dragSizes.set(p.id, _this3.instance.getSize(p.jel));\n      });\n    }\n  }, {\n    key: \"updatePositions\",\n    value: function updatePositions(currentPosition, originalPosition, callback) {\n      var _this4 = this;\n\n      var dx = currentPosition.x - originalPosition.x,\n          dy = currentPosition.y - originalPosition.y;\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(this._activeSet, function (p) {\n        var op = _this4._dragElementStartPositions.get(p.id);\n\n        if (op) {\n          var x = op.x + dx,\n              y = op.y + dy;\n\n          var _s = _this4._dragSizes.get(p.id);\n\n          var _b = {\n            x: x,\n            y: y,\n            w: _s.w,\n            h: _s.h\n          };\n\n          if (p.jel._jsPlumbParentGroup && p.jel._jsPlumbParentGroup.constrain) {\n            var constrainRect = {\n              w: p.jel.parentNode.offsetWidth + p.jel.parentNode.scrollLeft,\n              h: p.jel.parentNode.offsetHeight + p.jel.parentNode.scrollTop\n            };\n            _b.x = Math.max(_b.x, 0);\n            _b.y = Math.max(_b.y, 0);\n            _b.x = Math.min(_b.x, constrainRect.w - _s.w);\n            _b.y = Math.min(_b.y, constrainRect.h - _s.h);\n          }\n\n          _this4._dragElementPositions.set(p.id, {\n            x: x,\n            y: y\n          });\n\n          p.jel.style.left = _b.x + \"px\";\n          p.jel.style.top = _b.y + \"px\";\n          callback(p.jel, p.id, _s, _b);\n        }\n      });\n    }\n  }, {\n    key: \"each\",\n    value: function each(f) {\n      var _this5 = this;\n\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(this._activeSet, function (p) {\n        var s = _this5._dragSizes.get(p.id);\n\n        var o = _this5._dragElementPositions.get(p.id);\n\n        var orig = _this5._dragElementStartPositions.get(p.id);\n\n        f(p.jel, p.id, o, s, orig);\n      });\n    }\n  }, {\n    key: \"add\",\n    value: function add(el, id) {\n      var jel = el;\n      id = id || this.instance.getId(jel);\n      var idx = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.findWithFunction)(this._dragSelection, function (p) {\n        return p.id === id;\n      });\n\n      if (idx === -1) {\n        this.instance.addClass(el, CLASS_DRAG_SELECTED);\n\n        this._dragSelection.push({\n          id: id,\n          jel: jel\n        });\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(el) {\n      var _this6 = this;\n\n      var jel = el;\n      this._dragSelection = this._dragSelection.filter(function (p) {\n        var out = p.jel !== jel;\n\n        if (!out) {\n          _this6.instance.removeClass(p.jel, CLASS_DRAG_SELECTED);\n        }\n\n        return out;\n      });\n    }\n  }, {\n    key: \"toggle\",\n    value: function toggle(el) {\n      var jel = el;\n      var idx = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.findWithFunction)(this._dragSelection, function (p) {\n        return p.jel === jel;\n      });\n\n      if (idx !== -1) {\n        this.remove(jel);\n      } else {\n        this.add(el);\n      }\n    }\n  }]);\n\n  return DragSelection;\n}();\n\nvar CLASS_DELEGATED_DRAGGABLE = \"jtk-delegated-draggable\";\nvar CLASS_DRAGGABLE = \"jtk-draggable\";\nvar CLASS_DRAG_CONTAINER = \"jtk-drag\";\nvar CLASS_GHOST_PROXY = \"jtk-ghost-proxy\";\nvar CLASS_DRAG_ACTIVE = \"jtk-drag-active\";\nvar CLASS_DRAGGED = \"jtk-dragged\";\nvar CLASS_DRAG_HOVER = \"jtk-drag-hover\";\n\nvar DragManager = function () {\n  function DragManager(instance, dragSelection, options) {\n    var _this = this;\n\n    _classCallCheck(this, DragManager);\n\n    this.instance = instance;\n    this.dragSelection = dragSelection;\n\n    _defineProperty(this, \"collicat\", void 0);\n\n    _defineProperty(this, \"drag\", void 0);\n\n    _defineProperty(this, \"_draggables\", {});\n\n    _defineProperty(this, \"_dlist\", []);\n\n    _defineProperty(this, \"_elementsWithEndpoints\", {});\n\n    _defineProperty(this, \"_draggablesForElements\", {});\n\n    _defineProperty(this, \"handlers\", []);\n\n    _defineProperty(this, \"_trackScroll\", void 0);\n\n    _defineProperty(this, \"_filtersToAdd\", []);\n\n    this.collicat = new Collicat({\n      zoom: this.instance.currentZoom,\n      css: {\n        noSelect: this.instance.dragSelectClass,\n        delegatedDraggable: CLASS_DELEGATED_DRAGGABLE,\n        draggable: CLASS_DRAGGABLE,\n        drag: CLASS_DRAG_CONTAINER,\n        selected: CLASS_DRAG_SELECTED,\n        active: CLASS_DRAG_ACTIVE,\n        hover: CLASS_DRAG_HOVER,\n        ghostProxy: CLASS_GHOST_PROXY\n      }\n    });\n    this.instance.bind(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.EVENT_ZOOM, function (z) {\n      _this.collicat.setZoom(z);\n    });\n    options = options || {};\n    this._trackScroll = options.trackScroll !== false;\n  }\n\n  _createClass(DragManager, [{\n    key: \"addHandler\",\n    value: function addHandler(handler, dragOptions) {\n      var _this2 = this;\n\n      var o = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.extend)({\n        selector: handler.selector\n      }, dragOptions || {});\n      o.start = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.wrap)(o.start, function (p) {\n        return handler.onStart(p);\n      }, false);\n      o.drag = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.wrap)(o.drag, function (p) {\n        return handler.onDrag(p);\n      });\n      o.stop = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.wrap)(o.stop, function (p) {\n        return handler.onStop(p);\n      });\n\n      var handlerBeforeStart = (handler.onBeforeStart || function (p) {}).bind(handler);\n\n      o.beforeStart = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.wrap)(o.beforeStart, function (p) {\n        return handlerBeforeStart(p);\n      });\n\n      o.dragInit = function (el) {\n        return handler.onDragInit(el);\n      };\n\n      o.dragAbort = function (el) {\n        return handler.onDragAbort(el);\n      };\n\n      if (handler.useGhostProxy) {\n        o.useGhostProxy = handler.useGhostProxy;\n        o.makeGhostProxy = handler.makeGhostProxy;\n      }\n\n      if (o.constrainFunction == null && o.containment != null) {\n        switch (o.containment) {\n          case ContainmentType.notNegative:\n            {\n              o.constrainFunction = function (pos, dragEl, _constrainRect, _size) {\n                return {\n                  x: Math.max(0, Math.min(pos.x)),\n                  y: Math.max(0, Math.min(pos.y))\n                };\n              };\n\n              break;\n            }\n\n          case ContainmentType.parent:\n            {\n              var padding = o.containmentPadding || 5;\n\n              o.constrainFunction = function (pos, dragEl, _constrainRect, _size) {\n                var x = pos.x < 0 ? 0 : pos.x > _constrainRect.w - padding ? _constrainRect.w - padding : pos.x;\n                var y = pos.y < 0 ? 0 : pos.y > _constrainRect.h - padding ? _constrainRect.h - padding : pos.y;\n                return {\n                  x: x,\n                  y: y\n                };\n              };\n\n              break;\n            }\n\n          case ContainmentType.parentEnclosed:\n            {\n              o.constrainFunction = function (pos, dragEl, _constrainRect, _size) {\n                var x = pos.x < 0 ? 0 : pos.x + _size.w > _constrainRect.w ? _constrainRect.w - _size.w : pos.x;\n                var y = pos.y < 0 ? 0 : pos.y + _size.h > _constrainRect.h ? _constrainRect.h - _size.h : pos.y;\n                return {\n                  x: x,\n                  y: y\n                };\n              };\n\n              break;\n            }\n        }\n      }\n\n      if (this.drag == null) {\n        o.trackScroll = this._trackScroll;\n        this.drag = this.collicat.draggable(this.instance.getContainer(), o);\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(this._filtersToAdd, function (filterToAdd) {\n          return _this2.drag.addFilter(filterToAdd[0], filterToAdd[1]);\n        });\n        this.drag.on(EVENT_REVERT, function (el) {\n          _this2.instance.revalidate(el);\n        });\n      } else {\n        this.drag.addSelector(o);\n      }\n\n      this.handlers.push({\n        handler: handler,\n        options: o\n      });\n      handler.init(this.drag);\n    }\n  }, {\n    key: \"addSelector\",\n    value: function addSelector(params, atStart) {\n      this.drag && this.drag.addSelector(params, atStart);\n    }\n  }, {\n    key: \"addFilter\",\n    value: function addFilter(filter, exclude) {\n      if (this.drag == null) {\n        this._filtersToAdd.push([filter, exclude === true]);\n      } else {\n        this.drag.addFilter(filter, exclude);\n      }\n    }\n  }, {\n    key: \"removeFilter\",\n    value: function removeFilter(filter) {\n      if (this.drag != null) {\n        this.drag.removeFilter(filter);\n      }\n    }\n  }, {\n    key: \"setFilters\",\n    value: function setFilters(filters) {\n      var _this3 = this;\n\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(filters, function (f) {\n        _this3.drag.addFilter(f[0], f[1]);\n      });\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var out = [];\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(this.handlers, function (p) {\n        p.handler.reset();\n      });\n      this.handlers.length = 0;\n\n      if (this.drag != null) {\n        var currentFilters = this.drag._filters;\n\n        for (var f in currentFilters) {\n          out.push([f, currentFilters[f][1]]);\n        }\n\n        this.collicat.destroyDraggable(this.instance.getContainer());\n      }\n\n      delete this.drag;\n      return out;\n    }\n  }, {\n    key: \"setOption\",\n    value: function setOption(handler, options) {\n      var handlerAndOptions = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.getWithFunction)(this.handlers, function (p) {\n        return p.handler === handler;\n      });\n\n      if (handlerAndOptions != null) {\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.extend)(handlerAndOptions.options, options || {});\n      }\n    }\n  }]);\n\n  return DragManager;\n}();\n\nfunction decodeDragGroupSpec(instance, spec) {\n  if ((0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.isString)(spec)) {\n    return {\n      id: spec,\n      active: true\n    };\n  } else {\n    return {\n      id: instance.getId(spec),\n      active: spec.active\n    };\n  }\n}\n\nfunction isActiveDragGroupMember(dragGroup, el) {\n  var details = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.getFromSetWithFunction)(dragGroup.members, function (m) {\n    return m.el === el;\n  });\n\n  if (details !== null) {\n    return details.active === true;\n  } else {\n    return false;\n  }\n}\n\nfunction getAncestors(el) {\n  var ancestors = [];\n  var p = el._jsPlumbParentGroup;\n\n  while (p != null) {\n    ancestors.push(p.el);\n    p = p.group;\n  }\n\n  return ancestors;\n}\n\nvar ElementDragHandler = function () {\n  function ElementDragHandler(instance, _dragSelection) {\n    _classCallCheck(this, ElementDragHandler);\n\n    this.instance = instance;\n    this._dragSelection = _dragSelection;\n\n    _defineProperty(this, \"selector\", \"> \" + _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.SELECTOR_MANAGED_ELEMENT + \":not(\" + (0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.cls)(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.CLASS_OVERLAY) + \")\");\n\n    _defineProperty(this, \"_dragOffset\", null);\n\n    _defineProperty(this, \"_groupLocations\", []);\n\n    _defineProperty(this, \"_intersectingGroups\", []);\n\n    _defineProperty(this, \"_currentDragParentGroup\", null);\n\n    _defineProperty(this, \"_dragGroupByElementIdMap\", {});\n\n    _defineProperty(this, \"_dragGroupMap\", {});\n\n    _defineProperty(this, \"_currentDragGroup\", null);\n\n    _defineProperty(this, \"_currentDragGroupOffsets\", new Map());\n\n    _defineProperty(this, \"_currentDragGroupSizes\", new Map());\n\n    _defineProperty(this, \"_dragPayload\", null);\n\n    _defineProperty(this, \"drag\", void 0);\n\n    _defineProperty(this, \"originalPosition\", void 0);\n  }\n\n  _createClass(ElementDragHandler, [{\n    key: \"onDragInit\",\n    value: function onDragInit(el) {\n      return null;\n    }\n  }, {\n    key: \"onDragAbort\",\n    value: function onDragAbort(el) {\n      return null;\n    }\n  }, {\n    key: \"getDropGroup\",\n    value: function getDropGroup() {\n      var dropGroup = null;\n\n      if (this._intersectingGroups.length > 0) {\n        var targetGroup = this._intersectingGroups[0].groupLoc.group;\n        var intersectingElement = this._intersectingGroups[0].intersectingElement;\n        var currentGroup = intersectingElement._jsPlumbParentGroup;\n\n        if (currentGroup !== targetGroup) {\n          if (currentGroup == null || !currentGroup.overrideDrop(intersectingElement, targetGroup)) {\n            dropGroup = this._intersectingGroups[0];\n          }\n        }\n      }\n\n      return dropGroup;\n    }\n  }, {\n    key: \"onStop\",\n    value: function onStop(params) {\n      var _this = this;\n\n      var jel = params.drag.getDragElement();\n      var dropGroup = this.getDropGroup();\n      var elementsToProcess = [];\n      elementsToProcess.push({\n        el: jel,\n        id: this.instance.getId(jel),\n        pos: params.finalPos,\n        originalGroup: jel._jsPlumbParentGroup,\n        redrawResult: null,\n        originalPos: params.originalPos,\n        reverted: false,\n        dropGroup: dropGroup != null ? dropGroup.groupLoc.group : null\n      });\n\n      this._dragSelection.each(function (el, id, o, s, orig) {\n        if (el !== params.el) {\n          var pp = {\n            x: o.x,\n            y: o.y\n          };\n          var x = pp.x,\n              y = pp.y;\n\n          if (el._jsPlumbParentGroup && el._jsPlumbParentGroup.constrain) {\n            var constrainRect = {\n              w: el.parentNode.offsetWidth + el.parentNode.scrollLeft,\n              h: el.parentNode.offsetHeight + el.parentNode.scrollTop\n            };\n            x = Math.max(x, 0);\n            y = Math.max(y, 0);\n            x = Math.min(x, constrainRect.w - s.w);\n            y = Math.min(y, constrainRect.h - s.h);\n            pp.x = x;\n            pp.y = y;\n          }\n\n          elementsToProcess.push({\n            el: el,\n            id: id,\n            pos: pp,\n            originalPos: orig,\n            originalGroup: el._jsPlumbParentGroup,\n            redrawResult: null,\n            reverted: false,\n            dropGroup: dropGroup != null ? dropGroup.groupLoc.group : null\n          });\n        }\n      });\n\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(elementsToProcess, function (p) {\n        var wasInGroup = p.originalGroup != null,\n            isInOriginalGroup = wasInGroup && isInsideParent(_this.instance, p.el, p.pos),\n            parentOffset = {\n          x: 0,\n          y: 0\n        };\n\n        if (wasInGroup && !isInOriginalGroup) {\n          if (dropGroup == null) {\n            var orphanedPosition = _this._pruneOrOrphan(p, true, true);\n\n            if (orphanedPosition.pos != null) {\n              p.pos = orphanedPosition.pos.pos;\n            } else {\n              if (!orphanedPosition.pruned && p.originalGroup.revert) {\n                p.pos = p.originalPos;\n                p.reverted = true;\n              }\n            }\n          }\n        } else if (wasInGroup && isInOriginalGroup) {\n          parentOffset = _this.instance.viewport.getPosition(p.originalGroup.elId);\n        }\n\n        if (dropGroup != null && !isInOriginalGroup) {\n          _this.instance.groupManager.addToGroup(dropGroup.groupLoc.group, false, p.el);\n        } else {\n          p.dropGroup = null;\n        }\n\n        if (p.reverted) {\n          _this.instance.setPosition(p.el, p.pos);\n        }\n\n        p.redrawResult = _this.instance.setElementPosition(p.el, p.pos.x + parentOffset.x, p.pos.y + parentOffset.y);\n\n        _this.instance.removeClass(p.el, CLASS_DRAGGED);\n\n        _this.instance.select({\n          source: p.el\n        }).removeClass(_this.instance.elementDraggingClass + \" \" + _this.instance.sourceElementDraggingClass, true);\n\n        _this.instance.select({\n          target: p.el\n        }).removeClass(_this.instance.elementDraggingClass + \" \" + _this.instance.targetElementDraggingClass, true);\n      });\n\n      if (elementsToProcess[0].originalGroup != null) {\n        var currentGroup = jel._jsPlumbParentGroup;\n\n        if (currentGroup !== elementsToProcess[0].originalGroup) {\n          var originalElement = params.drag.getDragElement(true);\n\n          if (elementsToProcess[0].originalGroup.ghost) {\n            var o1 = this.instance.getOffset(this.instance.getGroupContentArea(currentGroup));\n            var o2 = this.instance.getOffset(this.instance.getGroupContentArea(elementsToProcess[0].originalGroup));\n            var o = {\n              x: o2.x + params.pos.x - o1.x,\n              y: o2.y + params.pos.y - o1.y\n            };\n            originalElement.style.left = o.x + \"px\";\n            originalElement.style.top = o.y + \"px\";\n            this.instance.revalidate(originalElement);\n          }\n        }\n      }\n\n      this.instance.fire(EVENT_DRAG_STOP, {\n        elements: elementsToProcess,\n        e: params.e,\n        el: jel,\n        payload: this._dragPayload\n      });\n\n      this._cleanup();\n    }\n  }, {\n    key: \"_cleanup\",\n    value: function _cleanup() {\n      var _this2 = this;\n\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(this._groupLocations, function (groupLoc) {\n        _this2.instance.removeClass(groupLoc.el, CLASS_DRAG_ACTIVE);\n\n        _this2.instance.removeClass(groupLoc.el, CLASS_DRAG_HOVER);\n      });\n      this._currentDragParentGroup = null;\n      this._groupLocations.length = 0;\n      this.instance.hoverSuspended = false;\n      this._dragOffset = null;\n\n      this._dragSelection.reset();\n\n      this._dragPayload = null;\n\n      this._currentDragGroupOffsets.clear();\n\n      this._currentDragGroupSizes.clear();\n\n      this._currentDragGroup = null;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {}\n  }, {\n    key: \"init\",\n    value: function init(drag) {\n      this.drag = drag;\n    }\n  }, {\n    key: \"onDrag\",\n    value: function onDrag(params) {\n      var _this3 = this;\n\n      var el = params.drag.getDragElement();\n      var finalPos = params.pos;\n      var elSize = this.instance.getSize(el);\n      var ui = {\n        x: finalPos.x,\n        y: finalPos.y\n      };\n      this._intersectingGroups.length = 0;\n\n      if (this._dragOffset != null) {\n        ui.x += this._dragOffset.x;\n        ui.y += this._dragOffset.y;\n      }\n\n      var _one = function _one(el, bounds, findIntersectingGroups) {\n        if (findIntersectingGroups) {\n          var ancestorsOfIntersectingGroups = new Set();\n          (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(_this3._groupLocations, function (groupLoc) {\n            if (!ancestorsOfIntersectingGroups.has(groupLoc.group.id) && (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.intersects)(bounds, groupLoc.r)) {\n              if (groupLoc.group !== _this3._currentDragParentGroup) {\n                _this3.instance.addClass(groupLoc.el, CLASS_DRAG_HOVER);\n              }\n\n              _this3._intersectingGroups.push({\n                groupLoc: groupLoc,\n                intersectingElement: params.drag.getDragElement(true),\n                d: 0\n              });\n\n              (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(_this3.instance.groupManager.getAncestors(groupLoc.group), function (g) {\n                return ancestorsOfIntersectingGroups.add(g.id);\n              });\n            } else {\n              _this3.instance.removeClass(groupLoc.el, CLASS_DRAG_HOVER);\n            }\n          });\n        }\n\n        _this3.instance.setElementPosition(el, bounds.x, bounds.y);\n\n        _this3.instance.fire(EVENT_DRAG_MOVE, {\n          el: el,\n          e: params.e,\n          pos: {\n            x: bounds.x,\n            y: bounds.y\n          },\n          originalPosition: _this3.originalPosition,\n          payload: _this3._dragPayload\n        });\n      };\n\n      var elBounds = {\n        x: ui.x,\n        y: ui.y,\n        w: elSize.w,\n        h: elSize.h\n      };\n\n      _one(el, elBounds, true);\n\n      this._dragSelection.updatePositions(finalPos, this.originalPosition, function (el, id, s, b) {\n        _one(el, b, false);\n      });\n\n      this._currentDragGroupOffsets.forEach(function (v, k) {\n        var s = _this3._currentDragGroupSizes.get(k);\n\n        var _b = {\n          x: elBounds.x + v[0].x,\n          y: elBounds.y + v[0].y,\n          w: s.w,\n          h: s.h\n        };\n        v[1].style.left = _b.x + \"px\";\n        v[1].style.top = _b.y + \"px\";\n\n        _one(v[1], _b, false);\n      });\n    }\n  }, {\n    key: \"onStart\",\n    value: function onStart(params) {\n      var _this4 = this;\n\n      var el = params.drag.getDragElement();\n      var elOffset = this.instance.getOffset(el);\n      this.originalPosition = {\n        x: params.pos.x,\n        y: params.pos.y\n      };\n\n      if (el._jsPlumbParentGroup) {\n        this._dragOffset = this.instance.getOffset(el.offsetParent);\n        this._currentDragParentGroup = el._jsPlumbParentGroup;\n      }\n\n      var cont = true;\n      var nd = el.getAttribute(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.ATTRIBUTE_NOT_DRAGGABLE);\n\n      if (this.instance.elementsDraggable === false || nd != null && nd !== _jsplumb_common__WEBPACK_IMPORTED_MODULE_2__.FALSE) {\n        cont = false;\n      }\n\n      if (cont) {\n        this._groupLocations.length = 0;\n        this._intersectingGroups.length = 0;\n        this.instance.hoverSuspended = true;\n        var originalElement = params.drag.getDragElement(true),\n            descendants = originalElement.querySelectorAll(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.SELECTOR_MANAGED_ELEMENT),\n            ancestors = getAncestors(originalElement),\n            a = [];\n        Array.prototype.push.apply(a, descendants);\n        Array.prototype.push.apply(a, ancestors);\n\n        this._dragSelection.filterActiveSet(function (p) {\n          return a.indexOf(p.jel) === -1;\n        });\n\n        this._dragSelection.initialisePositions();\n\n        var _one = function _one(_el) {\n          if (!_el._isJsPlumbGroup || _this4.instance.allowNestedGroups) {\n            var isNotInAGroup = !_el._jsPlumbParentGroup;\n            var membersAreDroppable = isNotInAGroup || _el._jsPlumbParentGroup.dropOverride !== true;\n            var isGhostOrNotConstrained = !isNotInAGroup && (_el._jsPlumbParentGroup.ghost || _el._jsPlumbParentGroup.constrain !== true);\n\n            if (isNotInAGroup || membersAreDroppable && isGhostOrNotConstrained) {\n              (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(_this4.instance.groupManager.getGroups(), function (group) {\n                var elementGroup = _el._jsPlumbGroup;\n\n                if (group.droppable !== false && group.enabled !== false && _el._jsPlumbGroup !== group && !_this4.instance.groupManager.isDescendant(group, elementGroup)) {\n                  var groupEl = group.el,\n                      s = _this4.instance.getSize(groupEl),\n                      o = _this4.instance.getOffset(groupEl),\n                      boundingRect = {\n                    x: o.x,\n                    y: o.y,\n                    w: s.w,\n                    h: s.h\n                  };\n\n                  var groupLocation = {\n                    el: groupEl,\n                    r: boundingRect,\n                    group: group\n                  };\n\n                  _this4._groupLocations.push(groupLocation);\n\n                  if (group !== _this4._currentDragParentGroup) {\n                    _this4.instance.addClass(groupEl, CLASS_DRAG_ACTIVE);\n                  }\n                }\n              });\n\n              _this4._groupLocations.sort(function (a, b) {\n                if (_this4.instance.groupManager.isDescendant(a.group, b.group)) {\n                  return -1;\n                } else if (_this4.instance.groupManager.isAncestor(b.group, a.group)) {\n                  return 1;\n                } else {\n                  return 0;\n                }\n              });\n            }\n          }\n\n          _this4.instance.select({\n            source: _el\n          }).addClass(_this4.instance.elementDraggingClass + \" \" + _this4.instance.sourceElementDraggingClass, true);\n\n          _this4.instance.select({\n            target: _el\n          }).addClass(_this4.instance.elementDraggingClass + \" \" + _this4.instance.targetElementDraggingClass, true);\n\n          return _this4.instance.fire(EVENT_DRAG_START, {\n            el: _el,\n            e: params.e,\n            originalPosition: _this4.originalPosition,\n            pos: _this4.originalPosition\n          });\n        };\n\n        var elId = this.instance.getId(el);\n        this._currentDragGroup = this._dragGroupByElementIdMap[elId];\n\n        if (this._currentDragGroup && !isActiveDragGroupMember(this._currentDragGroup, el)) {\n          this._currentDragGroup = null;\n        }\n\n        var dragStartReturn = _one(el);\n\n        if (dragStartReturn === false) {\n          this._cleanup();\n\n          return false;\n        } else {\n          this._dragPayload = dragStartReturn;\n        }\n\n        if (this._currentDragGroup != null) {\n          this._currentDragGroupOffsets.clear();\n\n          this._currentDragGroupSizes.clear();\n\n          this._currentDragGroup.members.forEach(function (jel) {\n            var off = _this4.instance.getOffset(jel.el);\n\n            _this4._currentDragGroupOffsets.set(jel.elId, [{\n              x: off.x - elOffset.x,\n              y: off.y - elOffset.y\n            }, jel.el]);\n\n            _this4._currentDragGroupSizes.set(jel.elId, _this4.instance.getSize(jel.el));\n\n            _one(jel.el);\n          });\n        }\n      }\n\n      return cont;\n    }\n  }, {\n    key: \"addToDragGroup\",\n    value: function addToDragGroup(spec) {\n      var _this5 = this;\n\n      var details = decodeDragGroupSpec(this.instance, spec);\n      var dragGroup = this._dragGroupMap[details.id];\n\n      if (dragGroup == null) {\n        dragGroup = {\n          id: details.id,\n          members: new Set()\n        };\n        this._dragGroupMap[details.id] = dragGroup;\n      }\n\n      for (var _len = arguments.length, els = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        els[_key - 1] = arguments[_key];\n      }\n\n      this.removeFromDragGroup.apply(this, els);\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(els, function (el) {\n        var elId = _this5.instance.getId(el);\n\n        dragGroup.members.add({\n          elId: elId,\n          el: el,\n          active: details.active\n        });\n        _this5._dragGroupByElementIdMap[elId] = dragGroup;\n      });\n    }\n  }, {\n    key: \"removeFromDragGroup\",\n    value: function removeFromDragGroup() {\n      var _this6 = this;\n\n      for (var _len2 = arguments.length, els = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        els[_key2] = arguments[_key2];\n      }\n\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(els, function (el) {\n        var id = _this6.instance.getId(el);\n\n        var dragGroup = _this6._dragGroupByElementIdMap[id];\n\n        if (dragGroup != null) {\n          var s = new Set();\n          dragGroup.members.forEach(function (member) {\n            if (member.el !== el) {\n              s.add(member);\n            }\n          });\n          dragGroup.members = s;\n          delete _this6._dragGroupByElementIdMap[id];\n        }\n      });\n    }\n  }, {\n    key: \"setDragGroupState\",\n    value: function setDragGroupState(state) {\n      var _this7 = this;\n\n      for (var _len3 = arguments.length, els = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        els[_key3 - 1] = arguments[_key3];\n      }\n\n      var elementIds = els.map(function (el) {\n        return _this7.instance.getId(el);\n      });\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(elementIds, function (id) {\n        var dragGroup = _this7._dragGroupByElementIdMap[id];\n\n        if (dragGroup != null) {\n          var member = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.getFromSetWithFunction)(dragGroup.members, function (m) {\n            return m.elId === id;\n          });\n\n          if (member != null) {\n            member.active = state;\n          }\n        }\n      });\n    }\n  }, {\n    key: \"_pruneOrOrphan\",\n    value: function _pruneOrOrphan(params, doNotTransferToAncestor, isDefinitelyNotInsideParent) {\n      var jel = params.el;\n      var orphanedPosition = {\n        pruned: false,\n        pos: null\n      };\n\n      if (isDefinitelyNotInsideParent || !isInsideParent(this.instance, jel, params.pos)) {\n        var group = jel._jsPlumbParentGroup;\n\n        if (group.prune) {\n          if (jel._isJsPlumbGroup) {\n            this.instance.removeGroup(jel._jsPlumbGroup);\n          } else {\n            group.remove(params.el, true);\n          }\n\n          orphanedPosition.pruned = true;\n        } else if (group.orphan) {\n          orphanedPosition.pos = this.instance.groupManager.orphan(params.el, doNotTransferToAncestor);\n\n          if (jel._isJsPlumbGroup) {\n            group.removeGroup(jel._jsPlumbGroup);\n          } else {\n            group.remove(params.el);\n          }\n        }\n      }\n\n      return orphanedPosition;\n    }\n  }]);\n\n  return ElementDragHandler;\n}();\n\nfunction _makeFloatingEndpoint(ep, endpoint, referenceCanvas, sourceElement, instance) {\n  var floatingAnchor = (0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.createFloatingAnchor)(instance, sourceElement);\n  var p = {\n    paintStyle: ep.getPaintStyle(),\n    preparedAnchor: floatingAnchor,\n    element: sourceElement,\n    scope: ep.scope\n  };\n\n  if (endpoint != null) {\n    if ((0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.isAssignableFrom)(endpoint, _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.EndpointRepresentation)) {\n      p.existingEndpoint = endpoint;\n    } else {\n      p.endpoint = endpoint;\n    }\n  }\n\n  var actualEndpoint = instance._internal_newEndpoint(p);\n\n  instance._paintEndpoint(actualEndpoint, {});\n\n  return actualEndpoint;\n}\n\nfunction selectorFilter(evt, _el, selector, _instance, negate) {\n  var t = evt.target || evt.srcElement,\n      ok = false,\n      sel = _instance.getSelector(_el, selector);\n\n  for (var j = 0; j < sel.length; j++) {\n    if (sel[j] === t) {\n      ok = true;\n      break;\n    }\n  }\n\n  return negate ? !ok : ok;\n}\n\nvar SELECTOR_DRAG_ACTIVE_OR_HOVER = (0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.cls)(CLASS_DRAG_ACTIVE, CLASS_DRAG_HOVER);\nvar SOURCE_SELECTOR_UNIQUE_ENDPOINT_DATA = \"sourceSelectorEndpoint\";\n\nvar EndpointDragHandler = function () {\n  function EndpointDragHandler(instance) {\n    _classCallCheck(this, EndpointDragHandler);\n\n    this.instance = instance;\n\n    _defineProperty(this, \"jpc\", void 0);\n\n    _defineProperty(this, \"existingJpc\", void 0);\n\n    _defineProperty(this, \"_originalAnchorSpec\", void 0);\n\n    _defineProperty(this, \"ep\", void 0);\n\n    _defineProperty(this, \"endpointRepresentation\", void 0);\n\n    _defineProperty(this, \"canvasElement\", void 0);\n\n    _defineProperty(this, \"_activeDefinition\", void 0);\n\n    _defineProperty(this, \"placeholderInfo\", {\n      id: null,\n      element: null\n    });\n\n    _defineProperty(this, \"floatingIndex\", void 0);\n\n    _defineProperty(this, \"floatingId\", void 0);\n\n    _defineProperty(this, \"floatingElement\", void 0);\n\n    _defineProperty(this, \"floatingEndpoint\", void 0);\n\n    _defineProperty(this, \"floatingAnchor\", void 0);\n\n    _defineProperty(this, \"_stopped\", void 0);\n\n    _defineProperty(this, \"inPlaceCopy\", void 0);\n\n    _defineProperty(this, \"endpointDropTargets\", []);\n\n    _defineProperty(this, \"currentDropTarget\", null);\n\n    _defineProperty(this, \"payload\", void 0);\n\n    _defineProperty(this, \"floatingConnections\", {});\n\n    _defineProperty(this, \"_forceReattach\", void 0);\n\n    _defineProperty(this, \"_forceDetach\", void 0);\n\n    _defineProperty(this, \"mousedownHandler\", void 0);\n\n    _defineProperty(this, \"mouseupHandler\", void 0);\n\n    _defineProperty(this, \"selector\", (0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.cls)(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.CLASS_ENDPOINT));\n\n    var container = instance.getContainer();\n    this.mousedownHandler = this._mousedownHandler.bind(this);\n    this.mouseupHandler = this._mouseupHandler.bind(this);\n    instance.on(container, EVENT_MOUSEDOWN, _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.SELECTOR_MANAGED_ELEMENT, this.mousedownHandler);\n    instance.on(container, EVENT_MOUSEUP, [_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.SELECTOR_MANAGED_ELEMENT, (0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.cls)(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.CLASS_ENDPOINT)].join(\",\"), this.mouseupHandler);\n  }\n\n  _createClass(EndpointDragHandler, [{\n    key: \"_resolveDragParent\",\n    value: function _resolveDragParent(def, eventTarget) {\n      var container = this.instance.getContainer();\n      var parent = findParent(eventTarget, _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.SELECTOR_MANAGED_ELEMENT, container, true);\n\n      if (def.parentSelector != null) {\n        var child = findParent(eventTarget, def.parentSelector, container, true);\n\n        if (child != null) {\n          parent = findParent(child.parentNode, _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.SELECTOR_MANAGED_ELEMENT, container, false);\n        }\n\n        return child || parent;\n      } else {\n        return parent;\n      }\n    }\n  }, {\n    key: \"_mousedownHandler\",\n    value: function _mousedownHandler(e) {\n      var sourceEl;\n      var sourceSelector;\n\n      if (e.which === 3 || e.button === 2) {\n        return;\n      }\n\n      var eventTarget = e.target || e.srcElement;\n      sourceSelector = this._getSourceDefinition(e);\n\n      if (sourceSelector != null) {\n        sourceEl = this._resolveDragParent(sourceSelector.def.def, eventTarget);\n\n        if (sourceEl == null || sourceEl.getAttribute(ATTRIBUTE_JTK_ENABLED) === _jsplumb_common__WEBPACK_IMPORTED_MODULE_2__.FALSE) {\n          return;\n        }\n      }\n\n      if (sourceSelector) {\n        var sourceElement = e.currentTarget,\n            def;\n\n        if (eventTarget.getAttribute(ATTRIBUTE_JTK_ENABLED) !== _jsplumb_common__WEBPACK_IMPORTED_MODULE_2__.FALSE) {\n          consume(e);\n          this._activeDefinition = sourceSelector;\n          def = sourceSelector.def.def;\n\n          if (def.canAcceptNewConnection != null && !def.canAcceptNewConnection(sourceEl, e)) {\n            return false;\n          }\n\n          var elxy = getPositionOnElement(e, sourceEl, this.instance.currentZoom);\n          var tempEndpointParams = {\n            element: sourceEl\n          };\n          (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.extend)(tempEndpointParams, def);\n          tempEndpointParams.isTemporarySource = true;\n\n          if (def.scope) {\n            tempEndpointParams.scope = def.scope;\n          } else {\n            var scopeFromElement = eventTarget.getAttribute(ATTRIBUTE_JTK_SCOPE);\n\n            if (scopeFromElement != null) {\n              tempEndpointParams.scope = scopeFromElement;\n            }\n          }\n\n          var extractedParameters = def.parameterExtractor ? def.parameterExtractor(sourceEl, eventTarget, e) : {};\n          tempEndpointParams = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.merge)(tempEndpointParams, extractedParameters);\n\n          if (tempEndpointParams.maxConnections != null && tempEndpointParams.maxConnections >= 0) {\n            var sourceCount = this.instance.select({\n              source: sourceEl\n            }).length;\n\n            if (sourceCount >= tempEndpointParams.maxConnections) {\n              consume(e);\n\n              if (def.onMaxConnections) {\n                def.onMaxConnections({\n                  element: sourceEl,\n                  maxConnections: tempEndpointParams.maxConnections\n                }, e);\n              }\n\n              e.stopImmediatePropagation && e.stopImmediatePropagation();\n              return false;\n            }\n          }\n\n          if (def.anchorPositionFinder) {\n            var maybeAnchorSpec = def.anchorPositionFinder(sourceEl, elxy, def, e);\n\n            if (maybeAnchorSpec != null) {\n              tempEndpointParams.anchor = maybeAnchorSpec;\n            }\n          }\n\n          this._originalAnchorSpec = tempEndpointParams.anchor || (this.instance.areDefaultAnchorsSet() ? this.instance.defaults.anchors[0] : this.instance.defaults.anchor);\n\n          var _originalAnchor = this.instance.router.prepareAnchor(this._originalAnchorSpec);\n\n          var anchorSpecToUse = [elxy.x, elxy.y, 0, 0];\n\n          if (_originalAnchor.locations.length > 0) {\n            anchorSpecToUse[2] = _originalAnchor.locations[0].ox;\n            anchorSpecToUse[3] = _originalAnchor.locations[0].oy;\n          } else if (_originalAnchor.isContinuous) {\n            var dx = elxy.x < 0.5 ? elxy.x : 1 - elxy.x;\n            var dy = elxy.y < 0.5 ? elxy.y : 1 - elxy.y;\n            anchorSpecToUse[2] = dx < dy ? elxy.x < 0.5 ? -1 : 1 : 0;\n            anchorSpecToUse[3] = dy < dx ? elxy.y < 0.5 ? -1 : 1 : 0;\n          }\n\n          tempEndpointParams.anchor = anchorSpecToUse;\n          tempEndpointParams.deleteOnEmpty = true;\n          this.ep = this.instance._internal_newEndpoint(tempEndpointParams);\n          var payload = {};\n\n          if (def.extract) {\n            for (var att in def.extract) {\n              var v = eventTarget.getAttribute(att);\n\n              if (v) {\n                payload[def.extract[att]] = v;\n              }\n            }\n\n            this.ep.mergeParameters(payload);\n          }\n\n          if (tempEndpointParams.uniqueEndpoint) {\n            var elementId = this.ep.elementId;\n            var existingUniqueEndpoint = this.instance.getManagedData(elementId, SOURCE_SELECTOR_UNIQUE_ENDPOINT_DATA, sourceSelector.id);\n\n            if (existingUniqueEndpoint == null) {\n              this.instance.setManagedData(elementId, SOURCE_SELECTOR_UNIQUE_ENDPOINT_DATA, sourceSelector.id, this.ep);\n              this.ep.deleteOnEmpty = false;\n            } else {\n              this.ep.finalEndpoint = existingUniqueEndpoint;\n            }\n          }\n\n          sourceElement._jsPlumbOrphanedEndpoints = sourceElement._jsPlumbOrphanedEndpoints || [];\n\n          sourceElement._jsPlumbOrphanedEndpoints.push(this.ep);\n\n          this.instance.trigger(this.ep.endpoint.canvas, EVENT_MOUSEDOWN, e, payload);\n        }\n      }\n    }\n  }, {\n    key: \"_mouseupHandler\",\n    value: function _mouseupHandler(e) {\n      var el = e.currentTarget || e.srcElement;\n\n      if (el._jsPlumbOrphanedEndpoints) {\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.each)(el._jsPlumbOrphanedEndpoints, this.instance._maybePruneEndpoint.bind(this.instance));\n        el._jsPlumbOrphanedEndpoints.length = 0;\n      }\n\n      this._activeDefinition = null;\n    }\n  }, {\n    key: \"onDragInit\",\n    value: function onDragInit(el) {\n      var ipco = this.instance.getOffset(el),\n          ips = this.instance.getSize(el);\n\n      this._makeDraggablePlaceholder(ipco, ips);\n\n      this.placeholderInfo.element.jtk = el.jtk;\n      return this.placeholderInfo.element;\n    }\n  }, {\n    key: \"onDragAbort\",\n    value: function onDragAbort(el) {\n      this._cleanupDraggablePlaceholder();\n    }\n  }, {\n    key: \"_makeDraggablePlaceholder\",\n    value: function _makeDraggablePlaceholder(ipco, ips) {\n      this.placeholderInfo = this.placeholderInfo || {};\n      var n = createElement(ELEMENT_DIV, {\n        position: \"absolute\"\n      });\n\n      this.instance._appendElement(n, this.instance.getContainer());\n\n      var id = this.instance.getId(n);\n      this.instance.setPosition(n, ipco);\n      n.style.width = ips.w + \"px\";\n      n.style.height = ips.h + \"px\";\n      this.instance.manage(n);\n      this.placeholderInfo.id = id;\n      this.placeholderInfo.element = n;\n      return n;\n    }\n  }, {\n    key: \"_cleanupDraggablePlaceholder\",\n    value: function _cleanupDraggablePlaceholder() {\n      if (this.placeholderInfo.element) {\n        this.instance.unmanage(this.placeholderInfo.element, true);\n        delete this.placeholderInfo.element;\n        delete this.placeholderInfo.id;\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var c = this.instance.getContainer();\n      this.instance.off(c, EVENT_MOUSEUP, this.mouseupHandler);\n      this.instance.off(c, EVENT_MOUSEDOWN, this.mousedownHandler);\n    }\n  }, {\n    key: \"init\",\n    value: function init(drag) {}\n  }, {\n    key: \"startNewConnectionDrag\",\n    value: function startNewConnectionDrag(scope, data) {\n      this.jpc = this.instance._newConnection({\n        sourceEndpoint: this.ep,\n        targetEndpoint: this.floatingEndpoint,\n        source: this.ep.element,\n        target: this.placeholderInfo.element,\n        paintStyle: this.ep.connectorStyle,\n        hoverPaintStyle: this.ep.connectorHoverStyle,\n        connector: this.ep.connector,\n        overlays: this.ep.connectorOverlays,\n        type: this.ep.edgeType,\n        cssClass: this.ep.connectorClass,\n        hoverClass: this.ep.connectorHoverClass,\n        scope: scope,\n        data: data\n      });\n      this.jpc.pending = true;\n      this.jpc.addClass(this.instance.draggingClass);\n      this.floatingEndpoint.addClass(this.instance.draggingClass);\n      this.instance.fire(EVENT_CONNECTION_DRAG, this.jpc);\n    }\n  }, {\n    key: \"startExistingConnectionDrag\",\n    value: function startExistingConnectionDrag() {\n      this.existingJpc = true;\n      this.instance.setHover(this.jpc, false);\n      var anchorIdx = this.jpc.endpoints[0].id === this.ep.id ? 0 : 1;\n      this.ep.detachFromConnection(this.jpc, null, true);\n      this.floatingEndpoint.addConnection(this.jpc);\n      this.floatingEndpoint.addClass(this.instance.draggingClass);\n      this.instance.fire(EVENT_CONNECTION_DRAG, this.jpc);\n      this.instance.sourceOrTargetChanged(this.jpc.endpoints[anchorIdx].elementId, this.placeholderInfo.id, this.jpc, this.placeholderInfo.element, anchorIdx);\n      this.jpc.suspendedEndpoint = this.jpc.endpoints[anchorIdx];\n      this.jpc.suspendedElement = this.jpc.endpoints[anchorIdx].element;\n      this.jpc.suspendedElementId = this.jpc.endpoints[anchorIdx].elementId;\n      this.jpc.suspendedElementType = anchorIdx === 0 ? _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.SOURCE : _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.TARGET;\n      this.instance.setHover(this.jpc.suspendedEndpoint, false);\n      this.floatingEndpoint.referenceEndpoint = this.jpc.suspendedEndpoint;\n      this.floatingEndpoint.mergeParameters(this.jpc.suspendedEndpoint.parameters);\n      this.jpc.endpoints[anchorIdx] = this.floatingEndpoint;\n      this.jpc.addClass(this.instance.draggingClass);\n      this.floatingId = this.placeholderInfo.id;\n      this.floatingIndex = anchorIdx;\n    }\n  }, {\n    key: \"_shouldStartDrag\",\n    value: function _shouldStartDrag() {\n      var _continue = true;\n\n      if (!this.ep.enabled) {\n        _continue = false;\n      }\n\n      if (this.jpc == null && !this.ep.isSource && !this.ep.isTemporarySource) {\n        _continue = false;\n      }\n\n      if (this.ep.isSource && this.ep.isFull() && !(this.jpc != null && this.ep.dragAllowedWhenFull)) {\n        _continue = false;\n      }\n\n      if (this.jpc != null && !this.jpc.isDetachable(this.ep)) {\n        if (this.ep.isFull()) {\n          _continue = false;\n        } else {\n          this.jpc = null;\n        }\n      }\n\n      var payload = {};\n      var beforeDrag = this.instance.checkCondition(this.jpc == null ? _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.INTERCEPT_BEFORE_DRAG : _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.INTERCEPT_BEFORE_START_DETACH, {\n        endpoint: this.ep,\n        source: this.ep.element,\n        sourceId: this.ep.elementId,\n        connection: this.jpc\n      });\n\n      if (beforeDrag === false) {\n        _continue = false;\n      } else if (_typeof(beforeDrag) === \"object\") {\n        payload = beforeDrag;\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.extend)(payload, this.payload || {});\n      } else {\n        payload = this.payload || {};\n      }\n\n      return [_continue, payload];\n    }\n  }, {\n    key: \"_createFloatingEndpoint\",\n    value: function _createFloatingEndpoint(canvasElement) {\n      var endpointToFloat = this.ep.endpoint;\n\n      if (this.ep.edgeType != null) {\n        var aae = this.instance._deriveEndpointAndAnchorSpec(this.ep.edgeType);\n\n        endpointToFloat = aae.endpoints[1];\n      }\n\n      this.floatingEndpoint = _makeFloatingEndpoint(this.ep, endpointToFloat, canvasElement, this.placeholderInfo.element, this.instance);\n      this.floatingAnchor = this.floatingEndpoint._anchor;\n      this.floatingEndpoint.deleteOnEmpty = true;\n      this.floatingElement = this.floatingEndpoint.endpoint.canvas;\n      this.floatingId = this.instance.getId(this.floatingElement);\n    }\n  }, {\n    key: \"_populateTargets\",\n    value: function _populateTargets(canvasElement, eventTarget, event) {\n      var _this = this;\n\n      var isSourceDrag = this.jpc && this.jpc.endpoints[0] === this.ep;\n      var boundingRect;\n      var matchingEndpoints = this.instance.getContainer().querySelectorAll([\".\", _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.CLASS_ENDPOINT, \"[\", _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.ATTRIBUTE_SCOPE_PREFIX, this.ep.scope, \"]\"].join(\"\"));\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(matchingEndpoints, function (candidate) {\n        if ((_this.jpc != null || candidate !== canvasElement) && candidate !== _this.floatingElement && !candidate.jtk.endpoint.isFull()) {\n          if (isSourceDrag && candidate.jtk.endpoint.isSource || !isSourceDrag && candidate.jtk.endpoint.isTarget) {\n            var o = _this.instance.getOffset(candidate),\n                s = _this.instance.getSize(candidate);\n\n            boundingRect = {\n              x: o.x,\n              y: o.y,\n              w: s.w,\n              h: s.h\n            };\n\n            _this.endpointDropTargets.push({\n              el: candidate,\n              targetEl: candidate,\n              r: boundingRect,\n              endpoint: candidate.jtk.endpoint,\n              def: null\n            });\n\n            _this.instance.addClass(candidate, CLASS_DRAG_ACTIVE);\n          }\n        }\n      });\n\n      if (isSourceDrag) {\n        var sourceDef = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.getWithFunction)(this.instance.sourceSelectors, function (sSel) {\n          return sSel.isEnabled() && (sSel.def.def.scope == null || sSel.def.def.scope === _this.ep.scope);\n        });\n\n        if (sourceDef != null) {\n          var targetZones = this.instance.getContainer().querySelectorAll(sourceDef.redrop === _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.REDROP_POLICY_ANY ? _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.SELECTOR_MANAGED_ELEMENT : sourceDef.selector);\n          (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(targetZones, function (el) {\n            if (el.getAttribute(ATTRIBUTE_JTK_ENABLED) !== _jsplumb_common__WEBPACK_IMPORTED_MODULE_2__.FALSE) {\n              var scopeFromElement = el.getAttribute(ATTRIBUTE_JTK_SCOPE);\n\n              if (scopeFromElement != null && scopeFromElement !== _this.ep.scope) {\n                return;\n              }\n\n              var d = {\n                r: null,\n                el: el\n              };\n              d.targetEl = findParent(el, _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.SELECTOR_MANAGED_ELEMENT, _this.instance.getContainer(), true);\n\n              var o = _this.instance.getOffset(d.el),\n                  s = _this.instance.getSize(d.el);\n\n              d.r = {\n                x: o.x,\n                y: o.y,\n                w: s.w,\n                h: s.h\n              };\n\n              if (sourceDef.def.def.rank != null) {\n                d.rank = sourceDef.def.def.rank;\n              }\n\n              d.def = sourceDef;\n\n              _this.endpointDropTargets.push(d);\n\n              _this.instance.addClass(d.targetEl, CLASS_DRAG_ACTIVE);\n            }\n          });\n        }\n      } else {\n        var targetDefs = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.getAllWithFunction)(this.instance.targetSelectors, function (tSel) {\n          return tSel.isEnabled();\n        });\n        targetDefs.forEach(function (targetDef) {\n          var targetZones = _this.instance.getContainer().querySelectorAll(targetDef.selector);\n\n          (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(targetZones, function (el) {\n            if (el.getAttribute(ATTRIBUTE_JTK_ENABLED) !== _jsplumb_common__WEBPACK_IMPORTED_MODULE_2__.FALSE) {\n              var scopeFromElement = el.getAttribute(ATTRIBUTE_JTK_SCOPE);\n\n              if (scopeFromElement != null && scopeFromElement !== _this.ep.scope) {\n                return;\n              }\n\n              var d = {\n                r: null,\n                el: el\n              };\n\n              if (targetDef.def.def.parentSelector != null) {\n                d.targetEl = findParent(el, targetDef.def.def.parentSelector, _this.instance.getContainer(), true);\n              }\n\n              if (d.targetEl == null) {\n                d.targetEl = findParent(el, _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.SELECTOR_MANAGED_ELEMENT, _this.instance.getContainer(), true);\n              }\n\n              if (targetDef.def.def.allowLoopback === false || _this._activeDefinition && _this._activeDefinition.def.def.allowLoopback === false) {\n                if (d.targetEl === _this.ep.element) {\n                  return;\n                }\n              }\n\n              if (targetDef.def.def.canAcceptNewConnection != null && !targetDef.def.def.canAcceptNewConnection(d.targetEl, event)) {\n                return;\n              }\n\n              var maxConnections = targetDef.def.def.maxConnections;\n\n              if (maxConnections != null && maxConnections !== -1) {\n                if (_this.instance.select({\n                  target: d.targetEl\n                }).length >= maxConnections) {\n                  return;\n                }\n              }\n\n              var o = _this.instance.getOffset(el),\n                  s = _this.instance.getSize(el);\n\n              d.r = {\n                x: o.x,\n                y: o.y,\n                w: s.w,\n                h: s.h\n              };\n              d.def = targetDef.def;\n\n              if (targetDef.def.def.rank != null) {\n                d.rank = targetDef.def.def.rank;\n              }\n\n              _this.endpointDropTargets.push(d);\n\n              _this.instance.addClass(d.targetEl, CLASS_DRAG_ACTIVE);\n            }\n          });\n        });\n      }\n\n      this.endpointDropTargets.sort(function (a, b) {\n        if (a.targetEl._isJsPlumbGroup && !b.targetEl._isJsPlumbGroup) {\n          return 1;\n        } else if (!a.targetEl._isJsPlumbGroup && b.targetEl._isJsPlumbGroup) {\n          return -1;\n        } else {\n          if (a.targetEl._isJsPlumbGroup && b.targetEl._isJsPlumbGroup) {\n            if (_this.instance.groupManager.isAncestor(a.targetEl._jsPlumbGroup, b.targetEl._jsPlumbGroup)) {\n              return -1;\n            } else if (_this.instance.groupManager.isAncestor(b.targetEl._jsPlumbGroup, a.targetEl._jsPlumbGroup)) {\n              return 1;\n            }\n          } else {\n            if (a.rank != null && b.rank != null) {\n              if (a.rank > b.rank) {\n                return -1;\n              } else if (a.rank < b.rank) {\n                return 1;\n              } else ;\n            } else {\n              return 0;\n            }\n          }\n        }\n      });\n    }\n  }, {\n    key: \"onStart\",\n    value: function onStart(p) {\n      this.endpointDropTargets.length = 0;\n      this.currentDropTarget = null;\n      this._stopped = false;\n      var dragEl = p.drag.getDragElement();\n      this.ep = dragEl.jtk.endpoint;\n      var eventTarget = p.e.srcElement || p.e.target;\n\n      if (!this.ep) {\n        return false;\n      }\n\n      this.endpointRepresentation = this.ep.endpoint;\n      this.canvasElement = this.endpointRepresentation.canvas;\n      this.jpc = this.ep.connectorSelector();\n\n      var _this$_shouldStartDra = this._shouldStartDrag(),\n          _this$_shouldStartDra2 = _slicedToArray(_this$_shouldStartDra, 2),\n          _continue = _this$_shouldStartDra2[0],\n          payload = _this$_shouldStartDra2[1];\n\n      if (_continue === false) {\n        this._stopped = true;\n        return false;\n      }\n\n      this.instance.setHover(this.ep, false);\n      this.instance.isConnectionBeingDragged = true;\n\n      if (this.jpc && !this.ep.isFull() && this.ep.isSource) {\n        this.jpc = null;\n      }\n\n      this._createFloatingEndpoint(this.canvasElement);\n\n      this._populateTargets(this.canvasElement, eventTarget, p.e);\n\n      if (this.jpc == null) {\n        this.startNewConnectionDrag(this.ep.scope, payload);\n      } else {\n        this.startExistingConnectionDrag();\n      }\n\n      this._registerFloatingConnection(this.placeholderInfo, this.jpc, this.floatingEndpoint);\n\n      this.instance.currentlyDragging = true;\n    }\n  }, {\n    key: \"onBeforeStart\",\n    value: function onBeforeStart(beforeStartParams) {\n      this.payload = beforeStartParams.e.payload || {};\n    }\n  }, {\n    key: \"onDrag\",\n    value: function onDrag(params) {\n      if (this._stopped) {\n        return true;\n      }\n\n      if (this.placeholderInfo.element) {\n        var floatingElementSize = this.instance.getSize(this.floatingElement);\n        this.instance.setElementPosition(this.placeholderInfo.element, params.pos.x, params.pos.y);\n\n        var boundingRect = {\n          x: params.pos.x,\n          y: params.pos.y,\n          w: floatingElementSize.w,\n          h: floatingElementSize.h\n        },\n            newDropTarget,\n            idx,\n            _cont;\n\n        for (var i = 0; i < this.endpointDropTargets.length; i++) {\n          if ((0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.intersects)(boundingRect, this.endpointDropTargets[i].r)) {\n            newDropTarget = this.endpointDropTargets[i];\n            break;\n          }\n        }\n\n        if (newDropTarget !== this.currentDropTarget && this.currentDropTarget != null) {\n          idx = this._getFloatingAnchorIndex();\n          this.instance.removeClass(this.currentDropTarget.el, CLASS_DRAG_HOVER);\n\n          if (this.currentDropTarget.endpoint) {\n            this.currentDropTarget.endpoint.endpoint.removeClass(this.instance.endpointDropAllowedClass);\n            this.currentDropTarget.endpoint.endpoint.removeClass(this.instance.endpointDropForbiddenClass);\n          }\n\n          this.floatingAnchor.out();\n        }\n\n        if (newDropTarget != null) {\n          this.instance.addClass(newDropTarget.el, CLASS_DRAG_HOVER);\n          idx = this._getFloatingAnchorIndex();\n\n          if (newDropTarget.endpoint != null) {\n            _cont = newDropTarget.endpoint.isSource && idx === 0 || newDropTarget.endpoint.isTarget && idx !== 0 || this.jpc.suspendedEndpoint && newDropTarget.endpoint.referenceEndpoint && newDropTarget.endpoint.referenceEndpoint.id === this.jpc.suspendedEndpoint.id;\n\n            if (_cont) {\n              var bb = this.instance.checkCondition(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.CHECK_DROP_ALLOWED, {\n                sourceEndpoint: this.jpc.endpoints[idx],\n                targetEndpoint: newDropTarget.endpoint.endpoint,\n                connection: this.jpc\n              });\n\n              if (bb) {\n                newDropTarget.endpoint.endpoint.addClass(this.instance.endpointDropAllowedClass);\n                newDropTarget.endpoint.endpoint.removeClass(this.instance.endpointDropForbiddenClass);\n              } else {\n                newDropTarget.endpoint.endpoint.removeClass(this.instance.endpointDropAllowedClass);\n                newDropTarget.endpoint.endpoint.addClass(this.instance.endpointDropForbiddenClass);\n              }\n\n              this.floatingAnchor.over(newDropTarget.endpoint);\n\n              this.instance._paintConnection(this.jpc);\n            } else {\n              newDropTarget = null;\n            }\n          }\n        }\n\n        this.currentDropTarget = newDropTarget;\n      }\n    }\n  }, {\n    key: \"_maybeCleanup\",\n    value: function _maybeCleanup(ep) {\n      if (ep._mtNew && ep.connections.length === 0) {\n        this.instance.deleteEndpoint(ep);\n      } else {\n        delete ep._mtNew;\n      }\n    }\n  }, {\n    key: \"_reattachOrDiscard\",\n    value: function _reattachOrDiscard(originalEvent) {\n      var existingConnection = this.jpc.suspendedEndpoint != null;\n\n      var idx = this._getFloatingAnchorIndex();\n\n      if (existingConnection && this._shouldReattach(originalEvent)) {\n        if (idx === 0) {\n          this.jpc.source = this.jpc.suspendedElement;\n          this.jpc.sourceId = this.jpc.suspendedElementId;\n        } else {\n          this.jpc.target = this.jpc.suspendedElement;\n          this.jpc.targetId = this.jpc.suspendedElementId;\n        }\n\n        this._doForceReattach(idx);\n\n        return true;\n      } else {\n        this._discard(idx, originalEvent);\n\n        return false;\n      }\n    }\n  }, {\n    key: \"onStop\",\n    value: function onStop(p) {\n      var _this2 = this;\n\n      var originalEvent = p.e;\n      this.instance.isConnectionBeingDragged = false;\n      this.instance.currentlyDragging = false;\n      var classesToRemove = (0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.classList)(CLASS_DRAG_HOVER, CLASS_DRAG_ACTIVE);\n      var matchingSelectors = this.instance.getContainer().querySelectorAll(SELECTOR_DRAG_ACTIVE_OR_HOVER);\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(matchingSelectors, function (el) {\n        _this2.instance.removeClass(el, classesToRemove);\n      });\n\n      if (this.jpc && this.jpc.endpoints != null) {\n        var existingConnection = this.jpc.suspendedEndpoint != null;\n\n        var idx = this._getFloatingAnchorIndex();\n\n        var suspendedEndpoint = this.jpc.suspendedEndpoint;\n        var dropEndpoint;\n\n        if (this.currentDropTarget != null) {\n          dropEndpoint = this._getDropEndpoint(p, this.jpc);\n\n          if (dropEndpoint == null) {\n            !this._reattachOrDiscard(p.e);\n          } else {\n            if (suspendedEndpoint && suspendedEndpoint.id === dropEndpoint.id) {\n              this._doForceReattach(idx);\n            } else {\n              if (!dropEndpoint.enabled) {\n                this._reattachOrDiscard(p.e);\n              } else if (dropEndpoint.isFull()) {\n                dropEndpoint.fire(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.EVENT_MAX_CONNECTIONS, {\n                  endpoint: this,\n                  connection: this.jpc,\n                  maxConnections: this.instance.defaults.maxConnections\n                }, originalEvent);\n\n                this._reattachOrDiscard(p.e);\n              } else {\n                if (idx === 0) {\n                  this.jpc.source = dropEndpoint.element;\n                  this.jpc.sourceId = dropEndpoint.elementId;\n                } else {\n                  this.jpc.target = dropEndpoint.element;\n                  this.jpc.targetId = dropEndpoint.elementId;\n                }\n\n                var _doContinue = true;\n\n                if (existingConnection && this.jpc.suspendedEndpoint.id !== dropEndpoint.id) {\n                  if (!this.jpc.isDetachAllowed(this.jpc) || !this.jpc.endpoints[idx].isDetachAllowed(this.jpc) || !this.jpc.suspendedEndpoint.isDetachAllowed(this.jpc) || !this.instance.checkCondition(\"beforeDetach\", this.jpc)) {\n                    _doContinue = false;\n                  }\n                }\n\n                _doContinue = _doContinue && dropEndpoint.isDropAllowed(this.jpc.sourceId, this.jpc.targetId, this.jpc.scope, this.jpc, dropEndpoint);\n\n                if (_doContinue) {\n                  this._drop(dropEndpoint, idx, originalEvent, _doContinue);\n                } else {\n                  this._reattachOrDiscard(p.e);\n                }\n              }\n            }\n          }\n        } else {\n          this._reattachOrDiscard(p.e);\n        }\n\n        this.instance._refreshEndpoint(this.ep);\n\n        this.ep.removeClass(this.instance.draggingClass);\n\n        this._cleanupDraggablePlaceholder();\n\n        this.jpc.removeClass(this.instance.draggingClass);\n        delete this.jpc.suspendedEndpoint;\n        delete this.jpc.suspendedElement;\n        delete this.jpc.suspendedElementType;\n        delete this.jpc.suspendedElementId;\n        delete this.jpc.suspendedIndex;\n        delete this.floatingId;\n        delete this.floatingIndex;\n        delete this.floatingElement;\n        delete this.floatingEndpoint;\n        delete this.floatingAnchor;\n        delete this.jpc.pending;\n\n        if (dropEndpoint != null) {\n          this._maybeCleanup(dropEndpoint);\n        }\n      }\n    }\n  }, {\n    key: \"_getSourceDefinition\",\n    value: function _getSourceDefinition(evt) {\n      var selector;\n\n      for (var i = 0; i < this.instance.sourceSelectors.length; i++) {\n        selector = this.instance.sourceSelectors[i];\n\n        if (selector.isEnabled()) {\n          var r = selectorFilter(evt, this.instance.getContainer(), selector.selector, this.instance, selector.exclude);\n\n          if (r !== false) {\n            return selector;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_getDropEndpoint\",\n    value: function _getDropEndpoint(p, jpc) {\n      var dropEndpoint;\n\n      if (this.currentDropTarget.endpoint == null) {\n        var targetDefinition = this.currentDropTarget.def;\n        var eventTarget = p.e.target || p.e.srcElement;\n\n        if (targetDefinition == null) {\n          return null;\n        }\n\n        var targetElement = this.currentDropTarget.targetEl;\n        var elxy = getPositionOnElement(p.e, targetElement, this.instance.currentZoom);\n\n        var eps = this.instance._deriveEndpointAndAnchorSpec(jpc.getType().join(\" \"), true);\n\n        var pp = eps.endpoints ? (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.extend)(p, {\n          endpoint: targetDefinition.def.endpoint || eps.endpoints[1]\n        }) : p;\n        var anchorsToUse = this.instance.validAnchorsSpec(eps.anchors) ? eps.anchors : this.instance.areDefaultAnchorsSet() ? this.instance.defaults.anchors : null;\n        var anchorFromDef = targetDefinition.def.anchor;\n        var anchorFromPositionFinder = targetDefinition.def.anchorPositionFinder ? targetDefinition.def.anchorPositionFinder(targetElement, elxy, targetDefinition.def, p.e) : null;\n        var dropAnchor = anchorFromPositionFinder != null ? anchorFromPositionFinder : anchorFromDef != null ? anchorFromDef : anchorsToUse != null && anchorsToUse[1] != null ? anchorsToUse[1] : null;\n\n        if (dropAnchor != null) {\n          pp = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.extend)(pp, {\n            anchor: dropAnchor\n          });\n        }\n\n        if (targetDefinition.def.portId != null) {\n          pp.portId = targetDefinition.def.portId;\n        }\n\n        var extractedParameters = targetDefinition.def.parameterExtractor ? targetDefinition.def.parameterExtractor(this.currentDropTarget.el, eventTarget, p.e) : {};\n        pp = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.merge)(pp, extractedParameters);\n        pp.element = targetElement;\n        dropEndpoint = this.instance._internal_newEndpoint(pp);\n        dropEndpoint._mtNew = true;\n        dropEndpoint.deleteOnEmpty = true;\n\n        if (targetDefinition.def.parameters) {\n          dropEndpoint.mergeParameters(targetDefinition.def.parameters);\n        }\n\n        if (targetDefinition.def.extract) {\n          var tpayload = {};\n\n          for (var att in targetDefinition.def.extract) {\n            var v = this.currentDropTarget.el.getAttribute(att);\n\n            if (v) {\n              tpayload[targetDefinition.def.extract[att]] = v;\n            }\n          }\n\n          dropEndpoint.mergeParameters(tpayload);\n        }\n      } else {\n        dropEndpoint = this.currentDropTarget.endpoint;\n      }\n\n      if (dropEndpoint) {\n        dropEndpoint.removeClass(this.instance.endpointDropAllowedClass);\n        dropEndpoint.removeClass(this.instance.endpointDropForbiddenClass);\n      }\n\n      return dropEndpoint;\n    }\n  }, {\n    key: \"_doForceReattach\",\n    value: function _doForceReattach(idx) {\n      this.floatingEndpoint.detachFromConnection(this.jpc, null, true);\n      this.jpc.endpoints[idx] = this.jpc.suspendedEndpoint;\n      this.instance.setHover(this.jpc, false);\n      this.jpc._forceDetach = true;\n      this.jpc.suspendedEndpoint.addConnection(this.jpc);\n      this.instance.sourceOrTargetChanged(this.floatingId, this.jpc.suspendedEndpoint.elementId, this.jpc, this.jpc.suspendedEndpoint.element, idx);\n      this.instance.deleteEndpoint(this.floatingEndpoint);\n      this.instance.repaint(this.jpc.source);\n      delete this.jpc._forceDetach;\n    }\n  }, {\n    key: \"_shouldReattach\",\n    value: function _shouldReattach(originalEvent) {\n      return this.jpc.isReattach() || this.jpc._forceReattach || !(0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.functionChain)(true, false, [[this.jpc.endpoints[0], _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.IS_DETACH_ALLOWED, [this.jpc]], [this.jpc.endpoints[1], _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.IS_DETACH_ALLOWED, [this.jpc]], [this.jpc, _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.IS_DETACH_ALLOWED, [this.jpc]], [this.instance, _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.CHECK_CONDITION, [_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.INTERCEPT_BEFORE_DETACH, this.jpc]]]);\n    }\n  }, {\n    key: \"_discard\",\n    value: function _discard(idx, originalEvent) {\n      if (this.jpc.pending) {\n        this.instance.fire(EVENT_CONNECTION_ABORT, this.jpc, originalEvent);\n      } else {\n        if (idx === 0) {\n          this.jpc.source = this.jpc.suspendedEndpoint.element;\n          this.jpc.sourceId = this.jpc.suspendedEndpoint.elementId;\n        } else {\n          this.jpc.target = this.jpc.suspendedEndpoint.element;\n          this.jpc.targetId = this.jpc.suspendedEndpoint.elementId;\n        }\n\n        this.jpc.endpoints[idx] = this.jpc.suspendedEndpoint;\n      }\n\n      if (this.floatingEndpoint) {\n        this.floatingEndpoint.detachFromConnection(this.jpc);\n      }\n\n      this.instance.deleteConnection(this.jpc, {\n        originalEvent: originalEvent,\n        force: true\n      });\n    }\n  }, {\n    key: \"_drop\",\n    value: function _drop(dropEndpoint, idx, originalEvent, optionalData) {\n      this.jpc.endpoints[idx].detachFromConnection(this.jpc);\n\n      if (this.jpc.suspendedEndpoint) {\n        this.jpc.suspendedEndpoint.detachFromConnection(this.jpc);\n      }\n\n      this.jpc.endpoints[idx] = dropEndpoint;\n      dropEndpoint.addConnection(this.jpc);\n\n      if (this.jpc.suspendedEndpoint) {\n        var suspendedElementId = this.jpc.suspendedEndpoint.elementId;\n        this.instance.fireMoveEvent({\n          index: idx,\n          originalSourceId: idx === 0 ? suspendedElementId : this.jpc.sourceId,\n          newSourceId: idx === 0 ? dropEndpoint.elementId : this.jpc.sourceId,\n          originalTargetId: idx === 1 ? suspendedElementId : this.jpc.targetId,\n          newTargetId: idx === 1 ? dropEndpoint.elementId : this.jpc.targetId,\n          originalEndpoint: this.jpc.suspendedEndpoint,\n          connection: this.jpc,\n          newEndpoint: dropEndpoint\n        }, originalEvent);\n      }\n\n      if (idx === 1) {\n        this.instance.sourceOrTargetChanged(this.floatingId, this.jpc.targetId, this.jpc, this.jpc.target, 1);\n      } else {\n        this.instance.sourceOrTargetChanged(this.floatingId, this.jpc.sourceId, this.jpc, this.jpc.source, 0);\n      }\n\n      if (this.jpc.endpoints[0].finalEndpoint) {\n        var _toDelete = this.jpc.endpoints[0];\n\n        _toDelete.detachFromConnection(this.jpc);\n\n        this.jpc.endpoints[0] = this.jpc.endpoints[0].finalEndpoint;\n        this.jpc.endpoints[0].addConnection(this.jpc);\n      }\n\n      if ((0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(optionalData)) {\n        this.jpc.mergeData(optionalData);\n      }\n\n      if (this._originalAnchorSpec) {\n        this.jpc.endpoints[0].setAnchor(this._originalAnchorSpec);\n        this._originalAnchorSpec = null;\n      }\n\n      this.instance._finaliseConnection(this.jpc, null, originalEvent);\n\n      this.instance.setHover(this.jpc, false);\n      this.instance.revalidate(this.jpc.endpoints[0].element);\n    }\n  }, {\n    key: \"_registerFloatingConnection\",\n    value: function _registerFloatingConnection(info, conn, ep) {\n      this.floatingConnections[info.id] = conn;\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.addToDictionary)(this.instance.endpointsByElement, info.id, ep);\n    }\n  }, {\n    key: \"_getFloatingAnchorIndex\",\n    value: function _getFloatingAnchorIndex() {\n      return this.floatingIndex == null ? 1 : this.floatingIndex;\n    }\n  }]);\n\n  return EndpointDragHandler;\n}();\n\nvar GroupDragHandler = function (_ElementDragHandler) {\n  _inherits(GroupDragHandler, _ElementDragHandler);\n\n  var _super = _createSuper(GroupDragHandler);\n\n  function GroupDragHandler(instance, dragSelection) {\n    var _this;\n\n    _classCallCheck(this, GroupDragHandler);\n\n    _this = _super.call(this, instance, dragSelection);\n    _this.instance = instance;\n    _this.dragSelection = dragSelection;\n\n    _defineProperty(_assertThisInitialized(_this), \"selector\", [\">\", SELECTOR_GROUP, _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.SELECTOR_MANAGED_ELEMENT].join(\" \"));\n\n    _defineProperty(_assertThisInitialized(_this), \"doRevalidate\", void 0);\n\n    _this.doRevalidate = _this._revalidate.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(GroupDragHandler, [{\n    key: \"reset\",\n    value: function reset() {\n      this.drag.off(EVENT_REVERT, this.doRevalidate);\n    }\n  }, {\n    key: \"_revalidate\",\n    value: function _revalidate(el) {\n      this.instance.revalidate(el);\n    }\n  }, {\n    key: \"init\",\n    value: function init(drag) {\n      this.drag = drag;\n      drag.on(EVENT_REVERT, this.doRevalidate);\n    }\n  }, {\n    key: \"useGhostProxy\",\n    value: function useGhostProxy(container, dragEl) {\n      var group = dragEl._jsPlumbParentGroup;\n      return group == null ? false : group.ghost === true;\n    }\n  }, {\n    key: \"makeGhostProxy\",\n    value: function makeGhostProxy(el) {\n      var jel = el;\n      var newEl = jel.cloneNode(true);\n      newEl._jsPlumbParentGroup = jel._jsPlumbParentGroup;\n      return newEl;\n    }\n  }]);\n\n  return GroupDragHandler;\n}(ElementDragHandler);\n\nvar HTMLElementOverlay = function () {\n  function HTMLElementOverlay(instance, overlay) {\n    _classCallCheck(this, HTMLElementOverlay);\n\n    this.instance = instance;\n    this.overlay = overlay;\n\n    _defineProperty(this, \"htmlElementOverlay\", void 0);\n\n    this.htmlElementOverlay = overlay;\n  }\n\n  _createClass(HTMLElementOverlay, null, [{\n    key: \"getElement\",\n    value: function getElement(o, component, elementCreator) {\n      if (o.canvas == null) {\n        if (elementCreator && component) {\n          o.canvas = elementCreator(component);\n          var cls = o.instance.overlayClass + \" \" + (o.cssClass ? o.cssClass : \"\");\n          o.instance.addClass(o.canvas, cls);\n        } else {\n          o.canvas = createElement(ELEMENT_DIV, {}, o.instance.overlayClass + \" \" + (o.cssClass ? o.cssClass : \"\"));\n        }\n\n        o.instance.setAttribute(o.canvas, \"jtk-overlay-id\", o.id);\n\n        for (var att in o.attributes) {\n          o.instance.setAttribute(o.canvas, att, o.attributes[att]);\n        }\n\n        o.canvas.style.position = _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.ABSOLUTE;\n\n        o.instance._appendElement(o.canvas, o.instance.getContainer());\n\n        o.instance.getId(o.canvas);\n        var ts = \"translate(-50%, -50%)\";\n        o.canvas.style.webkitTransform = ts;\n        o.canvas.style.mozTransform = ts;\n        o.canvas.style.msTransform = ts;\n        o.canvas.style.oTransform = ts;\n        o.canvas.style.transform = ts;\n\n        if (!o.isVisible()) {\n          o.canvas.style.display = _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.NONE;\n        }\n\n        o.canvas.jtk = {\n          overlay: o\n        };\n      }\n\n      return o.canvas;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(o) {\n      o.canvas && o.canvas.parentNode && o.canvas.parentNode.removeChild(o.canvas);\n      delete o.canvas;\n      delete o.cachedDimensions;\n    }\n  }, {\n    key: \"_getDimensions\",\n    value: function _getDimensions(o, forceRefresh) {\n      if (o.cachedDimensions == null || forceRefresh) {\n        o.cachedDimensions = {\n          w: 1,\n          h: 1\n        };\n      }\n\n      return o.cachedDimensions;\n    }\n  }]);\n\n  return HTMLElementOverlay;\n}();\n\nvar SVGElementOverlay = function (_Overlay) {\n  _inherits(SVGElementOverlay, _Overlay);\n\n  var _super = _createSuper(SVGElementOverlay);\n\n  function SVGElementOverlay() {\n    var _this;\n\n    _classCallCheck(this, SVGElementOverlay);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"path\", void 0);\n\n    return _this;\n  }\n\n  _createClass(SVGElementOverlay, null, [{\n    key: \"ensurePath\",\n    value: function ensurePath(o) {\n      if (o.path == null) {\n        var atts = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.extend)({\n          \"jtk-overlay-id\": o.id\n        }, o.attributes);\n        o.path = _node(ELEMENT_PATH, atts);\n        var parent = null;\n\n        if (o.component instanceof _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.Connection) {\n          var connector = o.component.connector;\n          parent = connector != null ? connector.canvas : null;\n        } else if (o.component instanceof _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.Endpoint) {\n          var endpoint = o.component.endpoint;\n          parent = endpoint != null ? endpoint.svg : endpoint;\n        }\n\n        if (parent != null) {\n          _appendAtIndex(parent, o.path, 1);\n        }\n\n        var cls = o.instance.overlayClass + \" \" + (o.cssClass ? o.cssClass : \"\");\n        o.instance.addClass(o.path, cls);\n        o.path.jtk = {\n          overlay: o\n        };\n      }\n\n      return o.path;\n    }\n  }, {\n    key: \"paint\",\n    value: function paint(o, path, params, extents) {\n      this.ensurePath(o);\n      var offset = [0, 0];\n\n      if (extents.xmin < 0) {\n        offset[0] = -extents.xmin;\n      }\n\n      if (extents.ymin < 0) {\n        offset[1] = -extents.ymin;\n      }\n\n      var a = {\n        \"d\": path,\n        stroke: params.stroke ? params.stroke : null,\n        fill: params.fill ? params.fill : null,\n        transform: \"translate(\" + offset[0] + \",\" + offset[1] + \")\",\n        \"pointer-events\": \"visibleStroke\"\n      };\n\n      _attr(o.path, a);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(o, force) {\n      var _o = o;\n\n      if (_o.path != null && _o.path.parentNode != null) {\n        _o.path.parentNode.removeChild(_o.path);\n      }\n\n      if (_o.bgPath != null && _o.bgPath.parentNode != null) {\n        _o.bgPath.parentNode.removeChild(_o.bgPath);\n      }\n\n      delete _o.path;\n      delete _o.bgPath;\n    }\n  }]);\n\n  return SVGElementOverlay;\n}(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.Overlay);\n\nvar SvgComponent = function () {\n  function SvgComponent() {\n    _classCallCheck(this, SvgComponent);\n  }\n\n  _createClass(SvgComponent, null, [{\n    key: \"paint\",\n    value: function paint(connector, useDivWrapper, paintStyle, extents) {\n      if (paintStyle != null) {\n        var xy = [connector.x, connector.y],\n            wh = [connector.w, connector.h],\n            p;\n\n        if (extents != null) {\n          if (extents.xmin < 0) {\n            xy[0] += extents.xmin;\n          }\n\n          if (extents.ymin < 0) {\n            xy[1] += extents.ymin;\n          }\n\n          wh[0] = extents.xmax + (extents.xmin < 0 ? -extents.xmin : 0);\n          wh[1] = extents.ymax + (extents.ymin < 0 ? -extents.ymin : 0);\n        }\n\n        if (isFinite(wh[0]) && isFinite(wh[1])) {\n          if (useDivWrapper) {\n            _size(connector.canvas, xy[0], xy[1], wh[0], wh[1]);\n\n            xy[0] = 0;\n            xy[1] = 0;\n            p = _pos([0, 0]);\n\n            _attr(connector.svg, {\n              \"style\": p,\n              \"width\": \"\" + (wh[0] || 0),\n              \"height\": \"\" + (wh[1] || 0)\n            });\n          } else {\n            p = _pos([xy[0], xy[1]]);\n\n            _attr(connector.canvas, {\n              \"style\": p,\n              \"width\": \"\" + (wh[0] || 0),\n              \"height\": \"\" + (wh[1] || 0)\n            });\n          }\n        }\n      }\n    }\n  }]);\n\n  return SvgComponent;\n}();\n\nfunction paintSvgConnector(instance, connector, paintStyle, extents) {\n  getConnectorElement(instance, connector);\n  SvgComponent.paint(connector, false, paintStyle, extents);\n  var p = \"\",\n      offset = [0, 0];\n\n  if (extents.xmin < 0) {\n    offset[0] = -extents.xmin;\n  }\n\n  if (extents.ymin < 0) {\n    offset[1] = -extents.ymin;\n  }\n\n  if (connector.segments.length > 0) {\n    p = instance.getPathData(connector);\n    var a = {\n      d: p,\n      transform: \"translate(\" + offset[0] + \",\" + offset[1] + \")\",\n      \"pointer-events\": \"visibleStroke\"\n    },\n        outlineStyle = null;\n\n    if (paintStyle.outlineStroke) {\n      var outlineWidth = paintStyle.outlineWidth || 1,\n          outlineStrokeWidth = paintStyle.strokeWidth + 2 * outlineWidth;\n      outlineStyle = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.extend)({}, paintStyle);\n      outlineStyle.stroke = paintStyle.outlineStroke;\n      outlineStyle.strokeWidth = outlineStrokeWidth;\n\n      if (connector.bgPath == null) {\n        connector.bgPath = _node(ELEMENT_PATH, a);\n        instance.addClass(connector.bgPath, instance.connectorOutlineClass);\n\n        _appendAtIndex(connector.canvas, connector.bgPath, 0);\n      } else {\n        _attr(connector.bgPath, a);\n      }\n\n      _applyStyles(connector.canvas, connector.bgPath, outlineStyle);\n    }\n\n    var cany = connector;\n\n    if (cany.path == null) {\n      cany.path = _node(ELEMENT_PATH, a);\n\n      _appendAtIndex(cany.canvas, cany.path, paintStyle.outlineStroke ? 1 : 0);\n    } else {\n      if (cany.path.parentNode !== cany.canvas) {\n        _appendAtIndex(cany.canvas, cany.path, paintStyle.outlineStroke ? 1 : 0);\n      }\n\n      _attr(connector.path, a);\n    }\n\n    _applyStyles(connector.canvas, connector.path, paintStyle);\n  }\n}\n\nfunction getConnectorElement(instance, c) {\n  if (c.canvas != null) {\n    return c.canvas;\n  } else {\n    var svg = _node(ELEMENT_SVG, {\n      \"style\": \"\",\n      \"width\": \"0\",\n      \"height\": \"0\",\n      \"pointer-events\": _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.NONE,\n      \"position\": _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.ABSOLUTE\n    });\n\n    c.canvas = svg;\n\n    instance._appendElement(c.canvas, instance.getContainer());\n\n    if (c.cssClass != null) {\n      instance.addClass(svg, c.cssClass);\n    }\n\n    instance.addClass(svg, instance.connectorClass);\n    svg.jtk = svg.jtk || {};\n    svg.jtk.connector = c;\n    return svg;\n  }\n}\n\nvar SvgEndpoint = function () {\n  function SvgEndpoint() {\n    _classCallCheck(this, SvgEndpoint);\n  }\n\n  _createClass(SvgEndpoint, null, [{\n    key: \"getEndpointElement\",\n    value: function getEndpointElement(ep) {\n      if (ep.canvas != null) {\n        return ep.canvas;\n      } else {\n        var svg = _node(ELEMENT_SVG, {\n          \"style\": \"\",\n          \"width\": \"0\",\n          \"height\": \"0\",\n          \"pointer-events\": _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.NONE,\n          \"position\": _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.ABSOLUTE\n        });\n\n        ep.svg = svg;\n        var canvas = createElement(ELEMENT_DIV, {\n          position: _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.ABSOLUTE\n        });\n        ep.canvas = canvas;\n        var classes = ep.classes.join(\" \");\n        ep.instance.addClass(canvas, classes);\n        var scopes = ep.endpoint.scope.split(/\\s/);\n\n        for (var i = 0; i < scopes.length; i++) {\n          ep.instance.setAttribute(canvas, _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.ATTRIBUTE_SCOPE_PREFIX + scopes[i], _jsplumb_common__WEBPACK_IMPORTED_MODULE_2__.TRUE);\n        }\n\n        if (!ep.instance._suspendDrawing) {\n          _size(canvas, 0, 0, 1, 1);\n        }\n\n        ep.instance._appendElement(canvas, ep.instance.getContainer());\n\n        canvas.appendChild(svg);\n\n        if (ep.cssClass != null) {\n          ep.instance.addClass(canvas, ep.cssClass);\n        }\n\n        ep.instance.addClass(canvas, ep.instance.endpointClass);\n        canvas.jtk = canvas.jtk || {};\n        canvas.jtk.endpoint = ep.endpoint;\n        canvas.style.display = ep.endpoint.visible !== false ? _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.BLOCK : _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.NONE;\n        return canvas;\n      }\n    }\n  }, {\n    key: \"paint\",\n    value: function paint(ep, handlers, paintStyle) {\n      if (ep.endpoint.deleted !== true) {\n        this.getEndpointElement(ep);\n        SvgComponent.paint(ep, true, paintStyle);\n        var s = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.extend)({}, paintStyle);\n\n        if (s.outlineStroke) {\n          s.stroke = s.outlineStroke;\n        }\n\n        if (ep.node == null) {\n          ep.node = handlers.makeNode(ep, s);\n          ep.svg.appendChild(ep.node);\n        } else if (handlers.updateNode != null) {\n          handlers.updateNode(ep, ep.node);\n        }\n\n        _applyStyles(ep.canvas, ep.node, s);\n      }\n    }\n  }]);\n\n  return SvgEndpoint;\n}();\n\nvar endpointMap = {};\n\nfunction registerEndpointRenderer(name, fns) {\n  endpointMap[name] = fns;\n}\n\nfunction getPositionOnElement(evt, el, zoom) {\n  var jel = el;\n  var box = _typeof(el.getBoundingClientRect) !== _jsplumb_common__WEBPACK_IMPORTED_MODULE_2__.UNDEFINED ? el.getBoundingClientRect() : {\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0\n  },\n      body = document.body,\n      docElem = document.documentElement,\n      scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,\n      scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,\n      clientTop = docElem.clientTop || body.clientTop || 0,\n      clientLeft = docElem.clientLeft || body.clientLeft || 0,\n      pst = 0,\n      psl = 0,\n      top = box.top + scrollTop - clientTop + pst * zoom,\n      left = box.left + scrollLeft - clientLeft + psl * zoom,\n      cl = pageLocation(evt),\n      w = box.width || jel.offsetWidth * zoom,\n      h = box.height || jel.offsetHeight * zoom,\n      x = (cl.x - left) / w,\n      y = (cl.y - top) / h;\n  return {\n    x: x,\n    y: y\n  };\n}\n\nfunction isSVGElementOverlay(o) {\n  return (0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isArrowOverlay)(o) || (0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isDiamondOverlay)(o) || (0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isPlainArrowOverlay)(o);\n}\n\nfunction setVisible(component, v) {\n  if (component.canvas) {\n    component.canvas.style.display = v ? \"block\" : \"none\";\n  }\n}\n\nfunction cleanup(component) {\n  if (component.canvas) {\n    component.canvas.parentNode.removeChild(component.canvas);\n  }\n\n  delete component.canvas;\n  delete component.svg;\n}\n\nfunction getEndpointCanvas(ep) {\n  return ep.canvas;\n}\n\nfunction getLabelElement(o) {\n  return HTMLElementOverlay.getElement(o);\n}\n\nfunction getCustomElement(o) {\n  return HTMLElementOverlay.getElement(o, o.component, function (c) {\n    var el = o.create(c);\n    o.instance.addClass(el, o.instance.overlayClass);\n    return el;\n  });\n}\n\nfunction groupDragConstrain(desiredLoc, dragEl, constrainRect, size) {\n  var x = desiredLoc.x,\n      y = desiredLoc.y;\n\n  if (dragEl._jsPlumbParentGroup && dragEl._jsPlumbParentGroup.constrain) {\n    x = Math.max(desiredLoc.x, 0);\n    y = Math.max(desiredLoc.y, 0);\n    x = Math.min(x, constrainRect.w - size.w);\n    y = Math.min(y, constrainRect.h - size.h);\n  }\n\n  return {\n    x: x,\n    y: y\n  };\n}\n\nvar BrowserJsPlumbInstance = function (_JsPlumbInstance) {\n  _inherits(BrowserJsPlumbInstance, _JsPlumbInstance);\n\n  var _super = _createSuper(BrowserJsPlumbInstance);\n\n  function BrowserJsPlumbInstance(_instanceIndex, defaults) {\n    var _this;\n\n    _classCallCheck(this, BrowserJsPlumbInstance);\n\n    _this = _super.call(this, _instanceIndex, defaults);\n    _this._instanceIndex = _instanceIndex;\n\n    _defineProperty(_assertThisInitialized(_this), \"dragSelection\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"dragManager\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_connectorClick\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_connectorDblClick\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_connectorTap\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_connectorDblTap\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_endpointClick\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_endpointDblClick\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_overlayClick\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_overlayDblClick\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_overlayTap\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_overlayDblTap\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_connectorMouseover\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_connectorMouseout\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_endpointMouseover\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_endpointMouseout\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_connectorContextmenu\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_connectorMousedown\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_connectorMouseup\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_endpointMousedown\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_endpointMouseup\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_overlayMouseover\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_overlayMouseout\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_elementClick\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_elementTap\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_elementDblTap\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_elementMouseenter\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_elementMouseexit\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_elementMousemove\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_elementMouseup\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_elementMousedown\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_elementContextmenu\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"eventManager\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"draggingClass\", \"jtk-dragging\");\n\n    _defineProperty(_assertThisInitialized(_this), \"elementDraggingClass\", \"jtk-element-dragging\");\n\n    _defineProperty(_assertThisInitialized(_this), \"hoverClass\", \"jtk-hover\");\n\n    _defineProperty(_assertThisInitialized(_this), \"sourceElementDraggingClass\", \"jtk-source-element-dragging\");\n\n    _defineProperty(_assertThisInitialized(_this), \"targetElementDraggingClass\", \"jtk-target-element-dragging\");\n\n    _defineProperty(_assertThisInitialized(_this), \"hoverSourceClass\", \"jtk-source-hover\");\n\n    _defineProperty(_assertThisInitialized(_this), \"hoverTargetClass\", \"jtk-target-hover\");\n\n    _defineProperty(_assertThisInitialized(_this), \"dragSelectClass\", \"jtk-drag-select\");\n\n    _defineProperty(_assertThisInitialized(_this), \"managedElementsSelector\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"elementsDraggable\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"elementDragHandler\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"groupDragOptions\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"elementDragOptions\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"svg\", {\n      node: function node(name, attributes) {\n        return _node(name, attributes);\n      },\n      attr: function attr(node, attributes) {\n        return _attr(node, attributes);\n      },\n      pos: function pos(d) {\n        return _pos(d);\n      }\n    });\n\n    _this.elementsDraggable = defaults && defaults.elementsDraggable !== false;\n    _this.managedElementsSelector = defaults ? defaults.managedElementsSelector || _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.SELECTOR_MANAGED_ELEMENT : _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.SELECTOR_MANAGED_ELEMENT;\n    _this.eventManager = new EventManager();\n    _this.dragSelection = new DragSelection(_assertThisInitialized(_this));\n    _this.dragManager = new DragManager(_assertThisInitialized(_this), _this.dragSelection);\n\n    _this.dragManager.addHandler(new EndpointDragHandler(_assertThisInitialized(_this)));\n\n    _this.groupDragOptions = {\n      constrainFunction: groupDragConstrain\n    };\n\n    _this.dragManager.addHandler(new GroupDragHandler(_assertThisInitialized(_this), _this.dragSelection), _this.groupDragOptions);\n\n    _this.elementDragHandler = new ElementDragHandler(_assertThisInitialized(_this), _this.dragSelection);\n    _this.elementDragOptions = defaults && defaults.dragOptions || {};\n\n    _this.dragManager.addHandler(_this.elementDragHandler, _this.elementDragOptions);\n\n    if (defaults && defaults.dragOptions && defaults.dragOptions.filter) {\n      _this.dragManager.addFilter(defaults.dragOptions.filter);\n    }\n\n    var _connClick = function _connClick(event, e) {\n      if (!e.defaultPrevented && e._jsPlumbOverlay == null) {\n        var connectorElement = findParent(getEventSource(e), SELECTOR_CONNECTOR, this.getContainer(), true);\n        this.fire(event, connectorElement.jtk.connector.connection, e);\n      }\n    };\n\n    _this._connectorClick = _connClick.bind(_assertThisInitialized(_this), EVENT_CONNECTION_CLICK);\n    _this._connectorDblClick = _connClick.bind(_assertThisInitialized(_this), EVENT_CONNECTION_DBL_CLICK);\n    _this._connectorTap = _connClick.bind(_assertThisInitialized(_this), EVENT_CONNECTION_TAP);\n    _this._connectorDblTap = _connClick.bind(_assertThisInitialized(_this), EVENT_CONNECTION_DBL_TAP);\n\n    var _connectorHover = function _connectorHover(state, e) {\n      var el = getEventSource(e).parentNode;\n\n      if (el.jtk && el.jtk.connector) {\n        var connector = el.jtk.connector;\n        var connection = connector.connection;\n        this.setConnectorHover(connector, state);\n\n        if (state) {\n          this.addClass(connection.source, this.hoverSourceClass);\n          this.addClass(connection.target, this.hoverTargetClass);\n        } else {\n          this.removeClass(connection.source, this.hoverSourceClass);\n          this.removeClass(connection.target, this.hoverTargetClass);\n        }\n\n        this.fire(state ? EVENT_CONNECTION_MOUSEOVER : EVENT_CONNECTION_MOUSEOUT, el.jtk.connector.connection, e);\n      }\n    };\n\n    _this._connectorMouseover = _connectorHover.bind(_assertThisInitialized(_this), true);\n    _this._connectorMouseout = _connectorHover.bind(_assertThisInitialized(_this), false);\n\n    var _connectorMouseupdown = function _connectorMouseupdown(state, e) {\n      var el = getEventSource(e).parentNode;\n\n      if (el.jtk && el.jtk.connector) {\n        this.fire(state ? EVENT_CONNECTION_MOUSEUP : EVENT_CONNECTION_MOUSEDOWN, el.jtk.connector.connection, e);\n      }\n    };\n\n    _this._connectorMouseup = _connectorMouseupdown.bind(_assertThisInitialized(_this), true);\n    _this._connectorMousedown = _connectorMouseupdown.bind(_assertThisInitialized(_this), false);\n\n    _this._connectorContextmenu = function (e) {\n      var el = getEventSource(e).parentNode;\n\n      if (el.jtk && el.jtk.connector) {\n        this.fire(EVENT_CONNECTION_CONTEXTMENU, el.jtk.connector.connection, e);\n      }\n    }.bind(_assertThisInitialized(_this));\n\n    var _epClick = function _epClick(event, e, endpointElement) {\n      if (!e.defaultPrevented && e._jsPlumbOverlay == null) {\n        this.fire(event, endpointElement.jtk.endpoint, e);\n      }\n    };\n\n    _this._endpointClick = _epClick.bind(_assertThisInitialized(_this), EVENT_ENDPOINT_CLICK);\n    _this._endpointDblClick = _epClick.bind(_assertThisInitialized(_this), EVENT_ENDPOINT_DBL_CLICK);\n\n    var _endpointHover = function _endpointHover(state, e) {\n      var el = getEventSource(e);\n\n      if (el.jtk && el.jtk.endpoint) {\n        this.setEndpointHover(el.jtk.endpoint, state);\n        this.fire(state ? EVENT_ENDPOINT_MOUSEOVER : EVENT_ENDPOINT_MOUSEOUT, el.jtk.endpoint, e);\n      }\n    };\n\n    _this._endpointMouseover = _endpointHover.bind(_assertThisInitialized(_this), true);\n    _this._endpointMouseout = _endpointHover.bind(_assertThisInitialized(_this), false);\n\n    var _endpointMouseupdown = function _endpointMouseupdown(state, e) {\n      var el = getEventSource(e);\n\n      if (el.jtk && el.jtk.endpoint) {\n        this.fire(state ? EVENT_ENDPOINT_MOUSEUP : EVENT_ENDPOINT_MOUSEDOWN, el.jtk.endpoint, e);\n      }\n    };\n\n    _this._endpointMouseup = _endpointMouseupdown.bind(_assertThisInitialized(_this), true);\n    _this._endpointMousedown = _endpointMouseupdown.bind(_assertThisInitialized(_this), false);\n\n    var _oClick = function (method, e) {\n      var overlayElement = findParent(getEventSource(e), SELECTOR_OVERLAY, this.getContainer(), true);\n      var overlay = overlayElement.jtk.overlay;\n\n      if (overlay) {\n        this.fireOverlayMethod(overlay, method, e);\n      }\n    }.bind(_assertThisInitialized(_this));\n\n    _this._overlayClick = _oClick.bind(_assertThisInitialized(_this), EVENT_CLICK);\n    _this._overlayDblClick = _oClick.bind(_assertThisInitialized(_this), EVENT_DBL_CLICK);\n    _this._overlayTap = _oClick.bind(_assertThisInitialized(_this), EVENT_TAP);\n    _this._overlayDblTap = _oClick.bind(_assertThisInitialized(_this), EVENT_DBL_TAP);\n\n    var _overlayHover = function _overlayHover(state, e) {\n      var overlayElement = findParent(getEventSource(e), SELECTOR_OVERLAY, this.getContainer(), true);\n      var overlay = overlayElement.jtk.overlay;\n\n      if (overlay) {\n        this.setOverlayHover(overlay, state);\n      }\n    };\n\n    _this._overlayMouseover = _overlayHover.bind(_assertThisInitialized(_this), true);\n    _this._overlayMouseout = _overlayHover.bind(_assertThisInitialized(_this), false);\n\n    var _elementClick = function _elementClick(event, e, target) {\n      if (!e.defaultPrevented) {\n        this.fire(e.detail === 1 ? EVENT_ELEMENT_CLICK : EVENT_ELEMENT_DBL_CLICK, target, e);\n      }\n    };\n\n    _this._elementClick = _elementClick.bind(_assertThisInitialized(_this), EVENT_ELEMENT_CLICK);\n\n    var _elementTap = function _elementTap(event, e, target) {\n      if (!e.defaultPrevented) {\n        this.fire(EVENT_ELEMENT_TAP, target, e);\n      }\n    };\n\n    _this._elementTap = _elementTap.bind(_assertThisInitialized(_this), EVENT_ELEMENT_TAP);\n\n    var _elementDblTap = function _elementDblTap(event, e, target) {\n      if (!e.defaultPrevented) {\n        this.fire(EVENT_ELEMENT_DBL_TAP, target, e);\n      }\n    };\n\n    _this._elementDblTap = _elementDblTap.bind(_assertThisInitialized(_this), EVENT_ELEMENT_DBL_TAP);\n\n    var _elementHover = function _elementHover(state, e) {\n      this.fire(state ? EVENT_ELEMENT_MOUSE_OVER : EVENT_ELEMENT_MOUSE_OUT, getEventSource(e), e);\n    };\n\n    _this._elementMouseenter = _elementHover.bind(_assertThisInitialized(_this), true);\n    _this._elementMouseexit = _elementHover.bind(_assertThisInitialized(_this), false);\n\n    _this._elementMousemove = function (e) {\n      this.fire(EVENT_ELEMENT_MOUSE_MOVE, getEventSource(e), e);\n    }.bind(_assertThisInitialized(_this));\n\n    _this._elementMouseup = function (e) {\n      this.fire(EVENT_ELEMENT_MOUSE_UP, getEventSource(e), e);\n    }.bind(_assertThisInitialized(_this));\n\n    _this._elementMousedown = function (e) {\n      this.fire(EVENT_ELEMENT_MOUSE_DOWN, getEventSource(e), e);\n    }.bind(_assertThisInitialized(_this));\n\n    _this._elementContextmenu = function (e) {\n      this.fire(EVENT_ELEMENT_CONTEXTMENU, getEventSource(e), e);\n    }.bind(_assertThisInitialized(_this));\n\n    _this._attachEventDelegates();\n\n    return _this;\n  }\n\n  _createClass(BrowserJsPlumbInstance, [{\n    key: \"fireOverlayMethod\",\n    value: function fireOverlayMethod(overlay, event, e) {\n      var stem = overlay.component instanceof _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.Connection ? CONNECTION : ENDPOINT;\n      var mappedEvent = compoundEvent(stem, event);\n      e._jsPlumbOverlay = overlay;\n      overlay.fire(event, {\n        e: e,\n        overlay: overlay\n      });\n      this.fire(mappedEvent, overlay.component, e);\n    }\n  }, {\n    key: \"addDragFilter\",\n    value: function addDragFilter(filter, exclude) {\n      this.dragManager.addFilter(filter, exclude);\n    }\n  }, {\n    key: \"removeDragFilter\",\n    value: function removeDragFilter(filter) {\n      this.dragManager.removeFilter(filter);\n    }\n  }, {\n    key: \"setDragGrid\",\n    value: function setDragGrid(grid) {\n      this.dragManager.setOption(this.elementDragHandler, {\n        grid: grid\n      });\n    }\n  }, {\n    key: \"_removeElement\",\n    value: function _removeElement(element) {\n      element.parentNode && element.parentNode.removeChild(element);\n    }\n  }, {\n    key: \"_appendElement\",\n    value: function _appendElement(el, parent) {\n      if (parent) {\n        parent.appendChild(el);\n      }\n    }\n  }, {\n    key: \"_getAssociatedElements\",\n    value: function _getAssociatedElements(el) {\n      var a = [];\n\n      if (el.nodeType !== 3 && el.nodeType !== 8) {\n        var els = el.querySelectorAll(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.SELECTOR_MANAGED_ELEMENT);\n        Array.prototype.push.apply(a, els);\n      }\n\n      return a.filter(function (_a) {\n        return _a.nodeType !== 3 && _a.nodeType !== 8;\n      });\n    }\n  }, {\n    key: \"shouldFireEvent\",\n    value: function shouldFireEvent(event, value, originalEvent) {\n      return true;\n    }\n  }, {\n    key: \"getClass\",\n    value: function getClass$1(el) {\n      return getClass(el);\n    }\n  }, {\n    key: \"addClass\",\n    value: function addClass$1(el, clazz) {\n      addClass(el, clazz);\n    }\n  }, {\n    key: \"hasClass\",\n    value: function hasClass$1(el, clazz) {\n      return hasClass(el, clazz);\n    }\n  }, {\n    key: \"removeClass\",\n    value: function removeClass$1(el, clazz) {\n      removeClass(el, clazz);\n    }\n  }, {\n    key: \"toggleClass\",\n    value: function toggleClass$1(el, clazz) {\n      toggleClass(el, clazz);\n    }\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(el, name, value) {\n      el.setAttribute(name, value);\n    }\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(el, name) {\n      return el.getAttribute(name);\n    }\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes(el, atts) {\n      for (var i in atts) {\n        el.setAttribute(i, atts[i]);\n      }\n    }\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(el, attName) {\n      el.removeAttribute && el.removeAttribute(attName);\n    }\n  }, {\n    key: \"on\",\n    value: function on(el, event, callbackOrSelector, callback) {\n      var _this2 = this;\n\n      var _one = function _one(_el) {\n        if (callback == null) {\n          _this2.eventManager.on(_el, event, callbackOrSelector);\n        } else {\n          _this2.eventManager.on(_el, event, callbackOrSelector, callback);\n        }\n      };\n\n      if (isNodeList(el)) {\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(el, function (el) {\n          return _one(el);\n        });\n      } else {\n        _one(el);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"off\",\n    value: function off(el, event, callback) {\n      var _this3 = this;\n\n      if (isNodeList(el)) {\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(el, function (_el) {\n          return _this3.eventManager.off(_el, event, callback);\n        });\n      } else {\n        this.eventManager.off(el, event, callback);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(el, event, originalEvent, payload, detail) {\n      this.eventManager.trigger(el, event, originalEvent, payload, detail);\n    }\n  }, {\n    key: \"getOffsetRelativeToRoot\",\n    value: function getOffsetRelativeToRoot(el) {\n      return offsetRelativeToRoot(el);\n    }\n  }, {\n    key: \"getOffset\",\n    value: function getOffset(el) {\n      var jel = el;\n      var container = this.getContainer();\n\n      var out = {\n        x: jel.offsetLeft,\n        y: jel.offsetTop\n      },\n          op = el !== container && jel.offsetParent !== container ? jel.offsetParent : null,\n          _maybeAdjustScroll = function _maybeAdjustScroll(offsetParent) {\n        if (offsetParent != null && offsetParent !== document.body && (offsetParent.scrollTop > 0 || offsetParent.scrollLeft > 0)) {\n          out.x -= offsetParent.scrollLeft;\n          out.y -= offsetParent.scrollTop;\n        }\n      };\n\n      while (op != null) {\n        out.x += op.offsetLeft;\n        out.y += op.offsetTop;\n\n        _maybeAdjustScroll(op);\n\n        op = op.offsetParent === container ? null : op.offsetParent;\n      }\n\n      if (container != null && (container.scrollTop > 0 || container.scrollLeft > 0)) {\n        var pp = jel.offsetParent != null ? this.getStyle(jel.offsetParent, PROPERTY_POSITION) : _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.STATIC,\n            p = this.getStyle(jel, PROPERTY_POSITION);\n\n        if (p !== _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.ABSOLUTE && p !== _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.FIXED && pp !== _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.ABSOLUTE && pp !== _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.FIXED) {\n          out.x -= container.scrollLeft;\n          out.y -= container.scrollTop;\n        }\n      }\n\n      return out;\n    }\n  }, {\n    key: \"getSize\",\n    value: function getSize(el) {\n      return size(el);\n    }\n  }, {\n    key: \"getStyle\",\n    value: function getStyle(el, prop) {\n      if (_typeof(window.getComputedStyle) !== _jsplumb_common__WEBPACK_IMPORTED_MODULE_2__.UNDEFINED) {\n        return getComputedStyle(el, null).getPropertyValue(prop);\n      } else {\n        return el.currentStyle[prop];\n      }\n    }\n  }, {\n    key: \"getGroupContentArea\",\n    value: function getGroupContentArea(group) {\n      var da = this.getSelector(group.el, SELECTOR_GROUP_CONTAINER);\n      return da && da.length > 0 ? da[0] : group.el;\n    }\n  }, {\n    key: \"getSelector\",\n    value: function getSelector(ctx, spec) {\n      var sel = null;\n\n      if (arguments.length === 1) {\n        if (!(0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.isString)(ctx)) {\n          var nodeList = document.createDocumentFragment();\n          nodeList.appendChild(ctx);\n          return (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.fromArray)(nodeList.childNodes);\n        }\n\n        sel = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.fromArray)(document.querySelectorAll(ctx));\n      } else {\n        sel = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.fromArray)(ctx.querySelectorAll(spec));\n      }\n\n      return sel;\n    }\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(el, p) {\n      var jel = el;\n      jel.style.left = p.x + \"px\";\n      jel.style.top = p.y + \"px\";\n    }\n  }, {\n    key: \"setDraggable\",\n    value: function setDraggable(element, draggable) {\n      if (draggable) {\n        this.removeAttribute(element, _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.ATTRIBUTE_NOT_DRAGGABLE);\n      } else {\n        this.setAttribute(element, _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.ATTRIBUTE_NOT_DRAGGABLE, _jsplumb_common__WEBPACK_IMPORTED_MODULE_2__.TRUE);\n      }\n    }\n  }, {\n    key: \"isDraggable\",\n    value: function isDraggable(el) {\n      var d = this.getAttribute(el, _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.ATTRIBUTE_NOT_DRAGGABLE);\n      return d == null || d === _jsplumb_common__WEBPACK_IMPORTED_MODULE_2__.FALSE;\n    }\n  }, {\n    key: \"toggleDraggable\",\n    value: function toggleDraggable(el) {\n      var state = this.isDraggable(el);\n      this.setDraggable(el, !state);\n      return !state;\n    }\n  }, {\n    key: \"_attachEventDelegates\",\n    value: function _attachEventDelegates() {\n      var currentContainer = this.getContainer();\n      this.eventManager.on(currentContainer, EVENT_CLICK, SELECTOR_OVERLAY, this._overlayClick);\n      this.eventManager.on(currentContainer, EVENT_DBL_CLICK, SELECTOR_OVERLAY, this._overlayDblClick);\n      this.eventManager.on(currentContainer, EVENT_TAP, SELECTOR_OVERLAY, this._overlayTap);\n      this.eventManager.on(currentContainer, EVENT_DBL_TAP, SELECTOR_OVERLAY, this._overlayDblTap);\n      this.eventManager.on(currentContainer, EVENT_CLICK, SELECTOR_CONNECTOR, this._connectorClick);\n      this.eventManager.on(currentContainer, EVENT_DBL_CLICK, SELECTOR_CONNECTOR, this._connectorDblClick);\n      this.eventManager.on(currentContainer, EVENT_TAP, SELECTOR_CONNECTOR, this._connectorTap);\n      this.eventManager.on(currentContainer, EVENT_DBL_TAP, SELECTOR_CONNECTOR, this._connectorDblTap);\n      this.eventManager.on(currentContainer, EVENT_CLICK, SELECTOR_ENDPOINT, this._endpointClick);\n      this.eventManager.on(currentContainer, EVENT_DBL_CLICK, SELECTOR_ENDPOINT, this._endpointDblClick);\n      this.eventManager.on(currentContainer, EVENT_CLICK, this.managedElementsSelector, this._elementClick);\n      this.eventManager.on(currentContainer, EVENT_TAP, this.managedElementsSelector, this._elementTap);\n      this.eventManager.on(currentContainer, EVENT_DBL_TAP, this.managedElementsSelector, this._elementDblTap);\n      this.eventManager.on(currentContainer, EVENT_MOUSEOVER, SELECTOR_CONNECTOR, this._connectorMouseover);\n      this.eventManager.on(currentContainer, EVENT_MOUSEOUT, SELECTOR_CONNECTOR, this._connectorMouseout);\n      this.eventManager.on(currentContainer, EVENT_CONTEXTMENU, SELECTOR_CONNECTOR, this._connectorContextmenu);\n      this.eventManager.on(currentContainer, EVENT_MOUSEUP, SELECTOR_CONNECTOR, this._connectorMouseup);\n      this.eventManager.on(currentContainer, EVENT_MOUSEDOWN, SELECTOR_CONNECTOR, this._connectorMousedown);\n      this.eventManager.on(currentContainer, EVENT_MOUSEOVER, SELECTOR_ENDPOINT, this._endpointMouseover);\n      this.eventManager.on(currentContainer, EVENT_MOUSEOUT, SELECTOR_ENDPOINT, this._endpointMouseout);\n      this.eventManager.on(currentContainer, EVENT_MOUSEUP, SELECTOR_ENDPOINT, this._endpointMouseup);\n      this.eventManager.on(currentContainer, EVENT_MOUSEDOWN, SELECTOR_ENDPOINT, this._endpointMousedown);\n      this.eventManager.on(currentContainer, EVENT_MOUSEOVER, SELECTOR_OVERLAY, this._overlayMouseover);\n      this.eventManager.on(currentContainer, EVENT_MOUSEOUT, SELECTOR_OVERLAY, this._overlayMouseout);\n      this.eventManager.on(currentContainer, EVENT_MOUSEOVER, _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.SELECTOR_MANAGED_ELEMENT, this._elementMouseenter);\n      this.eventManager.on(currentContainer, EVENT_MOUSEOUT, _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.SELECTOR_MANAGED_ELEMENT, this._elementMouseexit);\n      this.eventManager.on(currentContainer, EVENT_MOUSEMOVE, _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.SELECTOR_MANAGED_ELEMENT, this._elementMousemove);\n      this.eventManager.on(currentContainer, EVENT_MOUSEUP, _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.SELECTOR_MANAGED_ELEMENT, this._elementMouseup);\n      this.eventManager.on(currentContainer, EVENT_MOUSEDOWN, _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.SELECTOR_MANAGED_ELEMENT, this._elementMousedown);\n      this.eventManager.on(currentContainer, EVENT_CONTEXTMENU, _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.SELECTOR_MANAGED_ELEMENT, this._elementContextmenu);\n    }\n  }, {\n    key: \"_detachEventDelegates\",\n    value: function _detachEventDelegates() {\n      var currentContainer = this.getContainer();\n\n      if (currentContainer) {\n        this.eventManager.off(currentContainer, EVENT_CLICK, this._connectorClick);\n        this.eventManager.off(currentContainer, EVENT_DBL_CLICK, this._connectorDblClick);\n        this.eventManager.off(currentContainer, EVENT_TAP, this._connectorTap);\n        this.eventManager.off(currentContainer, EVENT_DBL_TAP, this._connectorDblTap);\n        this.eventManager.off(currentContainer, EVENT_CLICK, this._endpointClick);\n        this.eventManager.off(currentContainer, EVENT_DBL_CLICK, this._endpointDblClick);\n        this.eventManager.off(currentContainer, EVENT_CLICK, this._overlayClick);\n        this.eventManager.off(currentContainer, EVENT_DBL_CLICK, this._overlayDblClick);\n        this.eventManager.off(currentContainer, EVENT_TAP, this._overlayTap);\n        this.eventManager.off(currentContainer, EVENT_DBL_TAP, this._overlayDblTap);\n        this.eventManager.off(currentContainer, EVENT_CLICK, this._elementClick);\n        this.eventManager.off(currentContainer, EVENT_TAP, this._elementTap);\n        this.eventManager.off(currentContainer, EVENT_DBL_TAP, this._elementDblTap);\n        this.eventManager.off(currentContainer, EVENT_MOUSEOVER, this._connectorMouseover);\n        this.eventManager.off(currentContainer, EVENT_MOUSEOUT, this._connectorMouseout);\n        this.eventManager.off(currentContainer, EVENT_CONTEXTMENU, this._connectorContextmenu);\n        this.eventManager.off(currentContainer, EVENT_MOUSEUP, this._connectorMouseup);\n        this.eventManager.off(currentContainer, EVENT_MOUSEDOWN, this._connectorMousedown);\n        this.eventManager.off(currentContainer, EVENT_MOUSEOVER, this._endpointMouseover);\n        this.eventManager.off(currentContainer, EVENT_MOUSEOUT, this._endpointMouseout);\n        this.eventManager.off(currentContainer, EVENT_MOUSEUP, this._endpointMouseup);\n        this.eventManager.off(currentContainer, EVENT_MOUSEDOWN, this._endpointMousedown);\n        this.eventManager.off(currentContainer, EVENT_MOUSEOVER, this._overlayMouseover);\n        this.eventManager.off(currentContainer, EVENT_MOUSEOUT, this._overlayMouseout);\n        this.eventManager.off(currentContainer, EVENT_MOUSEENTER, this._elementMouseenter);\n        this.eventManager.off(currentContainer, EVENT_MOUSEEXIT, this._elementMouseexit);\n        this.eventManager.off(currentContainer, EVENT_MOUSEMOVE, this._elementMousemove);\n        this.eventManager.off(currentContainer, EVENT_MOUSEUP, this._elementMouseup);\n        this.eventManager.off(currentContainer, EVENT_MOUSEDOWN, this._elementMousedown);\n        this.eventManager.off(currentContainer, EVENT_CONTEXTMENU, this._elementContextmenu);\n      }\n    }\n  }, {\n    key: \"setContainer\",\n    value: function setContainer(newContainer) {\n      var _this4 = this;\n\n      if (newContainer === document || newContainer === document.body) {\n        throw new Error(\"Cannot set document or document.body as container element\");\n      }\n\n      this._detachEventDelegates();\n\n      var dragFilters;\n\n      if (this.dragManager != null) {\n        dragFilters = this.dragManager.reset();\n      }\n\n      this.setAttribute(newContainer, ATTRIBUTE_CONTAINER, (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.uuid)().replace(\"-\", \"\"));\n      var currentContainer = this.getContainer();\n\n      if (currentContainer != null) {\n        currentContainer.removeAttribute(ATTRIBUTE_CONTAINER);\n        var children = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.fromArray)(currentContainer.childNodes).filter(function (cn) {\n          return cn != null && (_this4.hasClass(cn, _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.CLASS_CONNECTOR) || _this4.hasClass(cn, _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.CLASS_ENDPOINT) || _this4.hasClass(cn, _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.CLASS_OVERLAY) || cn.getAttribute && cn.getAttribute(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.ATTRIBUTE_MANAGED) != null);\n        });\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(children, function (el) {\n          newContainer.appendChild(el);\n        });\n      }\n\n      _get(_getPrototypeOf(BrowserJsPlumbInstance.prototype), \"setContainer\", this).call(this, newContainer);\n\n      if (this.eventManager != null) {\n        this._attachEventDelegates();\n      }\n\n      if (this.dragManager != null) {\n        this.dragManager.addHandler(new EndpointDragHandler(this));\n        this.dragManager.addHandler(new GroupDragHandler(this, this.dragSelection), this.groupDragOptions);\n        this.elementDragHandler = new ElementDragHandler(this, this.dragSelection);\n        this.dragManager.addHandler(this.elementDragHandler, this.elementDragOptions);\n\n        if (dragFilters != null) {\n          this.dragManager.setFilters(dragFilters);\n        }\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      _get(_getPrototypeOf(BrowserJsPlumbInstance.prototype), \"reset\", this).call(this);\n\n      var container = this.getContainer();\n      var els = container.querySelectorAll([_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.SELECTOR_MANAGED_ELEMENT, SELECTOR_ENDPOINT, SELECTOR_CONNECTOR, SELECTOR_OVERLAY].join(\",\"));\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(els, function (el) {\n        return el.parentNode && el.parentNode.removeChild(el);\n      });\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._detachEventDelegates();\n\n      if (this.dragManager != null) {\n        this.dragManager.reset();\n      }\n\n      this.clearDragSelection();\n\n      _get(_getPrototypeOf(BrowserJsPlumbInstance.prototype), \"destroy\", this).call(this);\n    }\n  }, {\n    key: \"unmanage\",\n    value: function unmanage(el, removeElement) {\n      this.removeFromDragSelection(el);\n\n      _get(_getPrototypeOf(BrowserJsPlumbInstance.prototype), \"unmanage\", this).call(this, el, removeElement);\n    }\n  }, {\n    key: \"addToDragSelection\",\n    value: function addToDragSelection() {\n      var _this5 = this;\n\n      for (var _len = arguments.length, el = new Array(_len), _key = 0; _key < _len; _key++) {\n        el[_key] = arguments[_key];\n      }\n\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(el, function (_el) {\n        return _this5.dragSelection.add(_el);\n      });\n    }\n  }, {\n    key: \"clearDragSelection\",\n    value: function clearDragSelection() {\n      this.dragSelection.clear();\n    }\n  }, {\n    key: \"removeFromDragSelection\",\n    value: function removeFromDragSelection() {\n      var _this6 = this;\n\n      for (var _len2 = arguments.length, el = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        el[_key2] = arguments[_key2];\n      }\n\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(el, function (_el) {\n        return _this6.dragSelection.remove(_el);\n      });\n    }\n  }, {\n    key: \"toggleDragSelection\",\n    value: function toggleDragSelection() {\n      var _this7 = this;\n\n      for (var _len3 = arguments.length, el = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        el[_key3] = arguments[_key3];\n      }\n\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.forEach)(el, function (_el) {\n        return _this7.dragSelection.toggle(_el);\n      });\n    }\n  }, {\n    key: \"addToDragGroup\",\n    value: function addToDragGroup(spec) {\n      var _this$elementDragHand;\n\n      for (var _len4 = arguments.length, els = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        els[_key4 - 1] = arguments[_key4];\n      }\n\n      (_this$elementDragHand = this.elementDragHandler).addToDragGroup.apply(_this$elementDragHand, [spec].concat(els));\n    }\n  }, {\n    key: \"removeFromDragGroup\",\n    value: function removeFromDragGroup() {\n      var _this$elementDragHand2;\n\n      (_this$elementDragHand2 = this.elementDragHandler).removeFromDragGroup.apply(_this$elementDragHand2, arguments);\n    }\n  }, {\n    key: \"setDragGroupState\",\n    value: function setDragGroupState(state) {\n      var _this$elementDragHand3;\n\n      for (var _len5 = arguments.length, els = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        els[_key5 - 1] = arguments[_key5];\n      }\n\n      (_this$elementDragHand3 = this.elementDragHandler).setDragGroupState.apply(_this$elementDragHand3, [state].concat(els));\n    }\n  }, {\n    key: \"consume\",\n    value: function consume$1(e, doNotPreventDefault) {\n      consume(e, doNotPreventDefault);\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(element, rotation, doNotRepaint) {\n      var elementId = this.getId(element);\n\n      if (this._managedElements[elementId]) {\n        this._managedElements[elementId].el.style.transform = \"rotate(\" + rotation + \"deg)\";\n        this._managedElements[elementId].el.style.transformOrigin = \"center center\";\n        return _get(_getPrototypeOf(BrowserJsPlumbInstance.prototype), \"rotate\", this).call(this, element, rotation, doNotRepaint);\n      }\n\n      return {\n        c: new Set(),\n        e: new Set()\n      };\n    }\n  }, {\n    key: \"addOverlayClass\",\n    value: function addOverlayClass(o, clazz) {\n      if ((0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isLabelOverlay)(o)) {\n        o.instance.addClass(getLabelElement(o), clazz);\n      } else if (isSVGElementOverlay(o)) {\n        o.instance.addClass(SVGElementOverlay.ensurePath(o), clazz);\n      } else if ((0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isCustomOverlay)(o)) {\n        o.instance.addClass(getCustomElement(o), clazz);\n      } else {\n        throw \"Could not add class to overlay of type [\" + o.type + \"]\";\n      }\n    }\n  }, {\n    key: \"removeOverlayClass\",\n    value: function removeOverlayClass(o, clazz) {\n      if ((0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isLabelOverlay)(o)) {\n        o.instance.removeClass(getLabelElement(o), clazz);\n      } else if (isSVGElementOverlay(o)) {\n        o.instance.removeClass(SVGElementOverlay.ensurePath(o), clazz);\n      } else if ((0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isCustomOverlay)(o)) {\n        o.instance.removeClass(getCustomElement(o), clazz);\n      } else {\n        throw \"Could not remove class from overlay of type [\" + o.type + \"]\";\n      }\n    }\n  }, {\n    key: \"_paintOverlay\",\n    value: function _paintOverlay(o, params, extents) {\n      if ((0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isLabelOverlay)(o)) {\n        getLabelElement(o);\n        var XY = o.component.getXY();\n        o.canvas.style.left = XY.x + params.d.minx + \"px\";\n        o.canvas.style.top = XY.y + params.d.miny + \"px\";\n      } else if (isSVGElementOverlay(o)) {\n        var path = isNaN(params.d.cxy.x) || isNaN(params.d.cxy.y) ? \"M 0 0\" : \"M\" + params.d.hxy.x + \",\" + params.d.hxy.y + \" L\" + params.d.tail[0].x + \",\" + params.d.tail[0].y + \" L\" + params.d.cxy.x + \",\" + params.d.cxy.y + \" L\" + params.d.tail[1].x + \",\" + params.d.tail[1].y + \" L\" + params.d.hxy.x + \",\" + params.d.hxy.y;\n        SVGElementOverlay.paint(o, path, params, extents);\n      } else if ((0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isCustomOverlay)(o)) {\n        getCustomElement(o);\n\n        var _XY = o.component.getXY();\n\n        o.canvas.style.left = _XY.x + params.d.minx + \"px\";\n        o.canvas.style.top = _XY.y + params.d.miny + \"px\";\n      } else {\n        throw \"Could not paint overlay of type [\" + o.type + \"]\";\n      }\n    }\n  }, {\n    key: \"setOverlayVisible\",\n    value: function setOverlayVisible(o, visible) {\n      var d = visible ? \"block\" : \"none\";\n\n      function s(el) {\n        if (el != null) {\n          el.style.display = d;\n        }\n      }\n\n      if ((0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isLabelOverlay)(o)) {\n        s(getLabelElement(o));\n      } else if ((0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isCustomOverlay)(o)) {\n        s(getCustomElement(o));\n      } else if (isSVGElementOverlay(o)) {\n        s(o.path);\n      }\n    }\n  }, {\n    key: \"reattachOverlay\",\n    value: function reattachOverlay(o, c) {\n      if ((0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isLabelOverlay)(o)) {\n        o.instance._appendElement(getLabelElement(o), this.getContainer());\n      } else if ((0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isCustomOverlay)(o)) {\n        o.instance._appendElement(getCustomElement(o), this.getContainer());\n      } else if (isSVGElementOverlay(o)) {\n        this._appendElement(SVGElementOverlay.ensurePath(o), c.connector.canvas);\n      }\n    }\n  }, {\n    key: \"setOverlayHover\",\n    value: function setOverlayHover(o, hover) {\n      var canvas;\n\n      if ((0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isLabelOverlay)(o)) {\n        canvas = getLabelElement(o);\n      } else if ((0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isCustomOverlay)(o)) {\n        canvas = getCustomElement(o);\n      } else if (isSVGElementOverlay(o)) {\n        canvas = SVGElementOverlay.ensurePath(o);\n      }\n\n      if (canvas != null) {\n        if (this.hoverClass != null) {\n          if (hover) {\n            this.addClass(canvas, this.hoverClass);\n          } else {\n            this.removeClass(canvas, this.hoverClass);\n          }\n        }\n\n        this.setHover(o.component, hover);\n      }\n    }\n  }, {\n    key: \"destroyOverlay\",\n    value: function destroyOverlay(o) {\n      if ((0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isLabelOverlay)(o)) {\n        var el = getLabelElement(o);\n        el.parentNode.removeChild(el);\n        delete o.canvas;\n        delete o.cachedDimensions;\n      } else if ((0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isArrowOverlay)(o) || (0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isDiamondOverlay)(o) || (0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isPlainArrowOverlay)(o)) {\n        SVGElementOverlay.destroy(o);\n      } else if ((0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isCustomOverlay)(o)) {\n        var _el2 = getCustomElement(o);\n\n        _el2.parentNode.removeChild(_el2);\n\n        delete o.canvas;\n        delete o.cachedDimensions;\n      }\n    }\n  }, {\n    key: \"drawOverlay\",\n    value: function drawOverlay(o, component, paintStyle, absolutePosition) {\n      if ((0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isLabelOverlay)(o) || (0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isCustomOverlay)(o)) {\n        var td = HTMLElementOverlay._getDimensions(o);\n\n        if (td != null && td.w != null && td.h != null) {\n          var cxy = {\n            x: 0,\n            y: 0\n          };\n\n          if (absolutePosition) {\n            cxy = {\n              x: absolutePosition.x,\n              y: absolutePosition.y\n            };\n          } else if (component instanceof _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.EndpointRepresentation) {\n            var locToUse = Array.isArray(o.location) ? o.location : [o.location, o.location];\n            cxy = {\n              x: locToUse[0] * component.w,\n              y: locToUse[1] * component.h\n            };\n          } else {\n            var loc = o.location,\n                absolute = false;\n\n            if ((0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.isString)(o.location) || o.location < 0 || o.location > 1) {\n              loc = parseInt(\"\" + o.location, 10);\n              absolute = true;\n            }\n\n            cxy = component.pointOnPath(loc, absolute);\n          }\n\n          var minx = cxy.x - td.w / 2,\n              miny = cxy.y - td.h / 2;\n          return {\n            component: o,\n            d: {\n              minx: minx,\n              miny: miny,\n              td: td,\n              cxy: cxy\n            },\n            xmin: minx,\n            xmax: minx + td.w,\n            ymin: miny,\n            ymax: miny + td.h\n          };\n        } else {\n          return {\n            xmin: 0,\n            xmax: 0,\n            ymin: 0,\n            ymax: 0\n          };\n        }\n      } else if ((0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isArrowOverlay)(o) || (0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isDiamondOverlay)(o) || (0,_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.isPlainArrowOverlay)(o)) {\n        return o.draw(component, paintStyle, absolutePosition);\n      } else {\n        throw \"Could not draw overlay of type [\" + o.type + \"]\";\n      }\n    }\n  }, {\n    key: \"updateLabel\",\n    value: function updateLabel(o) {\n      if ((0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(o.label)) {\n        var lt = o.label(this);\n\n        if (lt != null) {\n          getLabelElement(o).innerText = lt;\n        } else {\n          getLabelElement(o).innerText = \"\";\n        }\n      } else {\n        if (o.labelText == null) {\n          o.labelText = o.label;\n\n          if (o.labelText != null) {\n            getLabelElement(o).innerText = o.labelText;\n          } else {\n            getLabelElement(o).innerText = \"\";\n          }\n        }\n      }\n    }\n  }, {\n    key: \"setHover\",\n    value: function setHover(component, hover) {\n      component._hover = hover;\n\n      if (component instanceof _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.Endpoint && component.endpoint != null) {\n        this.setEndpointHover(component, hover, -1);\n      } else if (component instanceof _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.Connection && component.connector != null) {\n        this.setConnectorHover(component.connector, hover);\n      }\n    }\n  }, {\n    key: \"paintConnector\",\n    value: function paintConnector(connector, paintStyle, extents) {\n      paintSvgConnector(this, connector, paintStyle, extents);\n    }\n  }, {\n    key: \"setConnectorHover\",\n    value: function setConnectorHover(connector, hover, sourceEndpoint) {\n      if (hover === false || !this.currentlyDragging && !this.isHoverSuspended()) {\n        var canvas = connector.canvas;\n\n        if (canvas != null) {\n          if (connector.hoverClass != null) {\n            if (hover) {\n              this.addClass(canvas, connector.hoverClass);\n            } else {\n              this.removeClass(canvas, connector.hoverClass);\n            }\n          }\n\n          if (hover) {\n            this.addClass(canvas, this.hoverClass);\n          } else {\n            this.removeClass(canvas, this.hoverClass);\n          }\n        }\n\n        if (connector.connection.hoverPaintStyle != null) {\n          connector.connection.paintStyleInUse = hover ? connector.connection.hoverPaintStyle : connector.connection.paintStyle;\n\n          if (!this._suspendDrawing) {\n            this._paintConnection(connector.connection);\n          }\n        }\n\n        if (connector.connection.endpoints[0] !== sourceEndpoint) {\n          this.setEndpointHover(connector.connection.endpoints[0], hover, 0, true);\n        }\n\n        if (connector.connection.endpoints[1] !== sourceEndpoint) {\n          this.setEndpointHover(connector.connection.endpoints[1], hover, 1, true);\n        }\n      }\n    }\n  }, {\n    key: \"destroyConnector\",\n    value: function destroyConnector(connection) {\n      if (connection.connector != null) {\n        cleanup(connection.connector);\n      }\n    }\n  }, {\n    key: \"addConnectorClass\",\n    value: function addConnectorClass(connector, clazz) {\n      if (connector.canvas) {\n        this.addClass(connector.canvas, clazz);\n      }\n    }\n  }, {\n    key: \"removeConnectorClass\",\n    value: function removeConnectorClass(connector, clazz) {\n      if (connector.canvas) {\n        this.removeClass(connector.canvas, clazz);\n      }\n    }\n  }, {\n    key: \"getConnectorClass\",\n    value: function getConnectorClass(connector) {\n      if (connector.canvas) {\n        return connector.canvas.className.baseVal;\n      } else {\n        return \"\";\n      }\n    }\n  }, {\n    key: \"setConnectorVisible\",\n    value: function setConnectorVisible(connector, v) {\n      setVisible(connector, v);\n    }\n  }, {\n    key: \"applyConnectorType\",\n    value: function applyConnectorType(connector, t) {\n      if (connector.canvas && t.cssClass) {\n        var classes = Array.isArray(t.cssClass) ? t.cssClass : [t.cssClass];\n        this.addClass(connector.canvas, classes.join(\" \"));\n      }\n    }\n  }, {\n    key: \"addEndpointClass\",\n    value: function addEndpointClass(ep, c) {\n      var canvas = getEndpointCanvas(ep.endpoint);\n\n      if (canvas != null) {\n        this.addClass(canvas, c);\n      }\n    }\n  }, {\n    key: \"applyEndpointType\",\n    value: function applyEndpointType(ep, t) {\n      if (t.cssClass) {\n        var canvas = getEndpointCanvas(ep.endpoint);\n\n        if (canvas) {\n          var classes = Array.isArray(t.cssClass) ? t.cssClass : [t.cssClass];\n          this.addClass(canvas, classes.join(\" \"));\n        }\n      }\n    }\n  }, {\n    key: \"destroyEndpoint\",\n    value: function destroyEndpoint(ep) {\n      var anchorClass = this.endpointAnchorClassPrefix + (ep.currentAnchorClass ? \"-\" + ep.currentAnchorClass : \"\");\n      this.removeClass(ep.element, anchorClass);\n      cleanup(ep.endpoint);\n    }\n  }, {\n    key: \"renderEndpoint\",\n    value: function renderEndpoint(ep, paintStyle) {\n      var renderer = endpointMap[ep.endpoint.type];\n\n      if (renderer != null) {\n        SvgEndpoint.paint(ep.endpoint, renderer, paintStyle);\n      } else {\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_1__.log)(\"jsPlumb: no endpoint renderer found for type [\" + ep.endpoint.type + \"]\");\n      }\n    }\n  }, {\n    key: \"removeEndpointClass\",\n    value: function removeEndpointClass(ep, c) {\n      var canvas = getEndpointCanvas(ep.endpoint);\n\n      if (canvas != null) {\n        this.removeClass(canvas, c);\n      }\n    }\n  }, {\n    key: \"getEndpointClass\",\n    value: function getEndpointClass(ep) {\n      var canvas = getEndpointCanvas(ep.endpoint);\n\n      if (canvas != null) {\n        return canvas.className;\n      } else {\n        return \"\";\n      }\n    }\n  }, {\n    key: \"setEndpointHover\",\n    value: function setEndpointHover(endpoint, hover, endpointIndex, doNotCascade) {\n      if (endpoint != null && (hover === false || !this.currentlyDragging && !this.isHoverSuspended())) {\n        var canvas = getEndpointCanvas(endpoint.endpoint);\n\n        if (canvas != null) {\n          if (endpoint.hoverClass != null) {\n            if (hover) {\n              this.addClass(canvas, endpoint.hoverClass);\n            } else {\n              this.removeClass(canvas, endpoint.hoverClass);\n            }\n          }\n\n          if (endpointIndex === 0 || endpointIndex === 1) {\n            var genericHoverClass = endpointIndex === 0 ? this.hoverSourceClass : this.hoverTargetClass;\n\n            if (hover) {\n              this.addClass(canvas, genericHoverClass);\n            } else {\n              this.removeClass(canvas, genericHoverClass);\n            }\n          }\n        }\n\n        if (endpoint.hoverPaintStyle != null) {\n          endpoint.paintStyleInUse = hover ? endpoint.hoverPaintStyle : endpoint.paintStyle;\n\n          if (!this._suspendDrawing) {\n            this.renderEndpoint(endpoint, endpoint.paintStyleInUse);\n          }\n        }\n\n        if (!doNotCascade) {\n          for (var i = 0; i < endpoint.connections.length; i++) {\n            this.setConnectorHover(endpoint.connections[i].connector, hover, endpoint);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"setEndpointVisible\",\n    value: function setEndpointVisible(ep, v) {\n      setVisible(ep.endpoint, v);\n    }\n  }, {\n    key: \"setGroupVisible\",\n    value: function setGroupVisible(group, state) {\n      var m = group.el.querySelectorAll(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.SELECTOR_MANAGED_ELEMENT);\n\n      for (var i = 0; i < m.length; i++) {\n        if (state) {\n          this.show(m[i], true);\n        } else {\n          this.hide(m[i], true);\n        }\n      }\n    }\n  }, {\n    key: \"deleteConnection\",\n    value: function deleteConnection(connection, params) {\n      if (connection != null && connection.deleted !== true) {\n        if (connection.endpoints[0].deleted !== true) {\n          this.setEndpointHover(connection.endpoints[0], false, 0, true);\n        }\n\n        if (connection.endpoints[1].deleted !== true) {\n          this.setEndpointHover(connection.endpoints[1], false, 1, true);\n        }\n\n        return _get(_getPrototypeOf(BrowserJsPlumbInstance.prototype), \"deleteConnection\", this).call(this, connection, params);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"addSourceSelector\",\n    value: function addSourceSelector(selector, params, exclude) {\n      this.addDragFilter(selector);\n      return _get(_getPrototypeOf(BrowserJsPlumbInstance.prototype), \"addSourceSelector\", this).call(this, selector, params, exclude);\n    }\n  }, {\n    key: \"removeSourceSelector\",\n    value: function removeSourceSelector(selector) {\n      this.removeDragFilter(selector.selector);\n\n      _get(_getPrototypeOf(BrowserJsPlumbInstance.prototype), \"removeSourceSelector\", this).call(this, selector);\n    }\n  }]);\n\n  return BrowserJsPlumbInstance;\n}(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.JsPlumbInstance);\n\nvar CIRCLE = \"circle\";\n\nvar register$2 = function register() {\n  registerEndpointRenderer(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.DotEndpoint.type, {\n    makeNode: function makeNode(ep, style) {\n      return _node(CIRCLE, {\n        \"cx\": ep.w / 2,\n        \"cy\": ep.h / 2,\n        \"r\": ep.radius\n      });\n    },\n    updateNode: function updateNode(ep, node) {\n      _attr(node, {\n        \"cx\": \"\" + ep.w / 2,\n        \"cy\": \"\" + ep.h / 2,\n        \"r\": \"\" + ep.radius\n      });\n    }\n  });\n};\n\nvar RECT = \"rect\";\n\nvar register$1 = function register() {\n  registerEndpointRenderer(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.RectangleEndpoint.type, {\n    makeNode: function makeNode(ep, style) {\n      return _node(RECT, {\n        \"width\": ep.w,\n        \"height\": ep.h\n      });\n    },\n    updateNode: function updateNode(ep, node) {\n      _attr(node, {\n        \"width\": ep.w,\n        \"height\": ep.h\n      });\n    }\n  });\n};\n\nvar BLANK_ATTRIBUTES = {\n  \"width\": 10,\n  \"height\": 0,\n  \"fill\": \"transparent\",\n  \"stroke\": \"transparent\"\n};\n\nvar register = function register() {\n  registerEndpointRenderer(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.BlankEndpoint.type, {\n    makeNode: function makeNode(ep, style) {\n      return _node(\"rect\", BLANK_ATTRIBUTES);\n    },\n    updateNode: function updateNode(ep, node) {\n      _attr(node, BLANK_ATTRIBUTES);\n    }\n  });\n};\n\nregister$2();\nregister();\nregister$1();\nvar _jsPlumbInstanceIndex = 0;\n\nfunction getInstanceIndex() {\n  var i = _jsPlumbInstanceIndex + 1;\n  _jsPlumbInstanceIndex++;\n  return i;\n}\n\nfunction newInstance(defaults) {\n  return new BrowserJsPlumbInstance(getInstanceIndex(), defaults);\n}\n\nfunction ready(f) {\n  var _do = function _do() {\n    if (/complete|loaded|interactive/.test(document.readyState) && typeof document.body !== \"undefined\" && document.body != null) {\n      f();\n    } else {\n      setTimeout(_do, 9);\n    }\n  };\n\n  _do();\n}\n\n\n\n//# sourceURL=webpack://questmaker/./node_modules/@jsplumb/browser-ui/js/jsplumb.browser-ui.es.js?");

/***/ }),

/***/ "./node_modules/@jsplumb/common/js/jsplumb.common.es.js":
/*!**************************************************************!*\
  !*** ./node_modules/@jsplumb/common/js/jsplumb.common.es.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AbstractSegment\": () => (/* binding */ AbstractSegment),\n/* harmony export */   \"AnchorLocations\": () => (/* binding */ AnchorLocations),\n/* harmony export */   \"DEFAULT\": () => (/* binding */ DEFAULT),\n/* harmony export */   \"EMPTY_BOUNDS\": () => (/* binding */ EMPTY_BOUNDS),\n/* harmony export */   \"FALSE\": () => (/* binding */ FALSE),\n/* harmony export */   \"PerimeterAnchorShapes\": () => (/* binding */ PerimeterAnchorShapes),\n/* harmony export */   \"TRUE\": () => (/* binding */ TRUE),\n/* harmony export */   \"UNDEFINED\": () => (/* binding */ UNDEFINED),\n/* harmony export */   \"WILDCARD\": () => (/* binding */ WILDCARD)\n/* harmony export */ });\nvar PerimeterAnchorShapes;\n\n(function (PerimeterAnchorShapes) {\n  PerimeterAnchorShapes[\"Circle\"] = \"Circle\";\n  PerimeterAnchorShapes[\"Ellipse\"] = \"Ellipse\";\n  PerimeterAnchorShapes[\"Triangle\"] = \"Triangle\";\n  PerimeterAnchorShapes[\"Diamond\"] = \"Diamond\";\n  PerimeterAnchorShapes[\"Rectangle\"] = \"Rectangle\";\n  PerimeterAnchorShapes[\"Square\"] = \"Square\";\n})(PerimeterAnchorShapes || (PerimeterAnchorShapes = {}));\n\nvar AnchorLocations;\n\n(function (AnchorLocations) {\n  AnchorLocations[\"Assign\"] = \"Assign\";\n  AnchorLocations[\"AutoDefault\"] = \"AutoDefault\";\n  AnchorLocations[\"Bottom\"] = \"Bottom\";\n  AnchorLocations[\"BottomLeft\"] = \"BottomLeft\";\n  AnchorLocations[\"BottomRight\"] = \"BottomRight\";\n  AnchorLocations[\"Center\"] = \"Center\";\n  AnchorLocations[\"Continuous\"] = \"Continuous\";\n  AnchorLocations[\"ContinuousBottom\"] = \"ContinuousBottom\";\n  AnchorLocations[\"ContinuousLeft\"] = \"ContinuousLeft\";\n  AnchorLocations[\"ContinuousRight\"] = \"ContinuousRight\";\n  AnchorLocations[\"ContinuousTop\"] = \"ContinuousTop\";\n  AnchorLocations[\"ContinuousLeftRight\"] = \"ContinuousLeftRight\";\n  AnchorLocations[\"ContinuousTopBottom\"] = \"ContinuousTopBottom\";\n  AnchorLocations[\"Left\"] = \"Left\";\n  AnchorLocations[\"Perimeter\"] = \"Perimeter\";\n  AnchorLocations[\"Right\"] = \"Right\";\n  AnchorLocations[\"Top\"] = \"Top\";\n  AnchorLocations[\"TopLeft\"] = \"TopLeft\";\n  AnchorLocations[\"TopRight\"] = \"TopRight\";\n})(AnchorLocations || (AnchorLocations = {}));\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction noSuchPoint() {\n  return {\n    d: Infinity,\n    x: null,\n    y: null,\n    l: null,\n    x1: null,\n    y1: null,\n    x2: null,\n    y2: null\n  };\n}\n\nfunction EMPTY_BOUNDS() {\n  return {\n    xmin: Infinity,\n    xmax: -Infinity,\n    ymin: Infinity,\n    ymax: -Infinity\n  };\n}\n\nvar AbstractSegment = function () {\n  function AbstractSegment(params) {\n    _classCallCheck(this, AbstractSegment);\n\n    this.params = params;\n\n    _defineProperty(this, \"x1\", void 0);\n\n    _defineProperty(this, \"x2\", void 0);\n\n    _defineProperty(this, \"y1\", void 0);\n\n    _defineProperty(this, \"y2\", void 0);\n\n    _defineProperty(this, \"extents\", EMPTY_BOUNDS());\n\n    _defineProperty(this, \"type\", void 0);\n\n    this.x1 = params.x1;\n    this.y1 = params.y1;\n    this.x2 = params.x2;\n    this.y2 = params.y2;\n  }\n\n  _createClass(AbstractSegment, [{\n    key: \"findClosestPointOnPath\",\n    value: function findClosestPointOnPath(x, y) {\n      return noSuchPoint();\n    }\n  }, {\n    key: \"lineIntersection\",\n    value: function lineIntersection(x1, y1, x2, y2) {\n      return [];\n    }\n  }, {\n    key: \"boxIntersection\",\n    value: function boxIntersection(x, y, w, h) {\n      var a = [];\n      a.push.apply(a, this.lineIntersection(x, y, x + w, y));\n      a.push.apply(a, this.lineIntersection(x + w, y, x + w, y + h));\n      a.push.apply(a, this.lineIntersection(x + w, y + h, x, y + h));\n      a.push.apply(a, this.lineIntersection(x, y + h, x, y));\n      return a;\n    }\n  }, {\n    key: \"boundingBoxIntersection\",\n    value: function boundingBoxIntersection(box) {\n      return this.boxIntersection(box.x, box.y, box.w, box.h);\n    }\n  }]);\n\n  return AbstractSegment;\n}();\n\nvar UNDEFINED = \"undefined\";\nvar DEFAULT = \"default\";\nvar TRUE = \"true\";\nvar FALSE = \"false\";\nvar WILDCARD = \"*\";\n\n\n//# sourceURL=webpack://questmaker/./node_modules/@jsplumb/common/js/jsplumb.common.es.js?");

/***/ }),

/***/ "./node_modules/@jsplumb/connector-flowchart/js/jsplumb.connector-flowchart.es.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@jsplumb/connector-flowchart/js/jsplumb.connector-flowchart.es.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FlowchartConnector\": () => (/* binding */ FlowchartConnector)\n/* harmony export */ });\n/* harmony import */ var _jsplumb_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jsplumb/core */ \"./node_modules/@jsplumb/core/js/jsplumb.core.es.js\");\n\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction sgn(n) {\n  return n < 0 ? -1 : n === 0 ? 0 : 1;\n}\n\nfunction segmentDirections(segment) {\n  return [sgn(segment[2] - segment[0]), sgn(segment[3] - segment[1])];\n}\n\nfunction segLength(s) {\n  return Math.sqrt(Math.pow(s[0] - s[2], 2) + Math.pow(s[1] - s[3], 2));\n}\n\nfunction _cloneArray(a) {\n  var _a = [];\n\n  _a.push.apply(_a, a);\n\n  return _a;\n}\n\nvar FlowchartConnector = function (_AbstractConnector) {\n  _inherits(FlowchartConnector, _AbstractConnector);\n\n  var _super = _createSuper(FlowchartConnector);\n\n  function FlowchartConnector(connection, params) {\n    var _this;\n\n    _classCallCheck(this, FlowchartConnector);\n\n    _this = _super.call(this, connection, params);\n    _this.connection = connection;\n\n    _defineProperty(_assertThisInitialized(_this), \"type\", FlowchartConnector.type);\n\n    _defineProperty(_assertThisInitialized(_this), \"internalSegments\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"midpoint\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"alwaysRespectStubs\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"cornerRadius\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"lastx\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"lasty\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"lastOrientation\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"loopbackRadius\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"isLoopbackCurrently\", void 0);\n\n    _this.midpoint = params.midpoint == null || isNaN(params.midpoint) ? 0.5 : params.midpoint;\n    _this.cornerRadius = params.cornerRadius != null ? params.cornerRadius : 0;\n    _this.alwaysRespectStubs = params.alwaysRespectStubs === true;\n    _this.lastx = null;\n    _this.lasty = null;\n    _this.lastOrientation = null;\n    _this.loopbackRadius = params.loopbackRadius || 25;\n    _this.isLoopbackCurrently = false;\n    return _this;\n  }\n\n  _createClass(FlowchartConnector, [{\n    key: \"getDefaultStubs\",\n    value: function getDefaultStubs() {\n      return [30, 30];\n    }\n  }, {\n    key: \"addASegment\",\n    value: function addASegment(x, y, paintInfo) {\n      if (this.lastx === x && this.lasty === y) {\n        return;\n      }\n\n      var lx = this.lastx == null ? paintInfo.sx : this.lastx,\n          ly = this.lasty == null ? paintInfo.sy : this.lasty,\n          o = lx === x ? \"v\" : \"h\";\n      this.lastx = x;\n      this.lasty = y;\n      this.internalSegments.push([lx, ly, x, y, o]);\n    }\n  }, {\n    key: \"writeSegments\",\n    value: function writeSegments(paintInfo) {\n      var current = null,\n          next,\n          currentDirection,\n          nextDirection;\n\n      for (var i = 0; i < this.internalSegments.length - 1; i++) {\n        current = current || _cloneArray(this.internalSegments[i]);\n        next = _cloneArray(this.internalSegments[i + 1]);\n        currentDirection = segmentDirections(current);\n        nextDirection = segmentDirections(next);\n\n        if (this.cornerRadius > 0 && current[4] !== next[4]) {\n          var minSegLength = Math.min(segLength(current), segLength(next));\n          var radiusToUse = Math.min(this.cornerRadius, minSegLength / 2);\n          current[2] -= currentDirection[0] * radiusToUse;\n          current[3] -= currentDirection[1] * radiusToUse;\n          next[0] += nextDirection[0] * radiusToUse;\n          next[1] += nextDirection[1] * radiusToUse;\n          var ac = currentDirection[1] === nextDirection[0] && nextDirection[0] === 1 || currentDirection[1] === nextDirection[0] && nextDirection[0] === 0 && currentDirection[0] !== nextDirection[1] || currentDirection[1] === nextDirection[0] && nextDirection[0] === -1,\n              sgny = next[1] > current[3] ? 1 : -1,\n              sgnx = next[0] > current[2] ? 1 : -1,\n              sgnEqual = sgny === sgnx,\n              cx = sgnEqual && ac || !sgnEqual && !ac ? next[0] : current[2],\n              cy = sgnEqual && ac || !sgnEqual && !ac ? current[3] : next[1];\n\n          this._addSegment(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.StraightSegment, {\n            x1: current[0],\n            y1: current[1],\n            x2: current[2],\n            y2: current[3]\n          });\n\n          this._addSegment(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.ArcSegment, {\n            r: radiusToUse,\n            x1: current[2],\n            y1: current[3],\n            x2: next[0],\n            y2: next[1],\n            cx: cx,\n            cy: cy,\n            ac: ac\n          });\n        } else {\n          this._addSegment(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.StraightSegment, {\n            x1: current[0],\n            y1: current[1],\n            x2: current[2],\n            y2: current[3]\n          });\n        }\n\n        current = next;\n      }\n\n      if (next != null) {\n        this._addSegment(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.StraightSegment, {\n          x1: next[0],\n          y1: next[1],\n          x2: next[2],\n          y2: next[3]\n        });\n      }\n    }\n  }, {\n    key: \"_compute\",\n    value: function _compute(paintInfo, params) {\n      var _this2 = this;\n\n      this.internalSegments.length = 0;\n      this.lastx = null;\n      this.lasty = null;\n      this.lastOrientation = null;\n\n      var commonStubCalculator = function commonStubCalculator(axis) {\n        return [paintInfo.startStubX, paintInfo.startStubY, paintInfo.endStubX, paintInfo.endStubY];\n      },\n          stubCalculators = {\n        perpendicular: commonStubCalculator,\n        orthogonal: commonStubCalculator,\n        opposite: function opposite(axis) {\n          var pi = paintInfo,\n              idx = axis === \"x\" ? 0 : 1,\n              areInProximity = {\n            \"x\": function x() {\n              return pi.so[idx] === 1 && (pi.startStubX > pi.endStubX && pi.tx > pi.startStubX || pi.sx > pi.endStubX && pi.tx > pi.sx) || pi.so[idx] === -1 && (pi.startStubX < pi.endStubX && pi.tx < pi.startStubX || pi.sx < pi.endStubX && pi.tx < pi.sx);\n            },\n            \"y\": function y() {\n              return pi.so[idx] === 1 && (pi.startStubY > pi.endStubY && pi.ty > pi.startStubY || pi.sy > pi.endStubY && pi.ty > pi.sy) || pi.so[idx] === -1 && (pi.startStubY < pi.endStubY && pi.ty < pi.startStubY || pi.sy < pi.endStubY && pi.ty < pi.sy);\n            }\n          };\n\n          if (!_this2.alwaysRespectStubs && areInProximity[axis]()) {\n            return {\n              \"x\": [(paintInfo.sx + paintInfo.tx) / 2, paintInfo.startStubY, (paintInfo.sx + paintInfo.tx) / 2, paintInfo.endStubY],\n              \"y\": [paintInfo.startStubX, (paintInfo.sy + paintInfo.ty) / 2, paintInfo.endStubX, (paintInfo.sy + paintInfo.ty) / 2]\n            }[axis];\n          } else {\n            return [paintInfo.startStubX, paintInfo.startStubY, paintInfo.endStubX, paintInfo.endStubY];\n          }\n        }\n      };\n\n      var stubs = stubCalculators[paintInfo.anchorOrientation](paintInfo.sourceAxis),\n          idx = paintInfo.sourceAxis === \"x\" ? 0 : 1,\n          oidx = paintInfo.sourceAxis === \"x\" ? 1 : 0,\n          ss = stubs[idx],\n          oss = stubs[oidx],\n          es = stubs[idx + 2],\n          oes = stubs[oidx + 2];\n      this.addASegment(stubs[0], stubs[1], paintInfo);\n      var midx = paintInfo.startStubX + (paintInfo.endStubX - paintInfo.startStubX) * this.midpoint,\n          midy = paintInfo.startStubY + (paintInfo.endStubY - paintInfo.startStubY) * this.midpoint;\n      var orientations = {\n        x: [0, 1],\n        y: [1, 0]\n      },\n          lineCalculators = {\n        perpendicular: function perpendicular(axis, ss, oss, es, oes) {\n          var pi = paintInfo,\n              sis = {\n            x: [[[1, 2, 3, 4], null, [2, 1, 4, 3]], null, [[4, 3, 2, 1], null, [3, 4, 1, 2]]],\n            y: [[[3, 2, 1, 4], null, [2, 3, 4, 1]], null, [[4, 1, 2, 3], null, [1, 4, 3, 2]]]\n          },\n              stubs = {\n            x: [[pi.startStubX, pi.endStubX], null, [pi.endStubX, pi.startStubX]],\n            y: [[pi.startStubY, pi.endStubY], null, [pi.endStubY, pi.startStubY]]\n          },\n              midLines = {\n            x: [[midx, pi.startStubY], [midx, pi.endStubY]],\n            y: [[pi.startStubX, midy], [pi.endStubX, midy]]\n          },\n              linesToEnd = {\n            x: [[pi.endStubX, pi.startStubY]],\n            y: [[pi.startStubX, pi.endStubY]]\n          },\n              startToEnd = {\n            x: [[pi.startStubX, pi.endStubY], [pi.endStubX, pi.endStubY]],\n            y: [[pi.endStubX, pi.startStubY], [pi.endStubX, pi.endStubY]]\n          },\n              startToMidToEnd = {\n            x: [[pi.startStubX, midy], [pi.endStubX, midy], [pi.endStubX, pi.endStubY]],\n            y: [[midx, pi.startStubY], [midx, pi.endStubY], [pi.endStubX, pi.endStubY]]\n          },\n              otherStubs = {\n            x: [pi.startStubY, pi.endStubY],\n            y: [pi.startStubX, pi.endStubX]\n          },\n              soIdx = orientations[axis][0],\n              toIdx = orientations[axis][1],\n              _so = pi.so[soIdx] + 1,\n              _to = pi.to[toIdx] + 1,\n              otherFlipped = pi.to[toIdx] === -1 && otherStubs[axis][1] < otherStubs[axis][0] || pi.to[toIdx] === 1 && otherStubs[axis][1] > otherStubs[axis][0],\n              stub1 = stubs[axis][_so][0],\n              stub2 = stubs[axis][_so][1],\n              segmentIndexes = sis[axis][_so][_to];\n\n          if (pi.segment === segmentIndexes[3] || pi.segment === segmentIndexes[2] && otherFlipped) {\n            return midLines[axis];\n          } else if (pi.segment === segmentIndexes[2] && stub2 < stub1) {\n            return linesToEnd[axis];\n          } else if (pi.segment === segmentIndexes[2] && stub2 >= stub1 || pi.segment === segmentIndexes[1] && !otherFlipped) {\n            return startToMidToEnd[axis];\n          } else if (pi.segment === segmentIndexes[0] || pi.segment === segmentIndexes[1] && otherFlipped) {\n            return startToEnd[axis];\n          }\n        },\n        orthogonal: function orthogonal(axis, startStub, otherStartStub, endStub, otherEndStub) {\n          var pi = paintInfo,\n              extent = {\n            \"x\": pi.so[0] === -1 ? Math.min(startStub, endStub) : Math.max(startStub, endStub),\n            \"y\": pi.so[1] === -1 ? Math.min(startStub, endStub) : Math.max(startStub, endStub)\n          }[axis];\n          return {\n            \"x\": [[extent, otherStartStub], [extent, otherEndStub], [endStub, otherEndStub]],\n            \"y\": [[otherStartStub, extent], [otherEndStub, extent], [otherEndStub, endStub]]\n          }[axis];\n        },\n        opposite: function opposite(axis, ss, oss, es, oes) {\n          var pi = paintInfo,\n              otherAxis = {\n            \"x\": \"y\",\n            \"y\": \"x\"\n          }[axis],\n              dim = {\n            \"x\": \"h\",\n            \"y\": \"w\"\n          }[axis],\n              comparator = pi[\"is\" + axis.toUpperCase() + \"GreaterThanStubTimes2\"];\n\n          if (params.sourceEndpoint.elementId === params.targetEndpoint.elementId) {\n            var _val = oss + (1 - params.sourceEndpoint._anchor.computedPosition[otherAxis]) * params.sourceInfo[dim] + _this2.maxStub;\n\n            return {\n              \"x\": [[ss, _val], [es, _val]],\n              \"y\": [[_val, ss], [_val, es]]\n            }[axis];\n          } else if (!comparator || pi.so[idx] === 1 && ss > es || pi.so[idx] === -1 && ss < es) {\n            return {\n              \"x\": [[ss, midy], [es, midy]],\n              \"y\": [[midx, ss], [midx, es]]\n            }[axis];\n          } else if (pi.so[idx] === 1 && ss < es || pi.so[idx] === -1 && ss > es) {\n            return {\n              \"x\": [[midx, pi.sy], [midx, pi.ty]],\n              \"y\": [[pi.sx, midy], [pi.tx, midy]]\n            }[axis];\n          }\n        }\n      };\n      var p = lineCalculators[paintInfo.anchorOrientation](paintInfo.sourceAxis, ss, oss, es, oes);\n\n      if (p) {\n        for (var i = 0; i < p.length; i++) {\n          this.addASegment(p[i][0], p[i][1], paintInfo);\n        }\n      }\n\n      this.addASegment(stubs[2], stubs[3], paintInfo);\n      this.addASegment(paintInfo.tx, paintInfo.ty, paintInfo);\n      this.writeSegments(paintInfo);\n    }\n  }, {\n    key: \"transformGeometry\",\n    value: function transformGeometry(g, dx, dy) {\n      return g;\n    }\n  }]);\n\n  return FlowchartConnector;\n}(_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.AbstractConnector);\n\n_defineProperty(FlowchartConnector, \"type\", \"Flowchart\");\n\n_jsplumb_core__WEBPACK_IMPORTED_MODULE_0__.Connectors.register(FlowchartConnector.type, FlowchartConnector);\n\n\n//# sourceURL=webpack://questmaker/./node_modules/@jsplumb/connector-flowchart/js/jsplumb.connector-flowchart.es.js?");

/***/ }),

/***/ "./node_modules/@jsplumb/core/js/jsplumb.core.es.js":
/*!**********************************************************!*\
  !*** ./node_modules/@jsplumb/core/js/jsplumb.core.es.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ABSOLUTE\": () => (/* binding */ ABSOLUTE),\n/* harmony export */   \"ATTRIBUTE_GROUP\": () => (/* binding */ ATTRIBUTE_GROUP),\n/* harmony export */   \"ATTRIBUTE_MANAGED\": () => (/* binding */ ATTRIBUTE_MANAGED),\n/* harmony export */   \"ATTRIBUTE_NOT_DRAGGABLE\": () => (/* binding */ ATTRIBUTE_NOT_DRAGGABLE),\n/* harmony export */   \"ATTRIBUTE_SCOPE\": () => (/* binding */ ATTRIBUTE_SCOPE),\n/* harmony export */   \"ATTRIBUTE_SCOPE_PREFIX\": () => (/* binding */ ATTRIBUTE_SCOPE_PREFIX),\n/* harmony export */   \"ATTRIBUTE_TABINDEX\": () => (/* binding */ ATTRIBUTE_TABINDEX),\n/* harmony export */   \"AbstractConnector\": () => (/* binding */ AbstractConnector),\n/* harmony export */   \"ArcSegment\": () => (/* binding */ ArcSegment),\n/* harmony export */   \"ArrowOverlay\": () => (/* binding */ ArrowOverlay),\n/* harmony export */   \"BLOCK\": () => (/* binding */ BLOCK),\n/* harmony export */   \"BOTTOM\": () => (/* binding */ BOTTOM),\n/* harmony export */   \"BlankEndpoint\": () => (/* binding */ BlankEndpoint),\n/* harmony export */   \"BlankEndpointHandler\": () => (/* binding */ BlankEndpointHandler),\n/* harmony export */   \"CHECK_CONDITION\": () => (/* binding */ CHECK_CONDITION),\n/* harmony export */   \"CHECK_DROP_ALLOWED\": () => (/* binding */ CHECK_DROP_ALLOWED),\n/* harmony export */   \"CLASS_CONNECTED\": () => (/* binding */ CLASS_CONNECTED),\n/* harmony export */   \"CLASS_CONNECTOR\": () => (/* binding */ CLASS_CONNECTOR),\n/* harmony export */   \"CLASS_CONNECTOR_OUTLINE\": () => (/* binding */ CLASS_CONNECTOR_OUTLINE),\n/* harmony export */   \"CLASS_ENDPOINT\": () => (/* binding */ CLASS_ENDPOINT),\n/* harmony export */   \"CLASS_ENDPOINT_ANCHOR_PREFIX\": () => (/* binding */ CLASS_ENDPOINT_ANCHOR_PREFIX),\n/* harmony export */   \"CLASS_ENDPOINT_CONNECTED\": () => (/* binding */ CLASS_ENDPOINT_CONNECTED),\n/* harmony export */   \"CLASS_ENDPOINT_DROP_ALLOWED\": () => (/* binding */ CLASS_ENDPOINT_DROP_ALLOWED),\n/* harmony export */   \"CLASS_ENDPOINT_DROP_FORBIDDEN\": () => (/* binding */ CLASS_ENDPOINT_DROP_FORBIDDEN),\n/* harmony export */   \"CLASS_ENDPOINT_FULL\": () => (/* binding */ CLASS_ENDPOINT_FULL),\n/* harmony export */   \"CLASS_GROUP_COLLAPSED\": () => (/* binding */ CLASS_GROUP_COLLAPSED),\n/* harmony export */   \"CLASS_GROUP_EXPANDED\": () => (/* binding */ CLASS_GROUP_EXPANDED),\n/* harmony export */   \"CLASS_OVERLAY\": () => (/* binding */ CLASS_OVERLAY),\n/* harmony export */   \"Component\": () => (/* binding */ Component),\n/* harmony export */   \"Connection\": () => (/* binding */ Connection),\n/* harmony export */   \"ConnectionDragSelector\": () => (/* binding */ ConnectionDragSelector),\n/* harmony export */   \"ConnectionSelection\": () => (/* binding */ ConnectionSelection),\n/* harmony export */   \"Connectors\": () => (/* binding */ Connectors),\n/* harmony export */   \"CustomOverlay\": () => (/* binding */ CustomOverlay),\n/* harmony export */   \"DiamondOverlay\": () => (/* binding */ DiamondOverlay),\n/* harmony export */   \"DotEndpoint\": () => (/* binding */ DotEndpoint),\n/* harmony export */   \"DotEndpointHandler\": () => (/* binding */ DotEndpointHandler),\n/* harmony export */   \"ERROR_SOURCE_DOES_NOT_EXIST\": () => (/* binding */ ERROR_SOURCE_DOES_NOT_EXIST),\n/* harmony export */   \"ERROR_SOURCE_ENDPOINT_FULL\": () => (/* binding */ ERROR_SOURCE_ENDPOINT_FULL),\n/* harmony export */   \"ERROR_TARGET_DOES_NOT_EXIST\": () => (/* binding */ ERROR_TARGET_DOES_NOT_EXIST),\n/* harmony export */   \"ERROR_TARGET_ENDPOINT_FULL\": () => (/* binding */ ERROR_TARGET_ENDPOINT_FULL),\n/* harmony export */   \"EVENT_ANCHOR_CHANGED\": () => (/* binding */ EVENT_ANCHOR_CHANGED),\n/* harmony export */   \"EVENT_CONNECTION\": () => (/* binding */ EVENT_CONNECTION),\n/* harmony export */   \"EVENT_CONNECTION_DETACHED\": () => (/* binding */ EVENT_CONNECTION_DETACHED),\n/* harmony export */   \"EVENT_CONNECTION_MOVED\": () => (/* binding */ EVENT_CONNECTION_MOVED),\n/* harmony export */   \"EVENT_CONTAINER_CHANGE\": () => (/* binding */ EVENT_CONTAINER_CHANGE),\n/* harmony export */   \"EVENT_ENDPOINT_REPLACED\": () => (/* binding */ EVENT_ENDPOINT_REPLACED),\n/* harmony export */   \"EVENT_GROUP_ADDED\": () => (/* binding */ EVENT_GROUP_ADDED),\n/* harmony export */   \"EVENT_GROUP_COLLAPSE\": () => (/* binding */ EVENT_GROUP_COLLAPSE),\n/* harmony export */   \"EVENT_GROUP_EXPAND\": () => (/* binding */ EVENT_GROUP_EXPAND),\n/* harmony export */   \"EVENT_GROUP_MEMBER_ADDED\": () => (/* binding */ EVENT_GROUP_MEMBER_ADDED),\n/* harmony export */   \"EVENT_GROUP_MEMBER_REMOVED\": () => (/* binding */ EVENT_GROUP_MEMBER_REMOVED),\n/* harmony export */   \"EVENT_GROUP_REMOVED\": () => (/* binding */ EVENT_GROUP_REMOVED),\n/* harmony export */   \"EVENT_INTERNAL_CONNECTION\": () => (/* binding */ EVENT_INTERNAL_CONNECTION),\n/* harmony export */   \"EVENT_INTERNAL_CONNECTION_DETACHED\": () => (/* binding */ EVENT_INTERNAL_CONNECTION_DETACHED),\n/* harmony export */   \"EVENT_INTERNAL_ENDPOINT_UNREGISTERED\": () => (/* binding */ EVENT_INTERNAL_ENDPOINT_UNREGISTERED),\n/* harmony export */   \"EVENT_MANAGE_ELEMENT\": () => (/* binding */ EVENT_MANAGE_ELEMENT),\n/* harmony export */   \"EVENT_MAX_CONNECTIONS\": () => (/* binding */ EVENT_MAX_CONNECTIONS),\n/* harmony export */   \"EVENT_NESTED_GROUP_ADDED\": () => (/* binding */ EVENT_NESTED_GROUP_ADDED),\n/* harmony export */   \"EVENT_NESTED_GROUP_REMOVED\": () => (/* binding */ EVENT_NESTED_GROUP_REMOVED),\n/* harmony export */   \"EVENT_UNMANAGE_ELEMENT\": () => (/* binding */ EVENT_UNMANAGE_ELEMENT),\n/* harmony export */   \"EVENT_ZOOM\": () => (/* binding */ EVENT_ZOOM),\n/* harmony export */   \"Endpoint\": () => (/* binding */ Endpoint),\n/* harmony export */   \"EndpointFactory\": () => (/* binding */ EndpointFactory),\n/* harmony export */   \"EndpointRepresentation\": () => (/* binding */ EndpointRepresentation),\n/* harmony export */   \"EndpointSelection\": () => (/* binding */ EndpointSelection),\n/* harmony export */   \"FIXED\": () => (/* binding */ FIXED),\n/* harmony export */   \"GroupManager\": () => (/* binding */ GroupManager),\n/* harmony export */   \"INTERCEPT_BEFORE_DETACH\": () => (/* binding */ INTERCEPT_BEFORE_DETACH),\n/* harmony export */   \"INTERCEPT_BEFORE_DRAG\": () => (/* binding */ INTERCEPT_BEFORE_DRAG),\n/* harmony export */   \"INTERCEPT_BEFORE_DROP\": () => (/* binding */ INTERCEPT_BEFORE_DROP),\n/* harmony export */   \"INTERCEPT_BEFORE_START_DETACH\": () => (/* binding */ INTERCEPT_BEFORE_START_DETACH),\n/* harmony export */   \"IS_DETACH_ALLOWED\": () => (/* binding */ IS_DETACH_ALLOWED),\n/* harmony export */   \"JsPlumbInstance\": () => (/* binding */ JsPlumbInstance),\n/* harmony export */   \"KEY_CONNECTION_OVERLAYS\": () => (/* binding */ KEY_CONNECTION_OVERLAYS),\n/* harmony export */   \"LEFT\": () => (/* binding */ LEFT),\n/* harmony export */   \"LabelOverlay\": () => (/* binding */ LabelOverlay),\n/* harmony export */   \"LightweightFloatingAnchor\": () => (/* binding */ LightweightFloatingAnchor),\n/* harmony export */   \"LightweightRouter\": () => (/* binding */ LightweightRouter),\n/* harmony export */   \"NONE\": () => (/* binding */ NONE),\n/* harmony export */   \"Overlay\": () => (/* binding */ Overlay),\n/* harmony export */   \"OverlayFactory\": () => (/* binding */ OverlayFactory),\n/* harmony export */   \"PlainArrowOverlay\": () => (/* binding */ PlainArrowOverlay),\n/* harmony export */   \"REDROP_POLICY_ANY\": () => (/* binding */ REDROP_POLICY_ANY),\n/* harmony export */   \"REDROP_POLICY_STRICT\": () => (/* binding */ REDROP_POLICY_STRICT),\n/* harmony export */   \"RIGHT\": () => (/* binding */ RIGHT),\n/* harmony export */   \"RectangleEndpoint\": () => (/* binding */ RectangleEndpoint),\n/* harmony export */   \"RectangleEndpointHandler\": () => (/* binding */ RectangleEndpointHandler),\n/* harmony export */   \"SELECTOR_MANAGED_ELEMENT\": () => (/* binding */ SELECTOR_MANAGED_ELEMENT),\n/* harmony export */   \"SOURCE\": () => (/* binding */ SOURCE),\n/* harmony export */   \"SOURCE_INDEX\": () => (/* binding */ SOURCE_INDEX),\n/* harmony export */   \"STATIC\": () => (/* binding */ STATIC),\n/* harmony export */   \"SourceSelector\": () => (/* binding */ SourceSelector),\n/* harmony export */   \"StraightConnector\": () => (/* binding */ StraightConnector),\n/* harmony export */   \"StraightSegment\": () => (/* binding */ StraightSegment),\n/* harmony export */   \"TARGET\": () => (/* binding */ TARGET),\n/* harmony export */   \"TARGET_INDEX\": () => (/* binding */ TARGET_INDEX),\n/* harmony export */   \"TOP\": () => (/* binding */ TOP),\n/* harmony export */   \"TargetSelector\": () => (/* binding */ TargetSelector),\n/* harmony export */   \"UIGroup\": () => (/* binding */ UIGroup),\n/* harmony export */   \"UINode\": () => (/* binding */ UINode),\n/* harmony export */   \"Viewport\": () => (/* binding */ Viewport),\n/* harmony export */   \"X_AXIS_FACES\": () => (/* binding */ X_AXIS_FACES),\n/* harmony export */   \"Y_AXIS_FACES\": () => (/* binding */ Y_AXIS_FACES),\n/* harmony export */   \"_createPerimeterAnchor\": () => (/* binding */ _createPerimeterAnchor),\n/* harmony export */   \"_removeTypeCssHelper\": () => (/* binding */ _removeTypeCssHelper),\n/* harmony export */   \"_updateHoverStyle\": () => (/* binding */ _updateHoverStyle),\n/* harmony export */   \"att\": () => (/* binding */ att),\n/* harmony export */   \"classList\": () => (/* binding */ classList),\n/* harmony export */   \"cls\": () => (/* binding */ cls),\n/* harmony export */   \"convertToFullOverlaySpec\": () => (/* binding */ convertToFullOverlaySpec),\n/* harmony export */   \"createFloatingAnchor\": () => (/* binding */ createFloatingAnchor),\n/* harmony export */   \"getDefaultFace\": () => (/* binding */ getDefaultFace),\n/* harmony export */   \"isArrowOverlay\": () => (/* binding */ isArrowOverlay),\n/* harmony export */   \"isContinuous\": () => (/* binding */ isContinuous),\n/* harmony export */   \"isCustomOverlay\": () => (/* binding */ isCustomOverlay),\n/* harmony export */   \"isDiamondOverlay\": () => (/* binding */ isDiamondOverlay),\n/* harmony export */   \"isDynamic\": () => (/* binding */ isDynamic),\n/* harmony export */   \"isEdgeSupported\": () => (/* binding */ isEdgeSupported),\n/* harmony export */   \"isFloating\": () => (/* binding */ _isFloating),\n/* harmony export */   \"isFullOverlaySpec\": () => (/* binding */ isFullOverlaySpec),\n/* harmony export */   \"isLabelOverlay\": () => (/* binding */ isLabelOverlay),\n/* harmony export */   \"isPlainArrowOverlay\": () => (/* binding */ isPlainArrowOverlay),\n/* harmony export */   \"makeLightweightAnchorFromSpec\": () => (/* binding */ makeLightweightAnchorFromSpec)\n/* harmony export */ });\n/* harmony import */ var _jsplumb_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jsplumb/util */ \"./node_modules/@jsplumb/util/js/jsplumb.util.es.js\");\n/* harmony import */ var _jsplumb_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jsplumb/common */ \"./node_modules/@jsplumb/common/js/jsplumb.common.es.js\");\n\n\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar endpointMap = {};\nvar endpointComputers = {};\nvar handlers = {};\nvar EndpointFactory = {\n  get: function get(ep, name, params) {\n    var e = endpointMap[name];\n\n    if (!e) {\n      throw {\n        message: \"jsPlumb: unknown endpoint type '\" + name + \"'\"\n      };\n    } else {\n      return new e(ep, params);\n    }\n  },\n  clone: function clone(epr) {\n    var handler = handlers[epr.type];\n    return EndpointFactory.get(epr.endpoint, epr.type, handler.getParams(epr));\n  },\n  compute: function compute(endpoint, anchorPoint, orientation, endpointStyle) {\n    var c = endpointComputers[endpoint.type];\n\n    if (c != null) {\n      return c(endpoint, anchorPoint, orientation, endpointStyle);\n    } else {\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.log)(\"jsPlumb: cannot find endpoint calculator for endpoint of type \", endpoint.type);\n    }\n  },\n  registerHandler: function registerHandler(eph) {\n    handlers[eph.type] = eph;\n    endpointMap[eph.type] = eph.cls;\n    endpointComputers[eph.type] = eph.compute;\n  }\n};\n\nvar EndpointRepresentation = function () {\n  function EndpointRepresentation(endpoint, params) {\n    _classCallCheck(this, EndpointRepresentation);\n\n    this.endpoint = endpoint;\n\n    _defineProperty(this, \"typeId\", void 0);\n\n    _defineProperty(this, \"x\", void 0);\n\n    _defineProperty(this, \"y\", void 0);\n\n    _defineProperty(this, \"w\", void 0);\n\n    _defineProperty(this, \"h\", void 0);\n\n    _defineProperty(this, \"computedValue\", void 0);\n\n    _defineProperty(this, \"bounds\", (0,_jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.EMPTY_BOUNDS)());\n\n    _defineProperty(this, \"classes\", []);\n\n    _defineProperty(this, \"instance\", void 0);\n\n    _defineProperty(this, \"type\", void 0);\n\n    params = params || {};\n    this.instance = endpoint.instance;\n\n    if (endpoint.cssClass) {\n      this.classes.push(endpoint.cssClass);\n    }\n\n    if (params.cssClass) {\n      this.classes.push(params.cssClass);\n    }\n  }\n\n  _createClass(EndpointRepresentation, [{\n    key: \"addClass\",\n    value: function addClass(c) {\n      this.classes.push(c);\n      this.instance.addEndpointClass(this.endpoint, c);\n    }\n  }, {\n    key: \"removeClass\",\n    value: function removeClass(c) {\n      this.classes = this.classes.filter(function (_c) {\n        return _c !== c;\n      });\n      this.instance.removeEndpointClass(this.endpoint, c);\n    }\n  }, {\n    key: \"compute\",\n    value: function compute(anchorPoint, orientation, endpointStyle) {\n      this.computedValue = EndpointFactory.compute(this, anchorPoint, orientation, endpointStyle);\n      this.bounds.xmin = this.x;\n      this.bounds.ymin = this.y;\n      this.bounds.xmax = this.x + this.w;\n      this.bounds.ymax = this.y + this.h;\n    }\n  }, {\n    key: \"setVisible\",\n    value: function setVisible(v) {\n      this.instance.setEndpointVisible(this.endpoint, v);\n    }\n  }]);\n\n  return EndpointRepresentation;\n}();\n\nvar DotEndpoint = function (_EndpointRepresentati) {\n  _inherits(DotEndpoint, _EndpointRepresentati);\n\n  var _super = _createSuper(DotEndpoint);\n\n  function DotEndpoint(endpoint, params) {\n    var _this;\n\n    _classCallCheck(this, DotEndpoint);\n\n    _this = _super.call(this, endpoint, params);\n\n    _defineProperty(_assertThisInitialized(_this), \"radius\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"defaultOffset\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"defaultInnerRadius\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"type\", DotEndpoint.type);\n\n    params = params || {};\n    _this.radius = params.radius || 5;\n    _this.defaultOffset = 0.5 * _this.radius;\n    _this.defaultInnerRadius = _this.radius / 3;\n    return _this;\n  }\n\n  return DotEndpoint;\n}(EndpointRepresentation);\n\n_defineProperty(DotEndpoint, \"type\", \"Dot\");\n\nvar DotEndpointHandler = {\n  type: DotEndpoint.type,\n  cls: DotEndpoint,\n  compute: function compute(ep, anchorPoint, orientation, endpointStyle) {\n    var x = anchorPoint.curX - ep.radius,\n        y = anchorPoint.curY - ep.radius,\n        w = ep.radius * 2,\n        h = ep.radius * 2;\n\n    if (endpointStyle && endpointStyle.stroke) {\n      var lw = endpointStyle.strokeWidth || 1;\n      x -= lw;\n      y -= lw;\n      w += lw * 2;\n      h += lw * 2;\n    }\n\n    ep.x = x;\n    ep.y = y;\n    ep.w = w;\n    ep.h = h;\n    return [x, y, w, h, ep.radius];\n  },\n  getParams: function getParams(ep) {\n    return {\n      radius: ep.radius\n    };\n  }\n};\n\nvar BlankEndpoint = function (_EndpointRepresentati) {\n  _inherits(BlankEndpoint, _EndpointRepresentati);\n\n  var _super = _createSuper(BlankEndpoint);\n\n  function BlankEndpoint(endpoint, params) {\n    var _this;\n\n    _classCallCheck(this, BlankEndpoint);\n\n    _this = _super.call(this, endpoint, params);\n\n    _defineProperty(_assertThisInitialized(_this), \"type\", BlankEndpoint.type);\n\n    return _this;\n  }\n\n  return BlankEndpoint;\n}(EndpointRepresentation);\n\n_defineProperty(BlankEndpoint, \"type\", \"Blank\");\n\nvar BlankEndpointHandler = {\n  type: BlankEndpoint.type,\n  cls: BlankEndpoint,\n  compute: function compute(ep, anchorPoint, orientation, endpointStyle) {\n    ep.x = anchorPoint.curX;\n    ep.y = anchorPoint.curY;\n    ep.w = 10;\n    ep.h = 0;\n    return [anchorPoint.curX, anchorPoint.curY, 10, 0];\n  },\n  getParams: function getParams(ep) {\n    return {};\n  }\n};\n\nvar RectangleEndpoint = function (_EndpointRepresentati) {\n  _inherits(RectangleEndpoint, _EndpointRepresentati);\n\n  var _super = _createSuper(RectangleEndpoint);\n\n  function RectangleEndpoint(endpoint, params) {\n    var _this;\n\n    _classCallCheck(this, RectangleEndpoint);\n\n    _this = _super.call(this, endpoint, params);\n\n    _defineProperty(_assertThisInitialized(_this), \"width\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"height\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"type\", RectangleEndpoint.type);\n\n    params = params || {};\n    _this.width = params.width || 10;\n    _this.height = params.height || 10;\n    return _this;\n  }\n\n  _createClass(RectangleEndpoint, null, [{\n    key: \"_getParams\",\n    value: function _getParams(ep) {\n      return {\n        width: ep.width,\n        height: ep.height\n      };\n    }\n  }]);\n\n  return RectangleEndpoint;\n}(EndpointRepresentation);\n\n_defineProperty(RectangleEndpoint, \"type\", \"Rectangle\");\n\nvar RectangleEndpointHandler = {\n  type: RectangleEndpoint.type,\n  cls: RectangleEndpoint,\n  compute: function compute(ep, anchorPoint, orientation, endpointStyle) {\n    var width = endpointStyle.width || ep.width,\n        height = endpointStyle.height || ep.height,\n        x = anchorPoint.curX - width / 2,\n        y = anchorPoint.curY - height / 2;\n    ep.x = x;\n    ep.y = y;\n    ep.w = width;\n    ep.h = height;\n    return [x, y, width, height];\n  },\n  getParams: function getParams(ep) {\n    return {\n      width: ep.width,\n      height: ep.height\n    };\n  }\n};\n\nvar AbstractConnector = function () {\n  function AbstractConnector(connection, params) {\n    _classCallCheck(this, AbstractConnector);\n\n    this.connection = connection;\n\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"edited\", false);\n\n    _defineProperty(this, \"stub\", void 0);\n\n    _defineProperty(this, \"sourceStub\", void 0);\n\n    _defineProperty(this, \"targetStub\", void 0);\n\n    _defineProperty(this, \"maxStub\", void 0);\n\n    _defineProperty(this, \"typeId\", void 0);\n\n    _defineProperty(this, \"gap\", void 0);\n\n    _defineProperty(this, \"sourceGap\", void 0);\n\n    _defineProperty(this, \"targetGap\", void 0);\n\n    _defineProperty(this, \"segments\", []);\n\n    _defineProperty(this, \"totalLength\", 0);\n\n    _defineProperty(this, \"segmentProportions\", []);\n\n    _defineProperty(this, \"segmentProportionalLengths\", []);\n\n    _defineProperty(this, \"paintInfo\", null);\n\n    _defineProperty(this, \"strokeWidth\", void 0);\n\n    _defineProperty(this, \"x\", void 0);\n\n    _defineProperty(this, \"y\", void 0);\n\n    _defineProperty(this, \"w\", void 0);\n\n    _defineProperty(this, \"h\", void 0);\n\n    _defineProperty(this, \"segment\", void 0);\n\n    _defineProperty(this, \"bounds\", (0,_jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.EMPTY_BOUNDS)());\n\n    _defineProperty(this, \"cssClass\", void 0);\n\n    _defineProperty(this, \"hoverClass\", void 0);\n\n    _defineProperty(this, \"geometry\", void 0);\n\n    this.stub = params.stub || this.getDefaultStubs();\n    this.sourceStub = Array.isArray(this.stub) ? this.stub[0] : this.stub;\n    this.targetStub = Array.isArray(this.stub) ? this.stub[1] : this.stub;\n    this.gap = params.gap || 0;\n    this.sourceGap = Array.isArray(this.gap) ? this.gap[0] : this.gap;\n    this.targetGap = Array.isArray(this.gap) ? this.gap[1] : this.gap;\n    this.maxStub = Math.max(this.sourceStub, this.targetStub);\n    this.cssClass = params.cssClass || \"\";\n    this.hoverClass = params.hoverClass || \"\";\n  }\n\n  _createClass(AbstractConnector, [{\n    key: \"getTypeDescriptor\",\n    value: function getTypeDescriptor() {\n      return \"connector\";\n    }\n  }, {\n    key: \"getIdPrefix\",\n    value: function getIdPrefix() {\n      return \"_jsplumb_connector\";\n    }\n  }, {\n    key: \"setGeometry\",\n    value: function setGeometry(g, internal) {\n      this.geometry = g;\n      this.edited = g != null && !internal;\n    }\n  }, {\n    key: \"exportGeometry\",\n    value: function exportGeometry() {\n      return this.geometry;\n    }\n  }, {\n    key: \"importGeometry\",\n    value: function importGeometry(g) {\n      this.geometry = g;\n      return true;\n    }\n  }, {\n    key: \"resetGeometry\",\n    value: function resetGeometry() {\n      this.geometry = null;\n      this.edited = false;\n    }\n  }, {\n    key: \"transformAnchorPlacement\",\n    value: function transformAnchorPlacement(a, dx, dy) {\n      return {\n        x: a.x,\n        y: a.y,\n        ox: a.ox,\n        oy: a.oy,\n        curX: a.curX + dx,\n        curY: a.curY + dy\n      };\n    }\n  }, {\n    key: \"resetBounds\",\n    value: function resetBounds() {\n      this.bounds = (0,_jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.EMPTY_BOUNDS)();\n    }\n  }, {\n    key: \"findSegmentForPoint\",\n    value: function findSegmentForPoint(x, y) {\n      var out = {\n        d: Infinity,\n        s: null,\n        x: null,\n        y: null,\n        l: null,\n        x1: null,\n        y1: null,\n        x2: null,\n        y2: null,\n        index: null,\n        connectorLocation: null\n      };\n\n      for (var i = 0; i < this.segments.length; i++) {\n        var _s = this.segments[i].findClosestPointOnPath(x, y);\n\n        if (_s.d < out.d) {\n          out.d = _s.d;\n          out.l = _s.l;\n          out.x = _s.x;\n          out.y = _s.y;\n          out.s = this.segments[i];\n          out.x1 = _s.x1;\n          out.x2 = _s.x2;\n          out.y1 = _s.y1;\n          out.y2 = _s.y2;\n          out.index = i;\n          out.connectorLocation = this.segmentProportions[i][0] + _s.l * (this.segmentProportions[i][1] - this.segmentProportions[i][0]);\n        }\n      }\n\n      return out;\n    }\n  }, {\n    key: \"lineIntersection\",\n    value: function lineIntersection(x1, y1, x2, y2) {\n      var out = [];\n\n      for (var i = 0; i < this.segments.length; i++) {\n        out.push.apply(out, this.segments[i].lineIntersection(x1, y1, x2, y2));\n      }\n\n      return out;\n    }\n  }, {\n    key: \"boxIntersection\",\n    value: function boxIntersection(x, y, w, h) {\n      var out = [];\n\n      for (var i = 0; i < this.segments.length; i++) {\n        out.push.apply(out, this.segments[i].boxIntersection(x, y, w, h));\n      }\n\n      return out;\n    }\n  }, {\n    key: \"boundingBoxIntersection\",\n    value: function boundingBoxIntersection(box) {\n      var out = [];\n\n      for (var i = 0; i < this.segments.length; i++) {\n        out.push.apply(out, this.segments[i].boundingBoxIntersection(box));\n      }\n\n      return out;\n    }\n  }, {\n    key: \"_updateSegmentProportions\",\n    value: function _updateSegmentProportions() {\n      var curLoc = 0;\n\n      for (var i = 0; i < this.segments.length; i++) {\n        var sl = this.segments[i].getLength();\n        this.segmentProportionalLengths[i] = sl / this.totalLength;\n        this.segmentProportions[i] = [curLoc, curLoc += sl / this.totalLength];\n      }\n    }\n  }, {\n    key: \"_findSegmentForLocation\",\n    value: function _findSegmentForLocation(location, absolute) {\n      var idx, i, inSegmentProportion;\n\n      if (absolute) {\n        location = location > 0 ? location / this.totalLength : (this.totalLength + location) / this.totalLength;\n      }\n\n      if (location === 1) {\n        idx = this.segments.length - 1;\n        inSegmentProportion = 1;\n      } else if (location === 0) {\n        inSegmentProportion = 0;\n        idx = 0;\n      } else {\n        if (location >= 0.5) {\n          idx = 0;\n          inSegmentProportion = 0;\n\n          for (i = this.segmentProportions.length - 1; i > -1; i--) {\n            if (this.segmentProportions[i][1] >= location && this.segmentProportions[i][0] <= location) {\n              idx = i;\n              inSegmentProportion = (location - this.segmentProportions[i][0]) / this.segmentProportionalLengths[i];\n              break;\n            }\n          }\n        } else {\n          idx = this.segmentProportions.length - 1;\n          inSegmentProportion = 1;\n\n          for (i = 0; i < this.segmentProportions.length; i++) {\n            if (this.segmentProportions[i][1] >= location) {\n              idx = i;\n              inSegmentProportion = (location - this.segmentProportions[i][0]) / this.segmentProportionalLengths[i];\n              break;\n            }\n          }\n        }\n      }\n\n      return {\n        segment: this.segments[idx],\n        proportion: inSegmentProportion,\n        index: idx\n      };\n    }\n  }, {\n    key: \"_addSegment\",\n    value: function _addSegment(clazz, params) {\n      if (params.x1 === params.x2 && params.y1 === params.y2) {\n        return;\n      }\n\n      var s = new clazz(params);\n      this.segments.push(s);\n      this.totalLength += s.getLength();\n      this.updateBounds(s);\n    }\n  }, {\n    key: \"_clearSegments\",\n    value: function _clearSegments() {\n      this.totalLength = 0;\n      this.segments.length = 0;\n      this.segmentProportions.length = 0;\n      this.segmentProportionalLengths.length = 0;\n    }\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      return this.totalLength;\n    }\n  }, {\n    key: \"_prepareCompute\",\n    value: function _prepareCompute(params) {\n      this.strokeWidth = params.strokeWidth;\n      var x1 = params.sourcePos.curX,\n          x2 = params.targetPos.curX,\n          y1 = params.sourcePos.curY,\n          y2 = params.targetPos.curY,\n          segment = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.quadrant)({\n        x: x1,\n        y: y1\n      }, {\n        x: x2,\n        y: y2\n      }),\n          swapX = x2 < x1,\n          swapY = y2 < y1,\n          so = [params.sourcePos.ox, params.sourcePos.oy],\n          to = [params.targetPos.ox, params.targetPos.oy],\n          x = swapX ? x2 : x1,\n          y = swapY ? y2 : y1,\n          w = Math.abs(x2 - x1),\n          h = Math.abs(y2 - y1);\n      var noSourceOrientation = so[0] === 0 && so[1] === 0;\n      var noTargetOrientation = to[0] === 0 && to[1] === 0;\n\n      if (noSourceOrientation || noTargetOrientation) {\n        var index = w > h ? 0 : 1,\n            oIndex = [1, 0][index],\n            v1 = index === 0 ? x1 : y1,\n            v2 = index === 0 ? x2 : y2;\n\n        if (noSourceOrientation) {\n          so[index] = v1 > v2 ? -1 : 1;\n          so[oIndex] = 0;\n        }\n\n        if (noTargetOrientation) {\n          to[index] = v1 > v2 ? 1 : -1;\n          to[oIndex] = 0;\n        }\n      }\n\n      var sx = swapX ? w + this.sourceGap * so[0] : this.sourceGap * so[0],\n          sy = swapY ? h + this.sourceGap * so[1] : this.sourceGap * so[1],\n          tx = swapX ? this.targetGap * to[0] : w + this.targetGap * to[0],\n          ty = swapY ? this.targetGap * to[1] : h + this.targetGap * to[1],\n          oProduct = so[0] * to[0] + so[1] * to[1];\n      var result = {\n        sx: sx,\n        sy: sy,\n        tx: tx,\n        ty: ty,\n        xSpan: Math.abs(tx - sx),\n        ySpan: Math.abs(ty - sy),\n        mx: (sx + tx) / 2,\n        my: (sy + ty) / 2,\n        so: so,\n        to: to,\n        x: x,\n        y: y,\n        w: w,\n        h: h,\n        segment: segment,\n        startStubX: sx + so[0] * this.sourceStub,\n        startStubY: sy + so[1] * this.sourceStub,\n        endStubX: tx + to[0] * this.targetStub,\n        endStubY: ty + to[1] * this.targetStub,\n        isXGreaterThanStubTimes2: Math.abs(sx - tx) > this.sourceStub + this.targetStub,\n        isYGreaterThanStubTimes2: Math.abs(sy - ty) > this.sourceStub + this.targetStub,\n        opposite: oProduct === -1,\n        perpendicular: oProduct === 0,\n        orthogonal: oProduct === 1,\n        sourceAxis: so[0] === 0 ? \"y\" : \"x\",\n        points: [x, y, w, h, sx, sy, tx, ty],\n        stubs: [this.sourceStub, this.targetStub]\n      };\n      result.anchorOrientation = result.opposite ? \"opposite\" : result.orthogonal ? \"orthogonal\" : \"perpendicular\";\n      return result;\n    }\n  }, {\n    key: \"updateBounds\",\n    value: function updateBounds(segment) {\n      var segBounds = segment.extents;\n      this.bounds.xmin = Math.min(this.bounds.xmin, segBounds.xmin);\n      this.bounds.xmax = Math.max(this.bounds.xmax, segBounds.xmax);\n      this.bounds.ymin = Math.min(this.bounds.ymin, segBounds.ymin);\n      this.bounds.ymax = Math.max(this.bounds.ymax, segBounds.ymax);\n    }\n  }, {\n    key: \"dumpSegmentsToConsole\",\n    value: function dumpSegmentsToConsole() {\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.log)(\"SEGMENTS:\");\n\n      for (var i = 0; i < this.segments.length; i++) {\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.log)(this.segments[i].type, \"\" + this.segments[i].getLength(), \"\" + this.segmentProportions[i]);\n      }\n    }\n  }, {\n    key: \"pointOnPath\",\n    value: function pointOnPath(location, absolute) {\n      var seg = this._findSegmentForLocation(location, absolute);\n\n      return seg.segment && seg.segment.pointOnPath(seg.proportion, false) || {\n        x: 0,\n        y: 0\n      };\n    }\n  }, {\n    key: \"gradientAtPoint\",\n    value: function gradientAtPoint(location, absolute) {\n      var seg = this._findSegmentForLocation(location, absolute);\n\n      return seg.segment && seg.segment.gradientAtPoint(seg.proportion, false) || 0;\n    }\n  }, {\n    key: \"pointAlongPathFrom\",\n    value: function pointAlongPathFrom(location, distance, absolute) {\n      var seg = this._findSegmentForLocation(location, absolute);\n\n      return seg.segment && seg.segment.pointAlongPathFrom(seg.proportion, distance, false) || {\n        x: 0,\n        y: 0\n      };\n    }\n  }, {\n    key: \"compute\",\n    value: function compute(params) {\n      this.paintInfo = this._prepareCompute(params);\n\n      this._clearSegments();\n\n      this._compute(this.paintInfo, params);\n\n      this.x = this.paintInfo.points[0];\n      this.y = this.paintInfo.points[1];\n      this.w = this.paintInfo.points[2];\n      this.h = this.paintInfo.points[3];\n      this.segment = this.paintInfo.segment;\n\n      this._updateSegmentProportions();\n    }\n  }, {\n    key: \"setAnchorOrientation\",\n    value: function setAnchorOrientation(idx, orientation) {}\n  }]);\n\n  return AbstractConnector;\n}();\n\nvar StraightSegment = function (_AbstractSegment) {\n  _inherits(StraightSegment, _AbstractSegment);\n\n  var _super = _createSuper(StraightSegment);\n\n  function StraightSegment(params) {\n    var _this;\n\n    _classCallCheck(this, StraightSegment);\n\n    _this = _super.call(this, params);\n\n    _defineProperty(_assertThisInitialized(_this), \"length\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"m\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"m2\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"type\", StraightSegment.segmentType);\n\n    _this._setCoordinates({\n      x1: params.x1,\n      y1: params.y1,\n      x2: params.x2,\n      y2: params.y2\n    });\n\n    return _this;\n  }\n\n  _createClass(StraightSegment, [{\n    key: \"getPath\",\n    value: function getPath(isFirstSegment) {\n      return (isFirstSegment ? \"M \" + this.x1 + \" \" + this.y1 + \" \" : \"\") + \"L \" + this.x2 + \" \" + this.y2;\n    }\n  }, {\n    key: \"_recalc\",\n    value: function _recalc() {\n      this.length = Math.sqrt(Math.pow(this.x2 - this.x1, 2) + Math.pow(this.y2 - this.y1, 2));\n      this.m = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.gradient)({\n        x: this.x1,\n        y: this.y1\n      }, {\n        x: this.x2,\n        y: this.y2\n      });\n      this.m2 = -1 / this.m;\n      this.extents = {\n        xmin: Math.min(this.x1, this.x2),\n        ymin: Math.min(this.y1, this.y2),\n        xmax: Math.max(this.x1, this.x2),\n        ymax: Math.max(this.y1, this.y2)\n      };\n    }\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      return this.length;\n    }\n  }, {\n    key: \"getGradient\",\n    value: function getGradient() {\n      return this.m;\n    }\n  }, {\n    key: \"_setCoordinates\",\n    value: function _setCoordinates(coords) {\n      this.x1 = coords.x1;\n      this.y1 = coords.y1;\n      this.x2 = coords.x2;\n      this.y2 = coords.y2;\n\n      this._recalc();\n    }\n  }, {\n    key: \"pointOnPath\",\n    value: function pointOnPath(location, absolute) {\n      if (location === 0 && !absolute) {\n        return {\n          x: this.x1,\n          y: this.y1\n        };\n      } else if (location === 1 && !absolute) {\n        return {\n          x: this.x2,\n          y: this.y2\n        };\n      } else {\n        var l = absolute ? location > 0 ? location : this.length + location : location * this.length;\n        return (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.pointOnLine)({\n          x: this.x1,\n          y: this.y1\n        }, {\n          x: this.x2,\n          y: this.y2\n        }, l);\n      }\n    }\n  }, {\n    key: \"gradientAtPoint\",\n    value: function gradientAtPoint(location, absolute) {\n      return this.m;\n    }\n  }, {\n    key: \"pointAlongPathFrom\",\n    value: function pointAlongPathFrom(location, distance, absolute) {\n      var p = this.pointOnPath(location, absolute),\n          farAwayPoint = distance <= 0 ? {\n        x: this.x1,\n        y: this.y1\n      } : {\n        x: this.x2,\n        y: this.y2\n      };\n\n      if (distance <= 0 && Math.abs(distance) > 1) {\n        distance *= -1;\n      }\n\n      return (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.pointOnLine)(p, farAwayPoint, distance);\n    }\n  }, {\n    key: \"within\",\n    value: function within(a, b, c) {\n      return c >= Math.min(a, b) && c <= Math.max(a, b);\n    }\n  }, {\n    key: \"closest\",\n    value: function closest(a, b, c) {\n      return Math.abs(c - a) < Math.abs(c - b) ? a : b;\n    }\n  }, {\n    key: \"findClosestPointOnPath\",\n    value: function findClosestPointOnPath(x, y) {\n      var out = {\n        d: Infinity,\n        x: null,\n        y: null,\n        l: null,\n        x1: this.x1,\n        x2: this.x2,\n        y1: this.y1,\n        y2: this.y2\n      };\n\n      if (this.m === 0) {\n        out.y = this.y1;\n        out.x = this.within(this.x1, this.x2, x) ? x : this.closest(this.x1, this.x2, x);\n      } else if (this.m === Infinity || this.m === -Infinity) {\n        out.x = this.x1;\n        out.y = this.within(this.y1, this.y2, y) ? y : this.closest(this.y1, this.y2, y);\n      } else {\n        var b = this.y1 - this.m * this.x1,\n            b2 = y - this.m2 * x,\n            _x1 = (b2 - b) / (this.m - this.m2),\n            _y1 = this.m * _x1 + b;\n\n        out.x = this.within(this.x1, this.x2, _x1) ? _x1 : this.closest(this.x1, this.x2, _x1);\n        out.y = this.within(this.y1, this.y2, _y1) ? _y1 : this.closest(this.y1, this.y2, _y1);\n      }\n\n      var fractionInSegment = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.lineLength)({\n        x: out.x,\n        y: out.y\n      }, {\n        x: this.x1,\n        y: this.y1\n      });\n      out.d = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.lineLength)({\n        x: x,\n        y: y\n      }, out);\n      out.l = fractionInSegment / length;\n      return out;\n    }\n  }, {\n    key: \"_pointLiesBetween\",\n    value: function _pointLiesBetween(q, p1, p2) {\n      return p2 > p1 ? p1 <= q && q <= p2 : p1 >= q && q >= p2;\n    }\n  }, {\n    key: \"lineIntersection\",\n    value: function lineIntersection(_x1, _y1, _x2, _y2) {\n      var m2 = Math.abs((0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.gradient)({\n        x: _x1,\n        y: _y1\n      }, {\n        x: _x2,\n        y: _y2\n      })),\n          m1 = Math.abs(this.m),\n          b = m1 === Infinity ? this.x1 : this.y1 - m1 * this.x1,\n          out = [],\n          b2 = m2 === Infinity ? _x1 : _y1 - m2 * _x1;\n\n      if (m2 !== m1) {\n        if (m2 === Infinity && m1 === 0) {\n          if (this._pointLiesBetween(_x1, this.x1, this.x2) && this._pointLiesBetween(this.y1, _y1, _y2)) {\n            out.push({\n              x: _x1,\n              y: this.y1\n            });\n          }\n        } else if (m2 === 0 && m1 === Infinity) {\n          if (this._pointLiesBetween(_y1, this.y1, this.y2) && this._pointLiesBetween(this.x1, _x1, _x2)) {\n            out.push({\n              x: this.x1,\n              y: _y1\n            });\n          }\n        } else {\n          var X, Y;\n\n          if (m2 === Infinity) {\n            X = _x1;\n\n            if (this._pointLiesBetween(X, this.x1, this.x2)) {\n              Y = m1 * _x1 + b;\n\n              if (this._pointLiesBetween(Y, _y1, _y2)) {\n                out.push({\n                  x: X,\n                  y: Y\n                });\n              }\n            }\n          } else if (m2 === 0) {\n            Y = _y1;\n\n            if (this._pointLiesBetween(Y, this.y1, this.y2)) {\n              X = (_y1 - b) / m1;\n\n              if (this._pointLiesBetween(X, _x1, _x2)) {\n                out.push({\n                  x: X,\n                  y: Y\n                });\n              }\n            }\n          } else {\n            X = (b2 - b) / (m1 - m2);\n            Y = m1 * X + b;\n\n            if (this._pointLiesBetween(X, this.x1, this.x2) && this._pointLiesBetween(Y, this.y1, this.y2)) {\n              out.push({\n                x: X,\n                y: Y\n              });\n            }\n          }\n        }\n      }\n\n      return out;\n    }\n  }, {\n    key: \"boxIntersection\",\n    value: function boxIntersection(x, y, w, h) {\n      var a = [];\n      a.push.apply(a, this.lineIntersection(x, y, x + w, y));\n      a.push.apply(a, this.lineIntersection(x + w, y, x + w, y + h));\n      a.push.apply(a, this.lineIntersection(x + w, y + h, x, y + h));\n      a.push.apply(a, this.lineIntersection(x, y + h, x, y));\n      return a;\n    }\n  }]);\n\n  return StraightSegment;\n}(_jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.AbstractSegment);\n\n_defineProperty(StraightSegment, \"segmentType\", \"Straight\");\n\nvar StraightConnector = function (_AbstractConnector) {\n  _inherits(StraightConnector, _AbstractConnector);\n\n  var _super = _createSuper(StraightConnector);\n\n  function StraightConnector() {\n    var _this;\n\n    _classCallCheck(this, StraightConnector);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"type\", StraightConnector.type);\n\n    return _this;\n  }\n\n  _createClass(StraightConnector, [{\n    key: \"getDefaultStubs\",\n    value: function getDefaultStubs() {\n      return [0, 0];\n    }\n  }, {\n    key: \"_compute\",\n    value: function _compute(paintInfo, p) {\n      this._addSegment(StraightSegment, {\n        x1: paintInfo.sx,\n        y1: paintInfo.sy,\n        x2: paintInfo.startStubX,\n        y2: paintInfo.startStubY\n      });\n\n      this._addSegment(StraightSegment, {\n        x1: paintInfo.startStubX,\n        y1: paintInfo.startStubY,\n        x2: paintInfo.endStubX,\n        y2: paintInfo.endStubY\n      });\n\n      this._addSegment(StraightSegment, {\n        x1: paintInfo.endStubX,\n        y1: paintInfo.endStubY,\n        x2: paintInfo.tx,\n        y2: paintInfo.ty\n      });\n\n      this.geometry = {\n        source: p.sourcePos,\n        target: p.targetPos\n      };\n    }\n  }, {\n    key: \"transformGeometry\",\n    value: function transformGeometry(g, dx, dy) {\n      return {\n        source: this.transformAnchorPlacement(g.source, dx, dy),\n        target: this.transformAnchorPlacement(g.target, dx, dy)\n      };\n    }\n  }]);\n\n  return StraightConnector;\n}(AbstractConnector);\n\n_defineProperty(StraightConnector, \"type\", \"Straight\");\n\nvar connectorMap = {};\nvar Connectors = {\n  get: function get(connection, name, params) {\n    var c = connectorMap[name];\n\n    if (!c) {\n      throw {\n        message: \"jsPlumb: unknown connector type '\" + name + \"'\"\n      };\n    } else {\n      return new c(connection, params);\n    }\n  },\n  register: function register(name, conn) {\n    connectorMap[name] = conn;\n  }\n};\n\nfunction cls() {\n  for (var _len = arguments.length, className = new Array(_len), _key = 0; _key < _len; _key++) {\n    className[_key] = arguments[_key];\n  }\n\n  return className.map(function (cn) {\n    return \".\" + cn;\n  }).join(\",\");\n}\n\nfunction classList() {\n  for (var _len2 = arguments.length, className = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    className[_key2] = arguments[_key2];\n  }\n\n  return className.join(\" \");\n}\n\nfunction att() {\n  for (var _len3 = arguments.length, attName = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    attName[_key3] = arguments[_key3];\n  }\n\n  return attName.map(function (an) {\n    return \"[\" + an + \"]\";\n  }).join(\",\");\n}\n\nvar SOURCE = \"source\";\nvar TARGET = \"target\";\nvar BLOCK = \"block\";\nvar NONE = \"none\";\nvar SOURCE_INDEX = 0;\nvar TARGET_INDEX = 1;\nvar ABSOLUTE = \"absolute\";\nvar FIXED = \"fixed\";\nvar STATIC = \"static\";\nvar ATTRIBUTE_GROUP = \"data-jtk-group\";\nvar ATTRIBUTE_MANAGED = \"data-jtk-managed\";\nvar ATTRIBUTE_NOT_DRAGGABLE = \"data-jtk-not-draggable\";\nvar ATTRIBUTE_TABINDEX = \"tabindex\";\nvar ATTRIBUTE_SCOPE = \"data-jtk-scope\";\nvar ATTRIBUTE_SCOPE_PREFIX = ATTRIBUTE_SCOPE + \"-\";\nvar CHECK_CONDITION = \"checkCondition\";\nvar CHECK_DROP_ALLOWED = \"checkDropAllowed\";\nvar CLASS_CONNECTOR = \"jtk-connector\";\nvar CLASS_CONNECTOR_OUTLINE = \"jtk-connector-outline\";\nvar CLASS_CONNECTED = \"jtk-connected\";\nvar CLASS_ENDPOINT = \"jtk-endpoint\";\nvar CLASS_ENDPOINT_CONNECTED = \"jtk-endpoint-connected\";\nvar CLASS_ENDPOINT_FULL = \"jtk-endpoint-full\";\nvar CLASS_ENDPOINT_DROP_ALLOWED = \"jtk-endpoint-drop-allowed\";\nvar CLASS_ENDPOINT_DROP_FORBIDDEN = \"jtk-endpoint-drop-forbidden\";\nvar CLASS_ENDPOINT_ANCHOR_PREFIX = \"jtk-endpoint-anchor\";\nvar CLASS_GROUP_COLLAPSED = \"jtk-group-collapsed\";\nvar CLASS_GROUP_EXPANDED = \"jtk-group-expanded\";\nvar CLASS_OVERLAY = \"jtk-overlay\";\nvar EVENT_ANCHOR_CHANGED = \"anchor:changed\";\nvar EVENT_CONNECTION = \"connection\";\nvar EVENT_INTERNAL_CONNECTION = \"internal.connection\";\nvar EVENT_CONNECTION_DETACHED = \"connection:detach\";\nvar EVENT_CONNECTION_MOVED = \"connection:move\";\nvar EVENT_CONTAINER_CHANGE = \"container:change\";\nvar EVENT_ENDPOINT_REPLACED = \"endpoint:replaced\";\nvar EVENT_INTERNAL_ENDPOINT_UNREGISTERED = \"internal.endpoint:unregistered\";\nvar EVENT_INTERNAL_CONNECTION_DETACHED = \"internal.connection:detached\";\nvar EVENT_MANAGE_ELEMENT = \"element:manage\";\nvar EVENT_GROUP_ADDED = \"group:added\";\nvar EVENT_GROUP_COLLAPSE = \"group:collapse\";\nvar EVENT_GROUP_EXPAND = \"group:expand\";\nvar EVENT_GROUP_MEMBER_ADDED = \"group:member:added\";\nvar EVENT_GROUP_MEMBER_REMOVED = \"group:member:removed\";\nvar EVENT_GROUP_REMOVED = \"group:removed\";\nvar EVENT_MAX_CONNECTIONS = \"maxConnections\";\nvar EVENT_NESTED_GROUP_ADDED = \"group:nested:added\";\nvar EVENT_NESTED_GROUP_REMOVED = \"group:nested:removed\";\nvar EVENT_UNMANAGE_ELEMENT = \"element:unmanage\";\nvar EVENT_ZOOM = \"zoom\";\nvar IS_DETACH_ALLOWED = \"isDetachAllowed\";\nvar INTERCEPT_BEFORE_DRAG = \"beforeDrag\";\nvar INTERCEPT_BEFORE_DROP = \"beforeDrop\";\nvar INTERCEPT_BEFORE_DETACH = \"beforeDetach\";\nvar INTERCEPT_BEFORE_START_DETACH = \"beforeStartDetach\";\nvar SELECTOR_MANAGED_ELEMENT = att(ATTRIBUTE_MANAGED);\nvar ERROR_SOURCE_ENDPOINT_FULL = \"Cannot establish connection: source endpoint is full\";\nvar ERROR_TARGET_ENDPOINT_FULL = \"Cannot establish connection: target endpoint is full\";\nvar ERROR_SOURCE_DOES_NOT_EXIST = \"Cannot establish connection: source does not exist\";\nvar ERROR_TARGET_DOES_NOT_EXIST = \"Cannot establish connection: target does not exist\";\nvar KEY_CONNECTION_OVERLAYS = \"connectionOverlays\";\n\nfunction isFullOverlaySpec(o) {\n  return o.type != null && o.options != null;\n}\n\nfunction convertToFullOverlaySpec(spec) {\n  var o = null;\n\n  if ((0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.isString)(spec)) {\n    o = {\n      type: spec,\n      options: {}\n    };\n  } else {\n    o = spec;\n  }\n\n  o.options.id = o.options.id || (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.uuid)();\n  return o;\n}\n\nvar Overlay = function (_EventGenerator) {\n  _inherits(Overlay, _EventGenerator);\n\n  var _super = _createSuper(Overlay);\n\n  function Overlay(instance, component, p) {\n    var _this;\n\n    _classCallCheck(this, Overlay);\n\n    _this = _super.call(this);\n    _this.instance = instance;\n    _this.component = component;\n\n    _defineProperty(_assertThisInitialized(_this), \"id\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"type\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"cssClass\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"visible\", true);\n\n    _defineProperty(_assertThisInitialized(_this), \"location\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"events\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"attributes\", void 0);\n\n    p = p || {};\n    _this.id = p.id || (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.uuid)();\n    _this.cssClass = p.cssClass || \"\";\n    _this.location = p.location || 0.5;\n    _this.events = p.events || {};\n    _this.attributes = p.attributes || {};\n\n    for (var _event in _this.events) {\n      _this.bind(_event, _this.events[_event]);\n    }\n\n    return _this;\n  }\n\n  _createClass(Overlay, [{\n    key: \"shouldFireEvent\",\n    value: function shouldFireEvent(event, value, originalEvent) {\n      return true;\n    }\n  }, {\n    key: \"setVisible\",\n    value: function setVisible(v) {\n      this.visible = v;\n      this.instance.setOverlayVisible(this, v);\n    }\n  }, {\n    key: \"isVisible\",\n    value: function isVisible() {\n      return this.visible;\n    }\n  }]);\n\n  return Overlay;\n}(_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.EventGenerator);\n\nvar overlayMap = {};\nvar OverlayFactory = {\n  get: function get(instance, name, component, params) {\n    var c = overlayMap[name];\n\n    if (!c) {\n      throw {\n        message: \"jsPlumb: unknown overlay type '\" + name + \"'\"\n      };\n    } else {\n      return new c(instance, component, params);\n    }\n  },\n  register: function register(name, overlay) {\n    overlayMap[name] = overlay;\n  }\n};\n\nvar LabelOverlay = function (_Overlay) {\n  _inherits(LabelOverlay, _Overlay);\n\n  var _super = _createSuper(LabelOverlay);\n\n  function LabelOverlay(instance, component, p) {\n    var _this;\n\n    _classCallCheck(this, LabelOverlay);\n\n    _this = _super.call(this, instance, component, p);\n    _this.instance = instance;\n    _this.component = component;\n\n    _defineProperty(_assertThisInitialized(_this), \"label\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"labelText\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"type\", LabelOverlay.type);\n\n    _defineProperty(_assertThisInitialized(_this), \"cachedDimensions\", void 0);\n\n    p = p || {\n      label: \"\"\n    };\n\n    _this.setLabel(p.label);\n\n    return _this;\n  }\n\n  _createClass(LabelOverlay, [{\n    key: \"getLabel\",\n    value: function getLabel() {\n      if ((0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(this.label)) {\n        return this.label(this);\n      } else {\n        return this.labelText;\n      }\n    }\n  }, {\n    key: \"setLabel\",\n    value: function setLabel(l) {\n      this.label = l;\n      this.labelText = null;\n      this.instance.updateLabel(this);\n    }\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return {\n        w: 1,\n        h: 1\n      };\n    }\n  }, {\n    key: \"updateFrom\",\n    value: function updateFrom(d) {\n      if (d.label != null) {\n        this.setLabel(d.label);\n      }\n    }\n  }]);\n\n  return LabelOverlay;\n}(Overlay);\n\n_defineProperty(LabelOverlay, \"type\", \"Label\");\n\nfunction isLabelOverlay(o) {\n  return o.type === LabelOverlay.type;\n}\n\nOverlayFactory.register(\"Label\", LabelOverlay);\n\nfunction _splitType(t) {\n  return t == null ? null : t.split(\" \");\n}\n\nfunction _mapType(map, obj, typeId) {\n  for (var i in obj) {\n    map[i] = typeId;\n  }\n}\n\nvar CONNECTOR = \"connector\";\nvar MERGE_STRATEGY_OVERRIDE = \"override\";\nvar CSS_CLASS = \"cssClass\";\nvar DEFAULT_TYPE_KEY = \"__default\";\nvar ANCHOR = \"anchor\";\nvar ANCHORS = \"anchors\";\nvar _internalLabelOverlayId = \"__label\";\nvar TYPE_ITEM_OVERLAY = \"overlay\";\nvar LOCATION_ATTRIBUTE = \"labelLocation\";\nvar ACTION_ADD = \"add\";\nvar ACTION_REMOVE = \"remove\";\n\nfunction _applyTypes(component, params) {\n  if (component.getDefaultType) {\n    var td = component.getTypeDescriptor(),\n        map = {};\n    var defType = component.getDefaultType();\n    var o = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, defType);\n\n    _mapType(map, defType, DEFAULT_TYPE_KEY);\n\n    for (var i = 0, j = component._types.length; i < j; i++) {\n      var tid = component._types[i];\n\n      if (tid !== DEFAULT_TYPE_KEY) {\n        var _t = component.instance.getType(tid, td);\n\n        if (_t != null) {\n          var overrides = new Set([CONNECTOR, ANCHOR, ANCHORS]);\n\n          if (_t.mergeStrategy === MERGE_STRATEGY_OVERRIDE) {\n            for (var k in _t) {\n              overrides.add(k);\n            }\n          }\n\n          o = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.merge)(o, _t, [CSS_CLASS], (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.setToArray)(overrides));\n\n          _mapType(map, _t, tid);\n        }\n      }\n    }\n\n    if (params) {\n      o = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.populate)(o, params, \"_\");\n    }\n\n    component.applyType(o, map);\n  }\n}\n\nfunction _removeTypeCssHelper(component, typeIndex) {\n  var typeId = component._types[typeIndex],\n      type = component.instance.getType(typeId, component.getTypeDescriptor());\n\n  if (type != null && type.cssClass) {\n    component.removeClass(type.cssClass);\n  }\n}\n\nfunction _updateHoverStyle(component) {\n  if (component.paintStyle && component.hoverPaintStyle) {\n    var mergedHoverStyle = {};\n    (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)(mergedHoverStyle, component.paintStyle);\n    (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)(mergedHoverStyle, component.hoverPaintStyle);\n    component.hoverPaintStyle = mergedHoverStyle;\n  }\n}\n\nfunction _makeLabelOverlay(component, params) {\n  var _params = {\n    cssClass: params.cssClass,\n    id: _internalLabelOverlayId,\n    component: component\n  },\n      mergedParams = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)(_params, params);\n  return new LabelOverlay(component.instance, component, mergedParams);\n}\n\nfunction _processOverlay(component, o) {\n  var _newOverlay = null;\n\n  if ((0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.isString)(o)) {\n    _newOverlay = OverlayFactory.get(component.instance, o, component, {});\n  } else if (o.type != null && o.options != null) {\n    var oa = o;\n    var p = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, oa.options);\n    _newOverlay = OverlayFactory.get(component.instance, oa.type, component, p);\n  } else {\n    _newOverlay = o;\n  }\n\n  _newOverlay.id = _newOverlay.id || (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.uuid)();\n  component.cacheTypeItem(TYPE_ITEM_OVERLAY, _newOverlay, _newOverlay.id);\n  component.overlays[_newOverlay.id] = _newOverlay;\n  return _newOverlay;\n}\n\nvar Component = function (_EventGenerator) {\n  _inherits(Component, _EventGenerator);\n\n  var _super = _createSuper(Component);\n\n  function Component(instance, params) {\n    var _this;\n\n    _classCallCheck(this, Component);\n\n    _this = _super.call(this);\n    _this.instance = instance;\n\n    _defineProperty(_assertThisInitialized(_this), \"defaultLabelLocation\", 0.5);\n\n    _defineProperty(_assertThisInitialized(_this), \"overlays\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"overlayPositions\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"overlayPlacements\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"clone\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"deleted\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"segment\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"x\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"y\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"w\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"h\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"id\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"visible\", true);\n\n    _defineProperty(_assertThisInitialized(_this), \"typeId\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"params\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"paintStyle\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"hoverPaintStyle\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"paintStyleInUse\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_hover\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"lastPaintedAt\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"data\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_defaultType\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"events\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"parameters\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_types\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_typeCache\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"cssClass\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"hoverClass\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"beforeDetach\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"beforeDrop\", void 0);\n\n    params = params || {};\n    _this.cssClass = params.cssClass || \"\";\n    _this.hoverClass = params.hoverClass || instance.defaults.hoverClass;\n    _this.beforeDetach = params.beforeDetach;\n    _this.beforeDrop = params.beforeDrop;\n    _this._types = [];\n    _this._typeCache = {};\n    _this.parameters = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.clone)(params.parameters || {});\n    _this.id = params.id || _this.getIdPrefix() + new Date().getTime();\n    _this._defaultType = {\n      parameters: _this.parameters,\n      scope: params.scope || _this.instance.defaultScope,\n      overlays: {}\n    };\n\n    if (params.events) {\n      for (var evtName in params.events) {\n        _this.bind(evtName, params.events[evtName]);\n      }\n    }\n\n    _this.clone = function () {\n      var o = Object.create(_this.constructor.prototype);\n\n      _this.constructor.apply(o, [instance, params]);\n\n      return o;\n    };\n\n    _this.overlays = {};\n    _this.overlayPositions = {};\n    var o = params.overlays || [],\n        oo = {};\n\n    var defaultOverlayKey = _this.getDefaultOverlayKey();\n\n    if (defaultOverlayKey) {\n      var defaultOverlays = _this.instance.defaults[defaultOverlayKey];\n\n      if (defaultOverlays) {\n        o.push.apply(o, _toConsumableArray(defaultOverlays));\n      }\n\n      for (var i = 0; i < o.length; i++) {\n        var fo = convertToFullOverlaySpec(o[i]);\n        oo[fo.options.id] = fo;\n      }\n    }\n\n    _this._defaultType.overlays = oo;\n\n    if (params.label) {\n      _this.getDefaultType().overlays[_internalLabelOverlayId] = {\n        type: LabelOverlay.type,\n        options: {\n          label: params.label,\n          location: params.labelLocation || _this.defaultLabelLocation,\n          id: _internalLabelOverlayId\n        }\n      };\n    }\n\n    return _this;\n  }\n\n  _createClass(Component, [{\n    key: \"isDetachAllowed\",\n    value: function isDetachAllowed(connection) {\n      var r = true;\n\n      if (this.beforeDetach) {\n        try {\n          r = this.beforeDetach(connection);\n        } catch (e) {\n          (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.log)(\"jsPlumb: beforeDetach callback failed\", e);\n        }\n      }\n\n      return r;\n    }\n  }, {\n    key: \"isDropAllowed\",\n    value: function isDropAllowed(sourceId, targetId, scope, connection, dropEndpoint) {\n      var r;\n      var payload = {\n        sourceId: sourceId,\n        targetId: targetId,\n        scope: scope,\n        connection: connection,\n        dropEndpoint: dropEndpoint\n      };\n\n      if (this.beforeDrop) {\n        try {\n          r = this.beforeDrop(payload);\n        } catch (e) {\n          (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.log)(\"jsPlumb: beforeDrop callback failed\", e);\n        }\n      } else {\n        r = this.instance.checkCondition(INTERCEPT_BEFORE_DROP, payload);\n      }\n\n      return r;\n    }\n  }, {\n    key: \"getDefaultType\",\n    value: function getDefaultType() {\n      return this._defaultType;\n    }\n  }, {\n    key: \"appendToDefaultType\",\n    value: function appendToDefaultType(obj) {\n      for (var i in obj) {\n        this._defaultType[i] = obj[i];\n      }\n    }\n  }, {\n    key: \"getId\",\n    value: function getId() {\n      return this.id;\n    }\n  }, {\n    key: \"cacheTypeItem\",\n    value: function cacheTypeItem(key, item, typeId) {\n      this._typeCache[typeId] = this._typeCache[typeId] || {};\n      this._typeCache[typeId][key] = item;\n    }\n  }, {\n    key: \"getCachedTypeItem\",\n    value: function getCachedTypeItem(key, typeId) {\n      return this._typeCache[typeId] ? this._typeCache[typeId][key] : null;\n    }\n  }, {\n    key: \"setType\",\n    value: function setType(typeId, params) {\n      this.clearTypes();\n      this._types = _splitType(typeId) || [];\n\n      _applyTypes(this, params);\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return this._types;\n    }\n  }, {\n    key: \"reapplyTypes\",\n    value: function reapplyTypes(params) {\n      _applyTypes(this, params);\n    }\n  }, {\n    key: \"hasType\",\n    value: function hasType(typeId) {\n      return this._types.indexOf(typeId) !== -1;\n    }\n  }, {\n    key: \"addType\",\n    value: function addType(typeId, params) {\n      var t = _splitType(typeId),\n          _somethingAdded = false;\n\n      if (t != null) {\n        for (var i = 0, j = t.length; i < j; i++) {\n          if (!this.hasType(t[i])) {\n            this._types.push(t[i]);\n\n            _somethingAdded = true;\n          }\n        }\n\n        if (_somethingAdded) {\n          _applyTypes(this, params);\n        }\n      }\n    }\n  }, {\n    key: \"removeType\",\n    value: function removeType(typeId, params) {\n      var _this2 = this;\n\n      var t = _splitType(typeId),\n          _cont = false,\n          _one = function _one(tt) {\n        var idx = _this2._types.indexOf(tt);\n\n        if (idx !== -1) {\n          _removeTypeCssHelper(_this2, idx);\n\n          _this2._types.splice(idx, 1);\n\n          return true;\n        }\n\n        return false;\n      };\n\n      if (t != null) {\n        for (var i = 0, j = t.length; i < j; i++) {\n          _cont = _one(t[i]) || _cont;\n        }\n\n        if (_cont) {\n          _applyTypes(this, params);\n        }\n      }\n    }\n  }, {\n    key: \"clearTypes\",\n    value: function clearTypes(params, doNotRepaint) {\n      var i = this._types.length;\n\n      for (var j = 0; j < i; j++) {\n        _removeTypeCssHelper(this, 0);\n\n        this._types.splice(0, 1);\n      }\n\n      _applyTypes(this, params);\n    }\n  }, {\n    key: \"toggleType\",\n    value: function toggleType(typeId, params) {\n      var t = _splitType(typeId);\n\n      if (t != null) {\n        for (var i = 0, j = t.length; i < j; i++) {\n          var idx = this._types.indexOf(t[i]);\n\n          if (idx !== -1) {\n            _removeTypeCssHelper(this, idx);\n\n            this._types.splice(idx, 1);\n          } else {\n            this._types.push(t[i]);\n          }\n        }\n\n        _applyTypes(this, params);\n      }\n    }\n  }, {\n    key: \"applyType\",\n    value: function applyType(t, params) {\n      this.setPaintStyle(t.paintStyle);\n      this.setHoverPaintStyle(t.hoverPaintStyle);\n      this.mergeParameters(t.parameters);\n      this.paintStyleInUse = this.getPaintStyle();\n\n      if (t.overlays) {\n        var keep = {},\n            i;\n\n        for (i in t.overlays) {\n          var existing = this.overlays[t.overlays[i].options.id];\n\n          if (existing) {\n            existing.updateFrom(t.overlays[i].options);\n            keep[t.overlays[i].options.id] = true;\n            this.instance.reattachOverlay(existing, this);\n          } else {\n            var _c = this.getCachedTypeItem(\"overlay\", t.overlays[i].options.id);\n\n            if (_c != null) {\n              this.instance.reattachOverlay(_c, this);\n\n              _c.setVisible(true);\n\n              _c.updateFrom(t.overlays[i].options);\n\n              this.overlays[_c.id] = _c;\n            } else {\n              _c = this.addOverlay(t.overlays[i]);\n            }\n\n            keep[_c.id] = true;\n          }\n        }\n\n        for (i in this.overlays) {\n          if (keep[this.overlays[i].id] == null) {\n            this.removeOverlay(this.overlays[i].id, true);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"setPaintStyle\",\n    value: function setPaintStyle(style) {\n      this.paintStyle = style;\n      this.paintStyleInUse = this.paintStyle;\n\n      _updateHoverStyle(this);\n    }\n  }, {\n    key: \"getPaintStyle\",\n    value: function getPaintStyle() {\n      return this.paintStyle;\n    }\n  }, {\n    key: \"setHoverPaintStyle\",\n    value: function setHoverPaintStyle(style) {\n      this.hoverPaintStyle = style;\n\n      _updateHoverStyle(this);\n    }\n  }, {\n    key: \"getHoverPaintStyle\",\n    value: function getHoverPaintStyle() {\n      return this.hoverPaintStyle;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      for (var i in this.overlays) {\n        this.instance.destroyOverlay(this.overlays[i]);\n      }\n\n      this.overlays = {};\n      this.overlayPositions = {};\n      this.unbind();\n      this.clone = null;\n    }\n  }, {\n    key: \"isHover\",\n    value: function isHover() {\n      return this._hover;\n    }\n  }, {\n    key: \"mergeParameters\",\n    value: function mergeParameters(p) {\n      if (p != null) {\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)(this.parameters, p);\n      }\n    }\n  }, {\n    key: \"setVisible\",\n    value: function setVisible(v) {\n      this.visible = v;\n\n      if (v) {\n        this.showOverlays();\n      } else {\n        this.hideOverlays();\n      }\n    }\n  }, {\n    key: \"isVisible\",\n    value: function isVisible() {\n      return this.visible;\n    }\n  }, {\n    key: \"setAbsoluteOverlayPosition\",\n    value: function setAbsoluteOverlayPosition(overlay, xy) {\n      this.overlayPositions[overlay.id] = xy;\n    }\n  }, {\n    key: \"getAbsoluteOverlayPosition\",\n    value: function getAbsoluteOverlayPosition(overlay) {\n      return this.overlayPositions ? this.overlayPositions[overlay.id] : null;\n    }\n  }, {\n    key: \"_clazzManip\",\n    value: function _clazzManip(action, clazz) {\n      for (var i in this.overlays) {\n        if (action === ACTION_ADD) {\n          this.instance.addOverlayClass(this.overlays[i], clazz);\n        } else if (action === ACTION_REMOVE) {\n          this.instance.removeOverlayClass(this.overlays[i], clazz);\n        }\n      }\n    }\n  }, {\n    key: \"addClass\",\n    value: function addClass(clazz, cascade) {\n      var parts = (this.cssClass || \"\").split(\" \");\n      parts.push(clazz);\n      this.cssClass = parts.join(\" \");\n\n      this._clazzManip(ACTION_ADD, clazz);\n    }\n  }, {\n    key: \"removeClass\",\n    value: function removeClass(clazz, cascade) {\n      var parts = (this.cssClass || \"\").split(\" \");\n      this.cssClass = parts.filter(function (p) {\n        return p !== clazz;\n      }).join(\" \");\n\n      this._clazzManip(ACTION_REMOVE, clazz);\n    }\n  }, {\n    key: \"getClass\",\n    value: function getClass() {\n      return this.cssClass;\n    }\n  }, {\n    key: \"shouldFireEvent\",\n    value: function shouldFireEvent(event, value, originalEvent) {\n      return true;\n    }\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      return this.data;\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(d) {\n      this.data = d || {};\n    }\n  }, {\n    key: \"mergeData\",\n    value: function mergeData(d) {\n      this.data = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)(this.data, d);\n    }\n  }, {\n    key: \"addOverlay\",\n    value: function addOverlay(overlay) {\n      var o = _processOverlay(this, overlay);\n\n      if (this.getData && o.type === LabelOverlay.type && !(0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.isString)(overlay)) {\n        var d = this.getData(),\n            p = overlay.options;\n\n        if (d) {\n          var locationAttribute = p.labelLocationAttribute || LOCATION_ATTRIBUTE;\n          var loc = d[locationAttribute];\n\n          if (loc) {\n            o.location = loc;\n          }\n        }\n      }\n\n      return o;\n    }\n  }, {\n    key: \"getOverlay\",\n    value: function getOverlay(id) {\n      return this.overlays[id];\n    }\n  }, {\n    key: \"getOverlays\",\n    value: function getOverlays() {\n      return this.overlays;\n    }\n  }, {\n    key: \"hideOverlay\",\n    value: function hideOverlay(id) {\n      var o = this.getOverlay(id);\n\n      if (o) {\n        o.setVisible(false);\n      }\n    }\n  }, {\n    key: \"hideOverlays\",\n    value: function hideOverlays() {\n      for (var _len = arguments.length, ids = new Array(_len), _key = 0; _key < _len; _key++) {\n        ids[_key] = arguments[_key];\n      }\n\n      ids = ids || [];\n\n      for (var i in this.overlays) {\n        if (ids.length === 0 || ids.indexOf(i) !== -1) {\n          this.overlays[i].setVisible(false);\n        }\n      }\n    }\n  }, {\n    key: \"showOverlay\",\n    value: function showOverlay(id) {\n      var o = this.getOverlay(id);\n\n      if (o) {\n        o.setVisible(true);\n      }\n    }\n  }, {\n    key: \"showOverlays\",\n    value: function showOverlays() {\n      for (var _len2 = arguments.length, ids = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        ids[_key2] = arguments[_key2];\n      }\n\n      ids = ids || [];\n\n      for (var i in this.overlays) {\n        if (ids.length === 0 || ids.indexOf(i) !== -1) {\n          this.overlays[i].setVisible(true);\n        }\n      }\n    }\n  }, {\n    key: \"removeAllOverlays\",\n    value: function removeAllOverlays() {\n      for (var i in this.overlays) {\n        this.instance.destroyOverlay(this.overlays[i]);\n      }\n\n      this.overlays = {};\n      this.overlayPositions = null;\n      this.overlayPlacements = {};\n    }\n  }, {\n    key: \"removeOverlay\",\n    value: function removeOverlay(overlayId, dontCleanup) {\n      var o = this.overlays[overlayId];\n\n      if (o) {\n        o.setVisible(false);\n\n        if (!dontCleanup) {\n          this.instance.destroyOverlay(o);\n        }\n\n        delete this.overlays[overlayId];\n\n        if (this.overlayPositions) {\n          delete this.overlayPositions[overlayId];\n        }\n\n        if (this.overlayPlacements) {\n          delete this.overlayPlacements[overlayId];\n        }\n      }\n    }\n  }, {\n    key: \"removeOverlays\",\n    value: function removeOverlays() {\n      for (var _len3 = arguments.length, overlays = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        overlays[_key3] = arguments[_key3];\n      }\n\n      for (var i = 0, j = overlays.length; i < j; i++) {\n        this.removeOverlay(arguments[i]);\n      }\n    }\n  }, {\n    key: \"getLabel\",\n    value: function getLabel() {\n      var lo = this.getLabelOverlay();\n      return lo != null ? lo.getLabel() : null;\n    }\n  }, {\n    key: \"getLabelOverlay\",\n    value: function getLabelOverlay() {\n      return this.getOverlay(_internalLabelOverlayId);\n    }\n  }, {\n    key: \"setLabel\",\n    value: function setLabel(l) {\n      var lo = this.getLabelOverlay();\n\n      if (!lo) {\n        var _params2 = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.isString)(l) || (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(l) ? {\n          label: l\n        } : l;\n\n        lo = _makeLabelOverlay(this, _params2);\n        this.overlays[_internalLabelOverlayId] = lo;\n      } else {\n        if ((0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.isString)(l) || (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(l)) {\n          lo.setLabel(l);\n        } else {\n          var ll = l;\n\n          if (ll.label) {\n            lo.setLabel(ll.label);\n          }\n\n          if (ll.location) {\n            lo.location = ll.location;\n          }\n        }\n      }\n    }\n  }]);\n\n  return Component;\n}(_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.EventGenerator);\n\nvar _opposites, _clockwiseOptions, _antiClockwiseOptions;\n\nvar FaceValues;\n\n(function (FaceValues) {\n  FaceValues[\"top\"] = \"top\";\n  FaceValues[\"left\"] = \"left\";\n  FaceValues[\"right\"] = \"right\";\n  FaceValues[\"bottom\"] = \"bottom\";\n})(FaceValues || (FaceValues = {}));\n\nvar TOP = FaceValues.top;\nvar LEFT = FaceValues.left;\nvar RIGHT = FaceValues.right;\nvar BOTTOM = FaceValues.bottom;\nvar X_AXIS_FACES = [LEFT, RIGHT];\nvar Y_AXIS_FACES = [TOP, BOTTOM];\n\nvar LightweightFloatingAnchor = function () {\n  function LightweightFloatingAnchor(instance, element) {\n    _classCallCheck(this, LightweightFloatingAnchor);\n\n    this.instance = instance;\n    this.element = element;\n\n    _defineProperty(this, \"isFloating\", true);\n\n    _defineProperty(this, \"isContinuous\", void 0);\n\n    _defineProperty(this, \"isDynamic\", void 0);\n\n    _defineProperty(this, \"locations\", []);\n\n    _defineProperty(this, \"currentLocation\", 0);\n\n    _defineProperty(this, \"locked\", false);\n\n    _defineProperty(this, \"cssClass\", '');\n\n    _defineProperty(this, \"timestamp\", null);\n\n    _defineProperty(this, \"type\", \"Floating\");\n\n    _defineProperty(this, \"id\", (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.uuid)());\n\n    _defineProperty(this, \"orientation\", [0, 0]);\n\n    _defineProperty(this, \"size\", void 0);\n\n    this.size = instance.getSize(element);\n    this.locations.push({\n      x: 0.5,\n      y: 0.5,\n      ox: this.orientation[0],\n      oy: this.orientation[1],\n      offx: 0,\n      offy: 0,\n      iox: this.orientation[0],\n      ioy: this.orientation[1],\n      cls: ''\n    });\n  }\n\n  _createClass(LightweightFloatingAnchor, [{\n    key: \"_updateOrientationInRouter\",\n    value: function _updateOrientationInRouter() {\n      this.instance.router.setAnchorOrientation(this, [this.locations[0].ox, this.locations[0].oy]);\n    }\n  }, {\n    key: \"over\",\n    value: function over(endpoint) {\n      this.orientation = this.instance.router.getEndpointOrientation(endpoint);\n      this.locations[0].ox = this.orientation[0];\n      this.locations[0].oy = this.orientation[1];\n\n      this._updateOrientationInRouter();\n    }\n  }, {\n    key: \"out\",\n    value: function out() {\n      this.orientation = null;\n      this.locations[0].ox = this.locations[0].iox;\n      this.locations[0].oy = this.locations[0].ioy;\n\n      this._updateOrientationInRouter();\n    }\n  }]);\n\n  return LightweightFloatingAnchor;\n}();\n\nvar opposites = (_opposites = {}, _defineProperty(_opposites, TOP, BOTTOM), _defineProperty(_opposites, RIGHT, LEFT), _defineProperty(_opposites, LEFT, RIGHT), _defineProperty(_opposites, BOTTOM, TOP), _opposites);\nvar clockwiseOptions = (_clockwiseOptions = {}, _defineProperty(_clockwiseOptions, TOP, RIGHT), _defineProperty(_clockwiseOptions, RIGHT, BOTTOM), _defineProperty(_clockwiseOptions, LEFT, TOP), _defineProperty(_clockwiseOptions, BOTTOM, LEFT), _clockwiseOptions);\nvar antiClockwiseOptions = (_antiClockwiseOptions = {}, _defineProperty(_antiClockwiseOptions, TOP, LEFT), _defineProperty(_antiClockwiseOptions, RIGHT, TOP), _defineProperty(_antiClockwiseOptions, LEFT, BOTTOM), _defineProperty(_antiClockwiseOptions, BOTTOM, RIGHT), _antiClockwiseOptions);\n\nfunction getDefaultFace(a) {\n  return a.faces.length === 0 ? TOP : a.faces[0];\n}\n\nfunction _isFaceAvailable(a, face) {\n  return a.faces.indexOf(face) !== -1;\n}\n\nfunction _secondBest(a, edge) {\n  return (a.clockwise ? clockwiseOptions : antiClockwiseOptions)[edge];\n}\n\nfunction _lastChoice(a, edge) {\n  return (a.clockwise ? antiClockwiseOptions : clockwiseOptions)[edge];\n}\n\nfunction isEdgeSupported(a, edge) {\n  return a.lockedAxis == null ? a.lockedFace == null ? _isFaceAvailable(a, edge) === true : a.lockedFace === edge : a.lockedAxis.indexOf(edge) !== -1;\n}\n\nfunction verifyFace(a, edge) {\n  if (_isFaceAvailable(a, edge)) {\n    return edge;\n  } else if (_isFaceAvailable(a, opposites[edge])) {\n    return opposites[edge];\n  } else {\n    var secondBest = _secondBest(a, edge);\n\n    if (_isFaceAvailable(a, secondBest)) {\n      return secondBest;\n    } else {\n      var lastChoice = _lastChoice(a, edge);\n\n      if (_isFaceAvailable(a, lastChoice)) {\n        return lastChoice;\n      }\n    }\n  }\n\n  return edge;\n}\n\nvar _top = {\n  x: 0.5,\n  y: 0,\n  ox: 0,\n  oy: -1,\n  offx: 0,\n  offy: 0\n},\n    _bottom = {\n  x: 0.5,\n  y: 1,\n  ox: 0,\n  oy: 1,\n  offx: 0,\n  offy: 0\n},\n    _left = {\n  x: 0,\n  y: 0.5,\n  ox: -1,\n  oy: 0,\n  offx: 0,\n  offy: 0\n},\n    _right = {\n  x: 1,\n  y: 0.5,\n  ox: 1,\n  oy: 0,\n  offx: 0,\n  offy: 0\n},\n    _topLeft = {\n  x: 0,\n  y: 0,\n  ox: 0,\n  oy: -1,\n  offx: 0,\n  offy: 0\n},\n    _topRight = {\n  x: 1,\n  y: 0,\n  ox: 1,\n  oy: -1,\n  offx: 0,\n  offy: 0\n},\n    _bottomLeft = {\n  x: 0,\n  y: 1,\n  ox: 0,\n  oy: 1,\n  offx: 0,\n  offy: 0\n},\n    _bottomRight = {\n  x: 1,\n  y: 1,\n  ox: 0,\n  oy: 1,\n  offx: 0,\n  offy: 0\n},\n    _center = {\n  x: 0.5,\n  y: 0.5,\n  ox: 0,\n  oy: 0,\n  offx: 0,\n  offy: 0\n};\nvar namedValues = {\n  \"Top\": [_top],\n  \"Bottom\": [_bottom],\n  \"Left\": [_left],\n  \"Right\": [_right],\n  \"TopLeft\": [_topLeft],\n  \"TopRight\": [_topRight],\n  \"BottomLeft\": [_bottomLeft],\n  \"BottomRight\": [_bottomRight],\n  \"Center\": [_center],\n  \"AutoDefault\": [_top, _left, _bottom, _right]\n};\nvar namedContinuousValues = {\n  \"Continuous\": {\n    faces: [TOP, LEFT, BOTTOM, RIGHT]\n  },\n  \"ContinuousTop\": {\n    faces: [TOP]\n  },\n  \"ContinuousRight\": {\n    faces: [RIGHT]\n  },\n  \"ContinuousBottom\": {\n    faces: [BOTTOM]\n  },\n  \"ContinuousLeft\": {\n    faces: [LEFT]\n  },\n  \"ContinuousLeftRight\": {\n    faces: [LEFT, RIGHT]\n  },\n  \"ContinuousTopBottom\": {\n    faces: [TOP, BOTTOM]\n  }\n};\n\nfunction getNamedAnchor(name, params) {\n  params = params || {};\n\n  if (name === _jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.AnchorLocations.Perimeter) {\n    return _createPerimeterAnchor(params);\n  }\n\n  var a = namedValues[name];\n\n  if (a != null) {\n    return _createAnchor(name, (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.map)(a, function (_a) {\n      return (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)({\n        iox: _a.ox,\n        ioy: _a.oy\n      }, _a);\n    }), params);\n  }\n\n  a = namedContinuousValues[name];\n\n  if (a != null) {\n    return _createContinuousAnchor(name, a.faces, params);\n  }\n\n  throw {\n    message: \"jsPlumb: unknown anchor type '\" + name + \"'\"\n  };\n}\n\nfunction _createAnchor(type, locations, params) {\n  return {\n    type: type,\n    locations: locations,\n    currentLocation: 0,\n    locked: false,\n    id: (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.uuid)(),\n    isFloating: false,\n    isContinuous: false,\n    isDynamic: locations.length > 1,\n    timestamp: null,\n    cssClass: params.cssClass || \"\"\n  };\n}\n\nfunction createFloatingAnchor(instance, element) {\n  return new LightweightFloatingAnchor(instance, element);\n}\n\nvar PROPERTY_CURRENT_FACE = \"currentFace\";\n\nfunction _createContinuousAnchor(type, faces, params) {\n  var ca = {\n    type: type,\n    locations: [],\n    currentLocation: 0,\n    locked: false,\n    id: (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.uuid)(),\n    cssClass: params.cssClass || \"\",\n    isFloating: false,\n    isContinuous: true,\n    timestamp: null,\n    faces: params.faces || faces,\n    lockedFace: null,\n    lockedAxis: null,\n    clockwise: !(params.clockwise === false),\n    __currentFace: null\n  };\n  Object.defineProperty(ca, PROPERTY_CURRENT_FACE, {\n    get: function get() {\n      return this.__currentFace;\n    },\n    set: function set(f) {\n      this.__currentFace = verifyFace(this, f);\n    }\n  });\n  return ca;\n}\n\nfunction isPrimitiveAnchorSpec(sa) {\n  return sa.length < 7 && sa.every(_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.isNumber) || sa.length === 7 && sa.slice(0, 5).every(_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.isNumber) && (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.isString)(sa[6]);\n}\n\nfunction makeLightweightAnchorFromSpec(spec) {\n  if ((0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.isString)(spec)) {\n    return getNamedAnchor(spec, null);\n  } else if (Array.isArray(spec)) {\n    if (isPrimitiveAnchorSpec(spec)) {\n      var _spec = spec;\n      return _createAnchor(null, [{\n        x: _spec[0],\n        y: _spec[1],\n        ox: _spec[2],\n        oy: _spec[3],\n        offx: _spec[4] == null ? 0 : _spec[4],\n        offy: _spec[5] == null ? 0 : _spec[5],\n        iox: _spec[2],\n        ioy: _spec[3],\n        cls: _spec[6] || \"\"\n      }], {\n        cssClass: _spec[6] || \"\"\n      });\n    } else {\n      var locations = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.map)(spec, function (aSpec) {\n        if ((0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.isString)(aSpec)) {\n          var a = namedValues[aSpec];\n          return a != null ? (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)({\n            iox: a[0].ox,\n            ioy: a[0].oy,\n            cls: \"\"\n          }, a[0]) : null;\n        } else if (isPrimitiveAnchorSpec(aSpec)) {\n          return {\n            x: aSpec[0],\n            y: aSpec[1],\n            ox: aSpec[2],\n            oy: aSpec[3],\n            offx: aSpec[4] == null ? 0 : aSpec[4],\n            offy: aSpec[5] == null ? 0 : aSpec[5],\n            iox: aSpec[2],\n            ioy: aSpec[3],\n            cls: aSpec[6] || \"\"\n          };\n        }\n      }).filter(function (ar) {\n        return ar != null;\n      });\n      return _createAnchor(\"Dynamic\", locations, {});\n    }\n  } else {\n    var sa = spec;\n    return getNamedAnchor(sa.type, sa.options);\n  }\n}\n\nfunction circleGenerator(anchorCount) {\n  var r = 0.5,\n      step = Math.PI * 2 / anchorCount,\n      a = [];\n  var current = 0;\n\n  for (var i = 0; i < anchorCount; i++) {\n    var x = r + r * Math.sin(current),\n        y = r + r * Math.cos(current);\n    a.push({\n      x: x,\n      y: y,\n      ox: 0,\n      oy: 0,\n      offx: 0,\n      offy: 0,\n      iox: 0,\n      ioy: 0,\n      cls: ''\n    });\n    current += step;\n  }\n\n  return a;\n}\n\nfunction _path(segments, anchorCount) {\n  var anchorsPerFace = anchorCount / segments.length,\n      a = [],\n      _computeFace = function _computeFace(x1, y1, x2, y2, fractionalLength, ox, oy) {\n    anchorsPerFace = anchorCount * fractionalLength;\n    var dx = (x2 - x1) / anchorsPerFace,\n        dy = (y2 - y1) / anchorsPerFace;\n\n    for (var i = 0; i < anchorsPerFace; i++) {\n      a.push({\n        x: x1 + dx * i,\n        y: y1 + dy * i,\n        ox: ox == null ? 0 : ox,\n        oy: oy == null ? 0 : oy,\n        offx: 0,\n        offy: 0,\n        iox: 0,\n        ioy: 0,\n        cls: ''\n      });\n    }\n  };\n\n  for (var i = 0; i < segments.length; i++) {\n    _computeFace.apply(null, segments[i]);\n  }\n\n  return a;\n}\n\nfunction shapeGenerator(faces, anchorCount) {\n  var s = [];\n\n  for (var i = 0; i < faces.length; i++) {\n    s.push([faces[i][0], faces[i][1], faces[i][2], faces[i][3], 1 / faces.length, faces[i][4], faces[i][5]]);\n  }\n\n  return _path(s, anchorCount);\n}\n\nfunction rectangleGenerator(anchorCount) {\n  return shapeGenerator([[0, 0, 1, 0, 0, -1], [1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 1, 0, 0, -1, 0]], anchorCount);\n}\n\nfunction diamondGenerator(anchorCount) {\n  return shapeGenerator([[0.5, 0, 1, 0.5], [1, 0.5, 0.5, 1], [0.5, 1, 0, 0.5], [0, 0.5, 0.5, 0]], anchorCount);\n}\n\nfunction triangleGenerator(anchorCount) {\n  return shapeGenerator([[0.5, 0, 1, 1], [1, 1, 0, 1], [0, 1, 0.5, 0]], anchorCount);\n}\n\nfunction rotate$1(points, amountInDegrees) {\n  var o = [],\n      theta = amountInDegrees / 180 * Math.PI;\n\n  for (var i = 0; i < points.length; i++) {\n    var _x = points[i].x - 0.5,\n        _y = points[i].y - 0.5;\n\n    o.push({\n      x: 0.5 + (_x * Math.cos(theta) - _y * Math.sin(theta)),\n      y: 0.5 + (_x * Math.sin(theta) + _y * Math.cos(theta)),\n      ox: points[i].ox,\n      oy: points[i].oy,\n      offx: 0,\n      offy: 0,\n      iox: 0,\n      ioy: 0,\n      cls: ''\n    });\n  }\n\n  return o;\n}\n\nvar anchorGenerators = new Map();\nanchorGenerators.set(_jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.PerimeterAnchorShapes.Circle, circleGenerator);\nanchorGenerators.set(_jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.PerimeterAnchorShapes.Ellipse, circleGenerator);\nanchorGenerators.set(_jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.PerimeterAnchorShapes.Rectangle, rectangleGenerator);\nanchorGenerators.set(_jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.PerimeterAnchorShapes.Square, rectangleGenerator);\nanchorGenerators.set(_jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.PerimeterAnchorShapes.Diamond, diamondGenerator);\nanchorGenerators.set(_jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.PerimeterAnchorShapes.Triangle, triangleGenerator);\n\nfunction _createPerimeterAnchor(params) {\n  params = params || {};\n  var anchorCount = params.anchorCount || 60,\n      shape = params.shape;\n\n  if (!shape) {\n    throw new Error(\"no shape supplied to Perimeter Anchor type\");\n  }\n\n  if (!anchorGenerators.has(shape)) {\n    throw new Error(\"Shape [\" + shape + \"] is unknown by Perimeter Anchor type\");\n  }\n\n  var da = anchorGenerators.get(shape)(anchorCount);\n\n  if (params.rotation) {\n    da = rotate$1(da, params.rotation);\n  }\n\n  var a = _createAnchor(_jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.AnchorLocations.Perimeter, da, params);\n\n  var aa = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)(a, {\n    shape: shape\n  });\n  return aa;\n}\n\nvar TYPE_ITEM_ANCHORS = \"anchors\";\nvar TYPE_ITEM_CONNECTOR = \"connector\";\n\nfunction prepareEndpoint(conn, existing, index, anchor, element, elementId, endpoint) {\n  var e;\n\n  if (existing) {\n    conn.endpoints[index] = existing;\n    existing.addConnection(conn);\n  } else {\n    var ep = endpoint || conn.endpointSpec || conn.endpointsSpec[index] || conn.instance.defaults.endpoints[index] || conn.instance.defaults.endpoint;\n    var es = conn.endpointStyles[index] || conn.endpointStyle || conn.instance.defaults.endpointStyles[index] || conn.instance.defaults.endpointStyle;\n\n    if (es.fill == null && conn.paintStyle != null) {\n      es.fill = conn.paintStyle.stroke;\n    }\n\n    if (es.outlineStroke == null && conn.paintStyle != null) {\n      es.outlineStroke = conn.paintStyle.outlineStroke;\n    }\n\n    if (es.outlineWidth == null && conn.paintStyle != null) {\n      es.outlineWidth = conn.paintStyle.outlineWidth;\n    }\n\n    var ehs = conn.endpointHoverStyles[index] || conn.endpointHoverStyle || conn.endpointHoverStyle || conn.instance.defaults.endpointHoverStyles[index] || conn.instance.defaults.endpointHoverStyle;\n\n    if (conn.hoverPaintStyle != null) {\n      if (ehs == null) {\n        ehs = {};\n      }\n\n      if (ehs.fill == null) {\n        ehs.fill = conn.hoverPaintStyle.stroke;\n      }\n    }\n\n    var u = conn.uuids ? conn.uuids[index] : null;\n    anchor = anchor != null ? anchor : conn.instance.defaults.anchors != null ? conn.instance.defaults.anchors[index] : conn.instance.defaults.anchor;\n    e = conn.instance._internal_newEndpoint({\n      paintStyle: es,\n      hoverPaintStyle: ehs,\n      endpoint: ep,\n      connections: [conn],\n      uuid: u,\n      element: element,\n      scope: conn.scope,\n      anchor: anchor,\n      reattachConnections: conn.reattach || conn.instance.defaults.reattachConnections,\n      connectionsDetachable: conn.detachable || conn.instance.defaults.connectionsDetachable\n    });\n\n    if (existing == null) {\n      e.deleteOnEmpty = true;\n    }\n\n    conn.endpoints[index] = e;\n  }\n\n  return e;\n}\n\nvar Connection = function (_Component) {\n  _inherits(Connection, _Component);\n\n  var _super = _createSuper(Connection);\n\n  function Connection(instance, params) {\n    var _this;\n\n    _classCallCheck(this, Connection);\n\n    _this = _super.call(this, instance, params);\n    _this.instance = instance;\n\n    _defineProperty(_assertThisInitialized(_this), \"connector\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"defaultLabelLocation\", 0.5);\n\n    _defineProperty(_assertThisInitialized(_this), \"scope\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"typeId\", \"_jsplumb_connection\");\n\n    _defineProperty(_assertThisInitialized(_this), \"previousConnection\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"sourceId\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"targetId\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"source\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"target\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"detachable\", true);\n\n    _defineProperty(_assertThisInitialized(_this), \"reattach\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"uuids\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"cost\", 1);\n\n    _defineProperty(_assertThisInitialized(_this), \"directed\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"endpoints\", [null, null]);\n\n    _defineProperty(_assertThisInitialized(_this), \"endpointStyles\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"endpointSpec\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"endpointsSpec\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"endpointStyle\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"endpointHoverStyle\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"endpointHoverStyles\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"suspendedEndpoint\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"suspendedIndex\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"suspendedElement\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"suspendedElementId\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"suspendedElementType\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_forceReattach\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_forceDetach\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"proxies\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"pending\", false);\n\n    _this.id = params.id;\n    _this.previousConnection = params.previousConnection;\n    _this.source = params.source;\n    _this.target = params.target;\n\n    if (params.sourceEndpoint) {\n      _this.source = params.sourceEndpoint.element;\n      _this.sourceId = params.sourceEndpoint.elementId;\n    } else {\n      _this.sourceId = instance.getId(_this.source);\n    }\n\n    if (params.targetEndpoint) {\n      _this.target = params.targetEndpoint.element;\n      _this.targetId = params.targetEndpoint.elementId;\n    } else {\n      _this.targetId = instance.getId(_this.target);\n    }\n\n    _this.scope = params.scope;\n    var sourceAnchor = params.anchors ? params.anchors[0] : params.anchor;\n    var targetAnchor = params.anchors ? params.anchors[1] : params.anchor;\n    instance.manage(_this.source);\n    instance.manage(_this.target);\n    _this.visible = true;\n    _this.params = {\n      cssClass: params.cssClass,\n      hoverClass: params.hoverClass,\n      \"pointer-events\": params[\"pointer-events\"],\n      overlays: params.overlays\n    };\n    _this.lastPaintedAt = null;\n\n    if (params.type) {\n      params.endpoints = params.endpoints || _this.instance._deriveEndpointAndAnchorSpec(params.type).endpoints;\n    }\n\n    _this.endpointSpec = params.endpoint;\n    _this.endpointsSpec = params.endpoints || [null, null];\n    _this.endpointStyle = params.endpointStyle;\n    _this.endpointHoverStyle = params.endpointHoverStyle;\n    _this.endpointStyles = params.endpointStyles || [null, null];\n    _this.endpointHoverStyles = params.endpointHoverStyles || [null, null];\n    _this.paintStyle = params.paintStyle;\n    _this.hoverPaintStyle = params.hoverPaintStyle;\n    _this.uuids = params.uuids;\n\n    _this.makeEndpoint(true, _this.source, _this.sourceId, sourceAnchor, params.sourceEndpoint);\n\n    _this.makeEndpoint(false, _this.target, _this.targetId, targetAnchor, params.targetEndpoint);\n\n    if (!_this.scope) {\n      _this.scope = _this.endpoints[0].scope;\n    }\n\n    if (params.deleteEndpointsOnEmpty != null) {\n      _this.endpoints[0].deleteOnEmpty = params.deleteEndpointsOnEmpty;\n      _this.endpoints[1].deleteOnEmpty = params.deleteEndpointsOnEmpty;\n    }\n\n    var _detachable = _this.instance.defaults.connectionsDetachable;\n\n    if (params.detachable === false) {\n      _detachable = false;\n    }\n\n    if (_this.endpoints[0].connectionsDetachable === false) {\n      _detachable = false;\n    }\n\n    if (_this.endpoints[1].connectionsDetachable === false) {\n      _detachable = false;\n    }\n\n    _this.endpointsSpec = params.endpoints || [null, null];\n    _this.endpointSpec = params.endpoint || null;\n\n    var _reattach = params.reattach || _this.endpoints[0].reattachConnections || _this.endpoints[1].reattachConnections || _this.instance.defaults.reattachConnections;\n\n    _this.appendToDefaultType({\n      detachable: _detachable,\n      reattach: _reattach,\n      paintStyle: _this.endpoints[0].connectorStyle || _this.endpoints[1].connectorStyle || params.paintStyle || _this.instance.defaults.paintStyle,\n      hoverPaintStyle: _this.endpoints[0].connectorHoverStyle || _this.endpoints[1].connectorHoverStyle || params.hoverPaintStyle || _this.instance.defaults.hoverPaintStyle\n    });\n\n    if (!_this.instance._suspendDrawing) {\n      var initialTimestamp = _this.instance._suspendedAt || (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.uuid)();\n\n      _this.instance._paintEndpoint(_this.endpoints[0], {\n        timestamp: initialTimestamp\n      });\n\n      _this.instance._paintEndpoint(_this.endpoints[1], {\n        timestamp: initialTimestamp\n      });\n    }\n\n    _this.cost = params.cost || _this.endpoints[0].connectionCost;\n    _this.directed = params.directed;\n\n    if (params.directed == null) {\n      _this.directed = _this.endpoints[0].connectionsDirected;\n    }\n\n    var _p = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, _this.endpoints[1].parameters);\n\n    (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)(_p, _this.endpoints[0].parameters);\n    (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)(_p, _this.parameters);\n    _this.parameters = _p;\n    _this.paintStyleInUse = _this.getPaintStyle() || {};\n\n    _this.setConnector(_this.endpoints[0].connector || _this.endpoints[1].connector || params.connector || _this.instance.defaults.connector, true);\n\n    var data = params.data == null || !(0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(params.data) ? {} : params.data;\n\n    _this.setData(data);\n\n    var _types = [_jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.DEFAULT, _this.endpoints[0].edgeType, _this.endpoints[1].edgeType, params.type].join(\" \");\n\n    if (/[^\\s]/.test(_types)) {\n      _this.addType(_types, params.data);\n    }\n\n    return _this;\n  }\n\n  _createClass(Connection, [{\n    key: \"getIdPrefix\",\n    value: function getIdPrefix() {\n      return \"_jsPlumb_c\";\n    }\n  }, {\n    key: \"getDefaultOverlayKey\",\n    value: function getDefaultOverlayKey() {\n      return KEY_CONNECTION_OVERLAYS;\n    }\n  }, {\n    key: \"getXY\",\n    value: function getXY() {\n      return {\n        x: this.connector.x,\n        y: this.connector.y\n      };\n    }\n  }, {\n    key: \"makeEndpoint\",\n    value: function makeEndpoint(isSource, el, elId, anchor, ep) {\n      elId = elId || this.instance.getId(el);\n      return prepareEndpoint(this, ep, isSource ? 0 : 1, anchor, el);\n    }\n  }, {\n    key: \"getTypeDescriptor\",\n    value: function getTypeDescriptor() {\n      return Connection.type;\n    }\n  }, {\n    key: \"isDetachable\",\n    value: function isDetachable(ep) {\n      return this.detachable === false ? false : ep != null ? ep.connectionsDetachable === true : this.detachable === true;\n    }\n  }, {\n    key: \"setDetachable\",\n    value: function setDetachable(detachable) {\n      this.detachable = detachable === true;\n    }\n  }, {\n    key: \"isReattach\",\n    value: function isReattach() {\n      return this.reattach === true || this.endpoints[0].reattachConnections === true || this.endpoints[1].reattachConnections === true;\n    }\n  }, {\n    key: \"setReattach\",\n    value: function setReattach(reattach) {\n      this.reattach = reattach === true;\n    }\n  }, {\n    key: \"applyType\",\n    value: function applyType(t, typeMap) {\n      var _connector = null;\n\n      if (t.connector != null) {\n        _connector = this.getCachedTypeItem(TYPE_ITEM_CONNECTOR, typeMap.connector);\n\n        if (_connector == null) {\n          _connector = this.prepareConnector(t.connector, typeMap.connector);\n          this.cacheTypeItem(TYPE_ITEM_CONNECTOR, _connector, typeMap.connector);\n        }\n\n        this.setPreparedConnector(_connector);\n      }\n\n      _get(_getPrototypeOf(Connection.prototype), \"applyType\", this).call(this, t, typeMap);\n\n      if (t.detachable != null) {\n        this.setDetachable(t.detachable);\n      }\n\n      if (t.reattach != null) {\n        this.setReattach(t.reattach);\n      }\n\n      if (t.scope) {\n        this.scope = t.scope;\n      }\n\n      var _anchors = null;\n\n      if (t.anchor) {\n        _anchors = this.getCachedTypeItem(TYPE_ITEM_ANCHORS, typeMap.anchor);\n\n        if (_anchors == null) {\n          _anchors = [makeLightweightAnchorFromSpec(t.anchor), makeLightweightAnchorFromSpec(t.anchor)];\n          this.cacheTypeItem(TYPE_ITEM_ANCHORS, _anchors, typeMap.anchor);\n        }\n      } else if (t.anchors) {\n        _anchors = this.getCachedTypeItem(TYPE_ITEM_ANCHORS, typeMap.anchors);\n\n        if (_anchors == null) {\n          _anchors = [makeLightweightAnchorFromSpec(t.anchors[0]), makeLightweightAnchorFromSpec(t.anchors[1])];\n          this.cacheTypeItem(TYPE_ITEM_ANCHORS, _anchors, typeMap.anchors);\n        }\n      }\n\n      if (_anchors != null) {\n        this.instance.router.setConnectionAnchors(this, _anchors);\n\n        if (this.instance.router.isDynamicAnchor(this.endpoints[1])) {\n          this.instance.repaint(this.endpoints[1].element);\n        }\n      }\n\n      this.instance.applyConnectorType(this.connector, t);\n    }\n  }, {\n    key: \"addClass\",\n    value: function addClass(c, cascade) {\n      _get(_getPrototypeOf(Connection.prototype), \"addClass\", this).call(this, c);\n\n      if (cascade) {\n        this.endpoints[0].addClass(c);\n        this.endpoints[1].addClass(c);\n\n        if (this.suspendedEndpoint) {\n          this.suspendedEndpoint.addClass(c);\n        }\n      }\n\n      if (this.connector) {\n        this.instance.addConnectorClass(this.connector, c);\n      }\n    }\n  }, {\n    key: \"removeClass\",\n    value: function removeClass(c, cascade) {\n      _get(_getPrototypeOf(Connection.prototype), \"removeClass\", this).call(this, c);\n\n      if (cascade) {\n        this.endpoints[0].removeClass(c);\n        this.endpoints[1].removeClass(c);\n\n        if (this.suspendedEndpoint) {\n          this.suspendedEndpoint.removeClass(c);\n        }\n      }\n\n      if (this.connector) {\n        this.instance.removeConnectorClass(this.connector, c);\n      }\n    }\n  }, {\n    key: \"setVisible\",\n    value: function setVisible(v) {\n      _get(_getPrototypeOf(Connection.prototype), \"setVisible\", this).call(this, v);\n\n      if (this.connector) {\n        this.instance.setConnectorVisible(this.connector, v);\n      }\n\n      this.instance._paintConnection(this);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(Connection.prototype), \"destroy\", this).call(this);\n\n      this.endpoints = null;\n      this.endpointStyles = null;\n      this.source = null;\n      this.target = null;\n      this.instance.destroyConnector(this);\n      this.connector = null;\n      this.deleted = true;\n    }\n  }, {\n    key: \"getUuids\",\n    value: function getUuids() {\n      return [this.endpoints[0].getUuid(), this.endpoints[1].getUuid()];\n    }\n  }, {\n    key: \"prepareConnector\",\n    value: function prepareConnector(connectorSpec, typeId) {\n      var connectorArgs = {\n        cssClass: this.params.cssClass,\n        hoverClass: this.params.hoverClass,\n        \"pointer-events\": this.params[\"pointer-events\"]\n      },\n          connector;\n\n      if ((0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.isString)(connectorSpec)) {\n        connector = this.instance._makeConnector(this, connectorSpec, connectorArgs);\n      } else {\n        var co = connectorSpec;\n        connector = this.instance._makeConnector(this, co.type, (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.merge)(co.options, connectorArgs));\n      }\n\n      if (typeId != null) {\n        connector.typeId = typeId;\n      }\n\n      return connector;\n    }\n  }, {\n    key: \"setPreparedConnector\",\n    value: function setPreparedConnector(connector, doNotRepaint, doNotChangeListenerComponent, typeId) {\n      if (this.connector !== connector) {\n        var previous,\n            previousClasses = \"\";\n\n        if (this.connector != null) {\n          previous = this.connector;\n          previousClasses = this.instance.getConnectorClass(this.connector);\n          this.instance.destroyConnector(this);\n        }\n\n        this.connector = connector;\n\n        if (typeId) {\n          this.cacheTypeItem(TYPE_ITEM_CONNECTOR, connector, typeId);\n        }\n\n        this.addClass(previousClasses);\n\n        if (previous != null) {\n          var o = this.getOverlays();\n\n          for (var i in o) {\n            this.instance.reattachOverlay(o[i], this);\n          }\n        }\n\n        if (!doNotRepaint) {\n          this.instance._paintConnection(this);\n        }\n      }\n    }\n  }, {\n    key: \"setConnector\",\n    value: function setConnector(connectorSpec, doNotRepaint, doNotChangeListenerComponent, typeId) {\n      var connector = this.prepareConnector(connectorSpec, typeId);\n      this.setPreparedConnector(connector, doNotRepaint, doNotChangeListenerComponent, typeId);\n    }\n  }, {\n    key: \"replaceEndpoint\",\n    value: function replaceEndpoint(idx, endpointDef) {\n      var current = this.endpoints[idx],\n          elId = current.elementId,\n          ebe = this.instance.getEndpoints(current.element),\n          _idx = ebe.indexOf(current),\n          _new = prepareEndpoint(this, null, idx, null, current.element, elId, endpointDef);\n\n      this.endpoints[idx] = _new;\n      ebe.splice(_idx, 1, _new);\n      current.detachFromConnection(this);\n      this.instance.deleteEndpoint(current);\n      this.instance.fire(EVENT_ENDPOINT_REPLACED, {\n        previous: current,\n        current: _new\n      });\n    }\n  }]);\n\n  return Connection;\n}(Component);\n\n_defineProperty(Connection, \"type\", \"connection\");\n\nvar typeParameters = [\"connectorStyle\", \"connectorHoverStyle\", \"connectorOverlays\", \"connector\", \"connectionType\", \"connectorClass\", \"connectorHoverClass\"];\n\nvar Endpoint = function (_Component) {\n  _inherits(Endpoint, _Component);\n\n  var _super = _createSuper(Endpoint);\n\n  function Endpoint(instance, params) {\n    var _this;\n\n    _classCallCheck(this, Endpoint);\n\n    _this = _super.call(this, instance, params);\n    _this.instance = instance;\n\n    _defineProperty(_assertThisInitialized(_this), \"connections\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"endpoint\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"element\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"elementId\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"dragAllowedWhenFull\", true);\n\n    _defineProperty(_assertThisInitialized(_this), \"timestamp\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"portId\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"maxConnections\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"proxiedBy\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"connectorClass\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"connectorHoverClass\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"finalEndpoint\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"enabled\", true);\n\n    _defineProperty(_assertThisInitialized(_this), \"isSource\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"isTarget\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"isTemporarySource\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"connectionCost\", 1);\n\n    _defineProperty(_assertThisInitialized(_this), \"connectionsDirected\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"connectionsDetachable\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"reattachConnections\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"currentAnchorClass\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"referenceEndpoint\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"edgeType\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"connector\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"connectorOverlays\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"connectorStyle\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"connectorHoverStyle\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"deleteOnEmpty\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"uuid\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"scope\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_anchor\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"defaultLabelLocation\", [0.5, 0.5]);\n\n    _this.appendToDefaultType({\n      edgeType: params.edgeType,\n      maxConnections: params.maxConnections == null ? _this.instance.defaults.maxConnections : params.maxConnections,\n      paintStyle: params.paintStyle || _this.instance.defaults.endpointStyle,\n      hoverPaintStyle: params.hoverPaintStyle || _this.instance.defaults.endpointHoverStyle,\n      connectorStyle: params.connectorStyle,\n      connectorHoverStyle: params.connectorHoverStyle,\n      connectorClass: params.connectorClass,\n      connectorHoverClass: params.connectorHoverClass,\n      connectorOverlays: params.connectorOverlays,\n      connector: params.connector\n    });\n\n    _this.enabled = !(params.enabled === false);\n    _this.visible = true;\n    _this.element = params.element;\n    _this.uuid = params.uuid;\n    _this.portId = params.portId;\n    _this.elementId = params.elementId;\n    _this.connectionCost = params.connectionCost == null ? 1 : params.connectionCost;\n    _this.connectionsDirected = params.connectionsDirected;\n    _this.currentAnchorClass = \"\";\n    _this.events = {};\n    _this.connectorOverlays = params.connectorOverlays;\n    _this.connectorStyle = params.connectorStyle;\n    _this.connectorHoverStyle = params.connectorHoverStyle;\n    _this.connector = params.connector;\n    _this.edgeType = params.edgeType;\n    _this.connectorClass = params.connectorClass;\n    _this.connectorHoverClass = params.connectorHoverClass;\n    _this.deleteOnEmpty = params.deleteOnEmpty === true;\n    _this.isSource = params.source || false;\n    _this.isTemporarySource = params.isTemporarySource || false;\n    _this.isTarget = params.target || false;\n    _this.connections = params.connections || [];\n    _this.scope = params.scope || instance.defaultScope;\n    _this.timestamp = null;\n    _this.reattachConnections = params.reattachConnections || instance.defaults.reattachConnections;\n    _this.connectionsDetachable = instance.defaults.connectionsDetachable;\n\n    if (params.connectionsDetachable === false) {\n      _this.connectionsDetachable = false;\n    }\n\n    _this.dragAllowedWhenFull = params.dragAllowedWhenFull !== false;\n\n    if (params.onMaxConnections) {\n      _this.bind(EVENT_MAX_CONNECTIONS, params.onMaxConnections);\n    }\n\n    var ep = params.endpoint || params.existingEndpoint || instance.defaults.endpoint;\n\n    _this.setEndpoint(ep);\n\n    if (params.preparedAnchor != null) {\n      _this.setPreparedAnchor(params.preparedAnchor);\n    } else {\n      var anchorParamsToUse = params.anchor ? params.anchor : params.anchors ? params.anchors : instance.defaults.anchor || _jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.AnchorLocations.Top;\n\n      _this.setAnchor(anchorParamsToUse);\n    }\n\n    var type = [_jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.DEFAULT, params.type || \"\"].join(\" \");\n\n    _this.addType(type, params.data);\n\n    return _this;\n  }\n\n  _createClass(Endpoint, [{\n    key: \"getIdPrefix\",\n    value: function getIdPrefix() {\n      return \"_jsplumb_e\";\n    }\n  }, {\n    key: \"getTypeDescriptor\",\n    value: function getTypeDescriptor() {\n      return \"endpoint\";\n    }\n  }, {\n    key: \"getXY\",\n    value: function getXY() {\n      return {\n        x: this.endpoint.x,\n        y: this.endpoint.y\n      };\n    }\n  }, {\n    key: \"getDefaultOverlayKey\",\n    value: function getDefaultOverlayKey() {\n      return \"endpointOverlays\";\n    }\n  }, {\n    key: \"_updateAnchorClass\",\n    value: function _updateAnchorClass() {\n      var ac = this._anchor && this._anchor.cssClass;\n\n      if (ac != null && ac.length > 0) {\n        var oldAnchorClass = this.instance.endpointAnchorClassPrefix + \"-\" + this.currentAnchorClass;\n        this.currentAnchorClass = ac;\n        var anchorClass = this.instance.endpointAnchorClassPrefix + (this.currentAnchorClass ? \"-\" + this.currentAnchorClass : \"\");\n\n        if (oldAnchorClass !== anchorClass) {\n          this.removeClass(oldAnchorClass);\n          this.addClass(anchorClass);\n          this.instance.removeClass(this.element, oldAnchorClass);\n          this.instance.addClass(this.element, anchorClass);\n        }\n      }\n    }\n  }, {\n    key: \"setPreparedAnchor\",\n    value: function setPreparedAnchor(anchor) {\n      this.instance.router.setAnchor(this, anchor);\n\n      this._updateAnchorClass();\n\n      return this;\n    }\n  }, {\n    key: \"_anchorLocationChanged\",\n    value: function _anchorLocationChanged(currentAnchor) {\n      this.fire(EVENT_ANCHOR_CHANGED, {\n        endpoint: this,\n        anchor: currentAnchor\n      });\n\n      this._updateAnchorClass();\n    }\n  }, {\n    key: \"setAnchor\",\n    value: function setAnchor(anchorParams) {\n      var a = this.instance.router.prepareAnchor(anchorParams);\n      this.setPreparedAnchor(a);\n      return this;\n    }\n  }, {\n    key: \"addConnection\",\n    value: function addConnection(conn) {\n      var wasFull = this.isFull();\n      var wasEmpty = this.connections.length === 0;\n      this.connections.push(conn);\n\n      if (wasEmpty) {\n        this.addClass(this.instance.endpointConnectedClass);\n      }\n\n      if (this.isFull()) {\n        if (!wasFull) {\n          this.addClass(this.instance.endpointFullClass);\n        }\n      } else if (wasFull) {\n        this.removeClass(this.instance.endpointFullClass);\n      }\n    }\n  }, {\n    key: \"detachFromConnection\",\n    value: function detachFromConnection(connection, idx, transientDetach) {\n      idx = idx == null ? this.connections.indexOf(connection) : idx;\n\n      if (idx >= 0) {\n        this.connections.splice(idx, 1);\n\n        this.instance._refreshEndpoint(this);\n      }\n\n      if (!transientDetach && this.deleteOnEmpty && this.connections.length === 0) {\n        this.instance.deleteEndpoint(this);\n      }\n    }\n  }, {\n    key: \"deleteEveryConnection\",\n    value: function deleteEveryConnection(params) {\n      var c = this.connections.length;\n\n      for (var i = 0; i < c; i++) {\n        this.instance.deleteConnection(this.connections[0], params);\n      }\n    }\n  }, {\n    key: \"detachFrom\",\n    value: function detachFrom(otherEndpoint) {\n      var c = [];\n\n      for (var i = 0; i < this.connections.length; i++) {\n        if (this.connections[i].endpoints[1] === otherEndpoint || this.connections[i].endpoints[0] === otherEndpoint) {\n          c.push(this.connections[i]);\n        }\n      }\n\n      for (var j = 0, count = c.length; j < count; j++) {\n        this.instance.deleteConnection(c[0]);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"setVisible\",\n    value: function setVisible(v, doNotChangeConnections, doNotNotifyOtherEndpoint) {\n      _get(_getPrototypeOf(Endpoint.prototype), \"setVisible\", this).call(this, v);\n\n      this.endpoint.setVisible(v);\n\n      if (v) {\n        this.showOverlays();\n      } else {\n        this.hideOverlays();\n      }\n\n      if (!doNotChangeConnections) {\n        for (var i = 0; i < this.connections.length; i++) {\n          this.connections[i].setVisible(v);\n\n          if (!doNotNotifyOtherEndpoint) {\n            var oIdx = this === this.connections[i].endpoints[0] ? 1 : 0;\n\n            if (this.connections[i].endpoints[oIdx].connections.length === 1) {\n              this.connections[i].endpoints[oIdx].setVisible(v, true, true);\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"applyType\",\n    value: function applyType(t, typeMap) {\n      _get(_getPrototypeOf(Endpoint.prototype), \"applyType\", this).call(this, t, typeMap);\n\n      this.setPaintStyle(t.endpointStyle || t.paintStyle);\n      this.setHoverPaintStyle(t.endpointHoverStyle || t.hoverPaintStyle);\n      this.connectorStyle = t.connectorStyle;\n      this.connectorHoverStyle = t.connectorHoverStyle;\n      this.connector = t.connector;\n      this.connectorOverlays = t.connectorOverlays;\n      this.edgeType = t.edgeType;\n\n      if (t.maxConnections != null) {\n        this.maxConnections = t.maxConnections;\n      }\n\n      if (t.scope) {\n        this.scope = t.scope;\n      }\n\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)(t, typeParameters);\n      this.instance.applyEndpointType(this, t);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(Endpoint.prototype), \"destroy\", this).call(this);\n\n      this.deleted = true;\n\n      if (this.endpoint != null) {\n        this.instance.destroyEndpoint(this);\n      }\n    }\n  }, {\n    key: \"isFull\",\n    value: function isFull() {\n      return this.maxConnections === 0 ? true : !(this.isFloating() || this.maxConnections < 0 || this.connections.length < this.maxConnections);\n    }\n  }, {\n    key: \"isFloating\",\n    value: function isFloating() {\n      return this.instance.router.isFloating(this);\n    }\n  }, {\n    key: \"isConnectedTo\",\n    value: function isConnectedTo(otherEndpoint) {\n      var found = false;\n\n      if (otherEndpoint) {\n        for (var i = 0; i < this.connections.length; i++) {\n          if (this.connections[i].endpoints[1] === otherEndpoint || this.connections[i].endpoints[0] === otherEndpoint) {\n            found = true;\n            break;\n          }\n        }\n      }\n\n      return found;\n    }\n  }, {\n    key: \"setDragAllowedWhenFull\",\n    value: function setDragAllowedWhenFull(allowed) {\n      this.dragAllowedWhenFull = allowed;\n    }\n  }, {\n    key: \"getUuid\",\n    value: function getUuid() {\n      return this.uuid;\n    }\n  }, {\n    key: \"connectorSelector\",\n    value: function connectorSelector() {\n      return this.connections[0];\n    }\n  }, {\n    key: \"prepareEndpoint\",\n    value: function prepareEndpoint(ep, typeId) {\n      var endpointArgs = {\n        cssClass: this.cssClass,\n        endpoint: this\n      };\n      var endpoint;\n\n      if ((0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.isAssignableFrom)(ep, EndpointRepresentation)) {\n        var epr = ep;\n        endpoint = EndpointFactory.clone(epr);\n      } else if ((0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.isString)(ep)) {\n        endpoint = EndpointFactory.get(this, ep, endpointArgs);\n      } else {\n        var fep = ep;\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)(endpointArgs, fep.options || {});\n        endpoint = EndpointFactory.get(this, fep.type, endpointArgs);\n      }\n\n      endpoint.typeId = typeId;\n      return endpoint;\n    }\n  }, {\n    key: \"setEndpoint\",\n    value: function setEndpoint(ep) {\n      var _ep = this.prepareEndpoint(ep);\n\n      this.setPreparedEndpoint(_ep);\n    }\n  }, {\n    key: \"setPreparedEndpoint\",\n    value: function setPreparedEndpoint(ep) {\n      if (this.endpoint != null) {\n        this.instance.destroyEndpoint(this);\n      }\n\n      this.endpoint = ep;\n    }\n  }, {\n    key: \"addClass\",\n    value: function addClass(clazz, cascade) {\n      _get(_getPrototypeOf(Endpoint.prototype), \"addClass\", this).call(this, clazz, cascade);\n\n      if (this.endpoint != null) {\n        this.endpoint.addClass(clazz);\n      }\n    }\n  }, {\n    key: \"removeClass\",\n    value: function removeClass(clazz, cascade) {\n      _get(_getPrototypeOf(Endpoint.prototype), \"removeClass\", this).call(this, clazz, cascade);\n\n      if (this.endpoint != null) {\n        this.endpoint.removeClass(clazz);\n      }\n    }\n  }]);\n\n  return Endpoint;\n}(Component);\n\nvar UINode = function UINode(instance, el) {\n  _classCallCheck(this, UINode);\n\n  this.instance = instance;\n  this.el = el;\n\n  _defineProperty(this, \"group\", void 0);\n};\n\nvar UIGroup = function (_UINode) {\n  _inherits(UIGroup, _UINode);\n\n  var _super = _createSuper(UIGroup);\n\n  function UIGroup(instance, el, options) {\n    var _this;\n\n    _classCallCheck(this, UIGroup);\n\n    _this = _super.call(this, instance, el);\n    _this.instance = instance;\n\n    _defineProperty(_assertThisInitialized(_this), \"children\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"collapsed\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"droppable\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"enabled\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"orphan\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"constrain\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"proxied\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"ghost\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"revert\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"prune\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"dropOverride\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"anchor\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"endpoint\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"connections\", {\n      source: [],\n      target: [],\n      internal: []\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"manager\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"id\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"elId\", void 0);\n\n    var jel = _this.el;\n    jel._isJsPlumbGroup = true;\n    jel._jsPlumbGroup = _assertThisInitialized(_this);\n    _this.elId = instance.getId(el);\n    _this.orphan = options.orphan === true;\n    _this.revert = _this.orphan === true ? false : options.revert !== false;\n    _this.droppable = options.droppable !== false;\n    _this.ghost = options.ghost === true;\n    _this.enabled = options.enabled !== false;\n    _this.prune = _this.orphan !== true && options.prune === true;\n    _this.constrain = _this.ghost || options.constrain === true;\n    _this.proxied = options.proxied !== false;\n    _this.id = options.id || (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.uuid)();\n    _this.dropOverride = options.dropOverride === true;\n    _this.anchor = options.anchor;\n    _this.endpoint = options.endpoint;\n    _this.anchor = options.anchor;\n    instance.setAttribute(el, ATTRIBUTE_GROUP, \"\");\n    return _this;\n  }\n\n  _createClass(UIGroup, [{\n    key: \"overrideDrop\",\n    value: function overrideDrop(el, targetGroup) {\n      return this.dropOverride && (this.revert || this.prune || this.orphan);\n    }\n  }, {\n    key: \"getAnchor\",\n    value: function getAnchor(conn, endpointIndex) {\n      return this.anchor || \"Continuous\";\n    }\n  }, {\n    key: \"getEndpoint\",\n    value: function getEndpoint(conn, endpointIndex) {\n      return this.endpoint || {\n        type: DotEndpoint.type,\n        options: {\n          radius: 10\n        }\n      };\n    }\n  }, {\n    key: \"add\",\n    value: function add(_el, doNotFireEvent) {\n      var dragArea = this.instance.getGroupContentArea(this);\n      var __el = _el;\n\n      if (__el._jsPlumbParentGroup != null) {\n        if (__el._jsPlumbParentGroup === this) {\n          return;\n        } else {\n          __el._jsPlumbParentGroup.remove(_el, true, doNotFireEvent, false);\n        }\n      }\n\n      __el._jsPlumbParentGroup = this;\n      this.children.push(new UINode(this.instance, _el));\n\n      this.instance._appendElement(__el, dragArea);\n\n      this.manager._updateConnectionsForGroup(this);\n    }\n  }, {\n    key: \"resolveNode\",\n    value: function resolveNode(el) {\n      return el == null ? null : (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.getWithFunction)(this.children, function (u) {\n        return u.el === el;\n      });\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(el, manipulateDOM, doNotFireEvent, doNotUpdateConnections, targetGroup) {\n      var uiNode = this.resolveNode(el);\n\n      if (uiNode != null) {\n        this._doRemove(uiNode, manipulateDOM, doNotFireEvent, doNotUpdateConnections, targetGroup);\n      }\n    }\n  }, {\n    key: \"_doRemove\",\n    value: function _doRemove(child, manipulateDOM, doNotFireEvent, doNotUpdateConnections, targetGroup) {\n      var __el = child.el;\n      delete __el._jsPlumbParentGroup;\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.removeWithFunction)(this.children, function (e) {\n        return e === child;\n      });\n\n      if (manipulateDOM) {\n        try {\n          this.instance.getGroupContentArea(this).removeChild(__el);\n        } catch (e) {\n          (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.log)(\"Could not remove element from Group \" + e);\n        }\n      }\n\n      if (!doNotFireEvent) {\n        var p = {\n          group: this,\n          el: __el\n        };\n\n        if (targetGroup) {\n          p.targetGroup = targetGroup;\n        }\n\n        this.instance.fire(EVENT_GROUP_MEMBER_REMOVED, p);\n      }\n\n      if (!doNotUpdateConnections) {\n        this.manager._updateConnectionsForGroup(this);\n      }\n    }\n  }, {\n    key: \"removeAll\",\n    value: function removeAll(manipulateDOM, doNotFireEvent) {\n      for (var i = 0, l = this.children.length; i < l; i++) {\n        var child = this.children[0];\n\n        this._doRemove(child, manipulateDOM, doNotFireEvent, true);\n\n        this.instance.unmanage(child.el, true);\n      }\n\n      this.children.length = 0;\n\n      this.manager._updateConnectionsForGroup(this);\n    }\n  }, {\n    key: \"orphanAll\",\n    value: function orphanAll() {\n      var orphanedPositions = {};\n\n      for (var i = 0; i < this.children.length; i++) {\n        var newPosition = this.manager.orphan(this.children[i].el, false);\n        orphanedPositions[newPosition.id] = newPosition.pos;\n      }\n\n      this.children.length = 0;\n      return orphanedPositions;\n    }\n  }, {\n    key: \"addGroup\",\n    value: function addGroup(group) {\n      if (this.instance.allowNestedGroups && group !== this) {\n        if (this.instance.groupManager.isAncestor(this, group)) {\n          return false;\n        }\n\n        if (group.group != null) {\n          group.group.removeGroup(group);\n        }\n\n        var groupElId = this.instance.getId(group.el);\n        var entry = this.instance.getManagedElements()[groupElId];\n        entry.group = this.elId;\n        var elpos = this.instance.getOffsetRelativeToRoot(group.el);\n        var cpos = this.collapsed ? this.instance.getOffsetRelativeToRoot(this.el) : this.instance.getOffsetRelativeToRoot(this.instance.getGroupContentArea(this));\n        group.el._jsPlumbParentGroup = this;\n        this.children.push(group);\n\n        this.instance._appendElement(group.el, this.instance.getGroupContentArea(this));\n\n        group.group = this;\n        var newPosition = {\n          x: elpos.x - cpos.x,\n          y: elpos.y - cpos.y\n        };\n        this.instance.setPosition(group.el, newPosition);\n        this.instance.fire(EVENT_NESTED_GROUP_ADDED, {\n          parent: this,\n          child: group\n        });\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"removeGroup\",\n    value: function removeGroup(group) {\n      if (group.group === this) {\n        var jel = group.el;\n        var d = this.instance.getGroupContentArea(this);\n\n        if (d === jel.parentNode) {\n          d.removeChild(group.el);\n        }\n\n        var groupElId = this.instance.getId(group.el);\n        var entry = this.instance.getManagedElements()[groupElId];\n\n        if (entry) {\n          delete entry.group;\n        }\n\n        this.children = this.children.filter(function (cg) {\n          return cg.id !== group.id;\n        });\n        delete group.group;\n        delete jel._jsPlumbParentGroup;\n        this.instance.fire(EVENT_NESTED_GROUP_REMOVED, {\n          parent: this,\n          child: group\n        });\n      }\n    }\n  }, {\n    key: \"getGroups\",\n    value: function getGroups() {\n      return this.children.filter(function (cg) {\n        return cg.constructor === UIGroup;\n      });\n    }\n  }, {\n    key: \"getNodes\",\n    value: function getNodes() {\n      return this.children.filter(function (cg) {\n        return cg.constructor === UINode;\n      });\n    }\n  }, {\n    key: \"collapseParent\",\n    get: function get() {\n      var cg = null;\n\n      if (this.group == null) {\n        return null;\n      } else {\n        var g = this.group;\n\n        while (g != null) {\n          if (g.collapsed) {\n            cg = g;\n          }\n\n          g = g.group;\n        }\n\n        return cg;\n      }\n    }\n  }]);\n\n  return UIGroup;\n}(UINode);\n\nvar GroupManager = function () {\n  function GroupManager(instance) {\n    var _this = this;\n\n    _classCallCheck(this, GroupManager);\n\n    this.instance = instance;\n\n    _defineProperty(this, \"groupMap\", {});\n\n    _defineProperty(this, \"_connectionSourceMap\", {});\n\n    _defineProperty(this, \"_connectionTargetMap\", {});\n\n    instance.bind(EVENT_INTERNAL_CONNECTION, function (p) {\n      var sourceGroup = _this.getGroupFor(p.source);\n\n      var targetGroup = _this.getGroupFor(p.target);\n\n      if (sourceGroup != null && targetGroup != null && sourceGroup === targetGroup) {\n        _this._connectionSourceMap[p.connection.id] = sourceGroup;\n        _this._connectionTargetMap[p.connection.id] = sourceGroup;\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.suggest)(sourceGroup.connections.internal, p.connection);\n      } else {\n        if (sourceGroup != null) {\n          if (p.target._jsPlumbGroup === sourceGroup) {\n            (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.suggest)(sourceGroup.connections.internal, p.connection);\n          } else {\n            (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.suggest)(sourceGroup.connections.source, p.connection);\n          }\n\n          _this._connectionSourceMap[p.connection.id] = sourceGroup;\n        }\n\n        if (targetGroup != null) {\n          if (p.source._jsPlumbGroup === targetGroup) {\n            (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.suggest)(targetGroup.connections.internal, p.connection);\n          } else {\n            (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.suggest)(targetGroup.connections.target, p.connection);\n          }\n\n          _this._connectionTargetMap[p.connection.id] = targetGroup;\n        }\n      }\n    });\n    instance.bind(EVENT_INTERNAL_CONNECTION_DETACHED, function (p) {\n      _this._cleanupDetachedConnection(p.connection);\n    });\n    instance.bind(EVENT_CONNECTION_MOVED, function (p) {\n      var originalElement = p.originalEndpoint.element,\n          originalGroup = _this.getGroupFor(originalElement),\n          newEndpoint = p.connection.endpoints[p.index],\n          newElement = newEndpoint.element,\n          newGroup = _this.getGroupFor(newElement),\n          connMap = p.index === 0 ? _this._connectionSourceMap : _this._connectionTargetMap,\n          otherConnMap = p.index === 0 ? _this._connectionTargetMap : _this._connectionSourceMap;\n\n      if (newGroup != null) {\n        connMap[p.connection.id] = newGroup;\n\n        if (p.connection.source === p.connection.target) {\n          otherConnMap[p.connection.id] = newGroup;\n        }\n      } else {\n        delete connMap[p.connection.id];\n\n        if (p.connection.source === p.connection.target) {\n          delete otherConnMap[p.connection.id];\n        }\n      }\n\n      if (originalGroup != null) {\n        _this._updateConnectionsForGroup(originalGroup);\n      }\n\n      if (newGroup != null) {\n        _this._updateConnectionsForGroup(newGroup);\n      }\n    });\n  }\n\n  _createClass(GroupManager, [{\n    key: \"_cleanupDetachedConnection\",\n    value: function _cleanupDetachedConnection(conn) {\n      conn.proxies.length = 0;\n      var group = this._connectionSourceMap[conn.id],\n          f;\n\n      if (group != null) {\n        f = function f(c) {\n          return c.id === conn.id;\n        };\n\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.removeWithFunction)(group.connections.source, f);\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.removeWithFunction)(group.connections.target, f);\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.removeWithFunction)(group.connections.internal, f);\n        delete this._connectionSourceMap[conn.id];\n      }\n\n      group = this._connectionTargetMap[conn.id];\n\n      if (group != null) {\n        f = function f(c) {\n          return c.id === conn.id;\n        };\n\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.removeWithFunction)(group.connections.source, f);\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.removeWithFunction)(group.connections.target, f);\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.removeWithFunction)(group.connections.internal, f);\n        delete this._connectionTargetMap[conn.id];\n      }\n    }\n  }, {\n    key: \"addGroup\",\n    value: function addGroup(params) {\n      var jel = params.el;\n\n      if (this.groupMap[params.id] != null) {\n        throw new Error(\"cannot create Group [\" + params.id + \"]; a Group with that ID exists\");\n      }\n\n      if (jel._isJsPlumbGroup != null) {\n        throw new Error(\"cannot create Group [\" + params.id + \"]; the given element is already a Group\");\n      }\n\n      var group = new UIGroup(this.instance, params.el, params);\n      this.groupMap[group.id] = group;\n\n      if (params.collapsed) {\n        this.collapseGroup(group);\n      }\n\n      this.instance.manage(group.el);\n      this.instance.addClass(group.el, CLASS_GROUP_EXPANDED);\n      group.manager = this;\n\n      this._updateConnectionsForGroup(group);\n\n      this.instance.fire(EVENT_GROUP_ADDED, {\n        group: group\n      });\n      return group;\n    }\n  }, {\n    key: \"getGroup\",\n    value: function getGroup(groupId) {\n      var group = groupId;\n\n      if ((0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.isString)(groupId)) {\n        group = this.groupMap[groupId];\n\n        if (group == null) {\n          throw new Error(\"No such group [\" + groupId + \"]\");\n        }\n      }\n\n      return group;\n    }\n  }, {\n    key: \"getGroupFor\",\n    value: function getGroupFor(el) {\n      var jel = el;\n      var c = this.instance.getContainer();\n      var abort = false,\n          g = null;\n\n      while (!abort) {\n        if (jel == null || jel === c) {\n          abort = true;\n        } else {\n          if (jel._jsPlumbParentGroup) {\n            g = jel._jsPlumbParentGroup;\n            abort = true;\n          } else {\n            jel = jel.parentNode;\n          }\n        }\n      }\n\n      return g;\n    }\n  }, {\n    key: \"getGroups\",\n    value: function getGroups() {\n      var g = [];\n\n      for (var key in this.groupMap) {\n        g.push(this.groupMap[key]);\n      }\n\n      return g;\n    }\n  }, {\n    key: \"removeGroup\",\n    value: function removeGroup(group, deleteMembers, manipulateView, doNotFireEvent) {\n      var _this2 = this;\n\n      var actualGroup = this.getGroup(group);\n      this.expandGroup(actualGroup, true);\n      var newPositions = {};\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.forEach)(actualGroup.children, function (uiNode) {\n        var entry = _this2.instance.getManagedElements()[_this2.instance.getId(uiNode.el)];\n\n        if (entry) {\n          delete entry.group;\n        }\n      });\n\n      if (deleteMembers) {\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.forEach)(actualGroup.getGroups(), function (cg) {\n          return _this2.removeGroup(cg, deleteMembers, manipulateView);\n        });\n        actualGroup.removeAll(manipulateView, doNotFireEvent);\n      } else {\n        if (actualGroup.group) {\n          (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.forEach)(actualGroup.children, function (c) {\n            return actualGroup.group.add(c.el);\n          });\n        }\n\n        newPositions = actualGroup.orphanAll();\n      }\n\n      if (actualGroup.group) {\n        actualGroup.group.removeGroup(actualGroup);\n      }\n\n      this.instance.unmanage(actualGroup.el, true);\n      delete this.groupMap[actualGroup.id];\n      this.instance.fire(EVENT_GROUP_REMOVED, {\n        group: actualGroup\n      });\n      return newPositions;\n    }\n  }, {\n    key: \"removeAllGroups\",\n    value: function removeAllGroups(deleteMembers, manipulateView, doNotFireEvent) {\n      for (var _g in this.groupMap) {\n        this.removeGroup(this.groupMap[_g], deleteMembers, manipulateView, doNotFireEvent);\n      }\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      for (var key in this.groupMap) {\n        f(this.groupMap[key]);\n      }\n    }\n  }, {\n    key: \"orphan\",\n    value: function orphan(el, doNotTransferToAncestor) {\n      var jel = el;\n\n      if (jel._jsPlumbParentGroup) {\n        var currentParent = jel._jsPlumbParentGroup;\n        var positionRelativeToGroup = this.instance.getOffset(jel);\n        var id = this.instance.getId(jel);\n        var pos = this.instance.getOffset(el);\n        jel.parentNode.removeChild(jel);\n\n        if (doNotTransferToAncestor !== true && currentParent.group) {\n          pos.x += positionRelativeToGroup.x;\n          pos.y += positionRelativeToGroup.y;\n          this.instance.getGroupContentArea(currentParent.group).appendChild(el);\n        } else {\n          this.instance._appendElement(el, this.instance.getContainer());\n        }\n\n        this.instance.setPosition(el, pos);\n        delete jel._jsPlumbParentGroup;\n        return {\n          id: id,\n          pos: pos\n        };\n      }\n    }\n  }, {\n    key: \"_updateConnectionsForGroup\",\n    value: function _updateConnectionsForGroup(group) {\n      var _this3 = this;\n\n      group.connections.source.length = 0;\n      group.connections.target.length = 0;\n      group.connections.internal.length = 0;\n      var members = group.children.slice().map(function (cn) {\n        return cn.el;\n      });\n      var childMembers = [];\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.forEach)(members, function (member) {\n        Array.prototype.push.apply(childMembers, _this3.instance.getSelector(member, SELECTOR_MANAGED_ELEMENT));\n      });\n      Array.prototype.push.apply(members, childMembers);\n\n      if (members.length > 0) {\n        var c1 = this.instance.getConnections({\n          source: members,\n          scope: _jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.WILDCARD\n        }, true);\n        var c2 = this.instance.getConnections({\n          target: members,\n          scope: _jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.WILDCARD\n        }, true);\n        var processed = {};\n        var gs, gt;\n\n        var oneSet = function oneSet(c) {\n          for (var i = 0; i < c.length; i++) {\n            if (processed[c[i].id]) {\n              continue;\n            }\n\n            processed[c[i].id] = true;\n            gs = _this3.getGroupFor(c[i].source);\n            gt = _this3.getGroupFor(c[i].target);\n\n            if (c[i].source === group.el && gt === group || c[i].target === group.el && gs === group) {\n              group.connections.internal.push(c[i]);\n            } else if (gs === group) {\n              if (gt !== group) {\n                group.connections.source.push(c[i]);\n              } else {\n                group.connections.internal.push(c[i]);\n              }\n\n              _this3._connectionSourceMap[c[i].id] = group;\n            } else if (gt === group) {\n              group.connections.target.push(c[i]);\n              _this3._connectionTargetMap[c[i].id] = group;\n            }\n          }\n        };\n\n        oneSet(c1);\n        oneSet(c2);\n      }\n    }\n  }, {\n    key: \"_collapseConnection\",\n    value: function _collapseConnection(conn, index, group) {\n      var otherEl = conn.endpoints[index === 0 ? 1 : 0].element;\n\n      if (otherEl._jsPlumbParentGroup && !otherEl._jsPlumbParentGroup.proxied && otherEl._jsPlumbParentGroup.collapsed) {\n        return false;\n      }\n\n      var es = conn.endpoints[0].element,\n          esg = es._jsPlumbParentGroup,\n          esgcp = esg != null ? esg.collapseParent || esg : null,\n          et = conn.endpoints[1].element,\n          etg = et._jsPlumbParentGroup,\n          etgcp = etg != null ? etg.collapseParent || etg : null;\n\n      if (esgcp == null || etgcp == null || esgcp.id !== etgcp.id) {\n        var groupEl = group.el;\n        this.instance.getId(groupEl);\n        this.instance.proxyConnection(conn, index, groupEl, function (conn, index) {\n          return group.getEndpoint(conn, index);\n        }, function (conn, index) {\n          return group.getAnchor(conn, index);\n        });\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"_expandConnection\",\n    value: function _expandConnection(c, index, group) {\n      this.instance.unproxyConnection(c, index);\n    }\n  }, {\n    key: \"isElementDescendant\",\n    value: function isElementDescendant(el, parentEl) {\n      var c = this.instance.getContainer();\n      var abort = false;\n\n      while (!abort) {\n        if (el == null || el === c) {\n          return false;\n        } else {\n          if (el === parentEl) {\n            return true;\n          } else {\n            el = el.parentNode;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"collapseGroup\",\n    value: function collapseGroup(group) {\n      var _this4 = this;\n\n      var actualGroup = this.getGroup(group);\n\n      if (actualGroup == null || actualGroup.collapsed) {\n        return;\n      }\n\n      var groupEl = actualGroup.el;\n\n      if (actualGroup.collapseParent == null) {\n        this.instance.setGroupVisible(actualGroup, false);\n        actualGroup.collapsed = true;\n        this.instance.removeClass(groupEl, CLASS_GROUP_EXPANDED);\n        this.instance.addClass(groupEl, CLASS_GROUP_COLLAPSED);\n\n        if (actualGroup.proxied) {\n          var collapsedConnectionIds = new Set();\n\n          var _collapseSet = function _collapseSet(conns, index) {\n            for (var i = 0; i < conns.length; i++) {\n              var c = conns[i];\n\n              if (_this4._collapseConnection(c, index, actualGroup) === true) {\n                collapsedConnectionIds.add(c.id);\n              }\n            }\n          };\n\n          _collapseSet(actualGroup.connections.source, 0);\n\n          _collapseSet(actualGroup.connections.target, 1);\n\n          (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.forEach)(actualGroup.getGroups(), function (cg) {\n            _this4.cascadeCollapse(actualGroup, cg, collapsedConnectionIds);\n          });\n        }\n\n        this.instance.revalidate(groupEl);\n        this.repaintGroup(actualGroup);\n        this.instance.fire(EVENT_GROUP_COLLAPSE, {\n          group: actualGroup\n        });\n      } else {\n        actualGroup.collapsed = true;\n        this.instance.removeClass(groupEl, CLASS_GROUP_EXPANDED);\n        this.instance.addClass(groupEl, CLASS_GROUP_COLLAPSED);\n      }\n    }\n  }, {\n    key: \"cascadeCollapse\",\n    value: function cascadeCollapse(collapsedGroup, targetGroup, collapsedIds) {\n      var _this5 = this;\n\n      if (collapsedGroup.proxied) {\n        var _collapseSet = function _collapseSet(conns, index) {\n          for (var i = 0; i < conns.length; i++) {\n            var c = conns[i];\n\n            if (!collapsedIds.has(c.id)) {\n              if (_this5._collapseConnection(c, index, collapsedGroup) === true) {\n                collapsedIds.add(c.id);\n              }\n            }\n          }\n        };\n\n        _collapseSet(targetGroup.connections.source, 0);\n\n        _collapseSet(targetGroup.connections.target, 1);\n      }\n\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.forEach)(targetGroup.getGroups(), function (cg) {\n        _this5.cascadeCollapse(collapsedGroup, cg, collapsedIds);\n      });\n    }\n  }, {\n    key: \"expandGroup\",\n    value: function expandGroup(group, doNotFireEvent) {\n      var _this6 = this;\n\n      var actualGroup = this.getGroup(group);\n\n      if (actualGroup == null) {\n        return;\n      }\n\n      var groupEl = actualGroup.el;\n\n      if (actualGroup.collapseParent == null) {\n        this.instance.setGroupVisible(actualGroup, true);\n        actualGroup.collapsed = false;\n        this.instance.addClass(groupEl, CLASS_GROUP_EXPANDED);\n        this.instance.removeClass(groupEl, CLASS_GROUP_COLLAPSED);\n\n        if (actualGroup.proxied) {\n          var _expandSet = function _expandSet(conns, index) {\n            for (var i = 0; i < conns.length; i++) {\n              var c = conns[i];\n\n              _this6._expandConnection(c, index, actualGroup);\n            }\n          };\n\n          _expandSet(actualGroup.connections.source, 0);\n\n          _expandSet(actualGroup.connections.target, 1);\n\n          var _expandNestedGroup = function _expandNestedGroup(group, ignoreCollapsedStateForNested) {\n            if (ignoreCollapsedStateForNested || group.collapsed) {\n              var _collapseSet = function _collapseSet(conns, index) {\n                for (var i = 0; i < conns.length; i++) {\n                  var c = conns[i];\n\n                  _this6._collapseConnection(c, index, group.collapseParent || group);\n                }\n              };\n\n              _collapseSet(group.connections.source, 0);\n\n              _collapseSet(group.connections.target, 1);\n\n              (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.forEach)(group.connections.internal, function (c) {\n                return c.setVisible(false);\n              });\n              (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.forEach)(group.getGroups(), function (g) {\n                return _expandNestedGroup(g, true);\n              });\n            } else {\n              _this6.expandGroup(group, true);\n            }\n          };\n\n          (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.forEach)(actualGroup.getGroups(), _expandNestedGroup);\n        }\n\n        this.instance.revalidate(groupEl);\n        this.repaintGroup(actualGroup);\n\n        if (!doNotFireEvent) {\n          this.instance.fire(EVENT_GROUP_EXPAND, {\n            group: actualGroup\n          });\n        }\n      } else {\n        actualGroup.collapsed = false;\n        this.instance.addClass(groupEl, CLASS_GROUP_EXPANDED);\n        this.instance.removeClass(groupEl, CLASS_GROUP_COLLAPSED);\n      }\n    }\n  }, {\n    key: \"toggleGroup\",\n    value: function toggleGroup(group) {\n      group = this.getGroup(group);\n\n      if (group != null) {\n        if (group.collapsed) {\n          this.expandGroup(group);\n        } else {\n          this.collapseGroup(group);\n        }\n      }\n    }\n  }, {\n    key: \"repaintGroup\",\n    value: function repaintGroup(group) {\n      var actualGroup = this.getGroup(group);\n      var m = actualGroup.children;\n\n      for (var i = 0; i < m.length; i++) {\n        this.instance.revalidate(m[i].el);\n      }\n    }\n  }, {\n    key: \"addToGroup\",\n    value: function addToGroup(group, doNotFireEvent) {\n      var _this7 = this;\n\n      var actualGroup = this.getGroup(group);\n\n      if (actualGroup) {\n        var groupEl = actualGroup.el;\n\n        var _one = function _one(el) {\n          var jel = el;\n          var isGroup = jel._isJsPlumbGroup != null,\n              droppingGroup = jel._jsPlumbGroup;\n          var currentGroup = jel._jsPlumbParentGroup;\n\n          if (currentGroup !== actualGroup) {\n            var entry = _this7.instance.manage(el);\n\n            var elpos = _this7.instance.getOffset(el);\n\n            var cpos = actualGroup.collapsed ? _this7.instance.getOffsetRelativeToRoot(groupEl) : _this7.instance.getOffset(_this7.instance.getGroupContentArea(actualGroup));\n            entry.group = actualGroup.elId;\n\n            if (currentGroup != null) {\n              currentGroup.remove(el, false, doNotFireEvent, false, actualGroup);\n\n              _this7._updateConnectionsForGroup(currentGroup);\n            }\n\n            if (isGroup) {\n              actualGroup.addGroup(droppingGroup);\n            } else {\n              actualGroup.add(el, doNotFireEvent);\n            }\n\n            var handleDroppedConnections = function handleDroppedConnections(list, index) {\n              var oidx = index === 0 ? 1 : 0;\n              list.each(function (c) {\n                c.setVisible(false);\n\n                if (c.endpoints[oidx].element._jsPlumbGroup === actualGroup) {\n                  c.endpoints[oidx].setVisible(false);\n\n                  _this7._expandConnection(c, oidx, actualGroup);\n                } else {\n                  c.endpoints[index].setVisible(false);\n\n                  _this7._collapseConnection(c, index, actualGroup);\n                }\n              });\n            };\n\n            if (actualGroup.collapsed) {\n              handleDroppedConnections(_this7.instance.select({\n                source: el\n              }), 0);\n              handleDroppedConnections(_this7.instance.select({\n                target: el\n              }), 1);\n            }\n\n            _this7.instance.getId(el);\n\n            var newPosition = {\n              x: elpos.x - cpos.x,\n              y: elpos.y - cpos.y\n            };\n\n            _this7.instance.setPosition(el, newPosition);\n\n            _this7._updateConnectionsForGroup(actualGroup);\n\n            _this7.instance.revalidate(el);\n\n            if (!doNotFireEvent) {\n              var p = {\n                group: actualGroup,\n                el: el,\n                pos: newPosition\n              };\n\n              if (currentGroup) {\n                p.sourceGroup = currentGroup;\n              }\n\n              _this7.instance.fire(EVENT_GROUP_MEMBER_ADDED, p);\n            }\n          }\n        };\n\n        for (var _len = arguments.length, el = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n          el[_key - 2] = arguments[_key];\n        }\n\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.forEach)(el, _one);\n      }\n    }\n  }, {\n    key: \"removeFromGroup\",\n    value: function removeFromGroup(group, doNotFireEvent) {\n      var _this8 = this;\n\n      var actualGroup = this.getGroup(group);\n\n      if (actualGroup) {\n        var _one = function _one(_el) {\n          if (actualGroup.collapsed) {\n            var _expandSet = function _expandSet(conns, index) {\n              for (var i = 0; i < conns.length; i++) {\n                var c = conns[i];\n\n                if (c.proxies) {\n                  for (var j = 0; j < c.proxies.length; j++) {\n                    if (c.proxies[j] != null) {\n                      var proxiedElement = c.proxies[j].originalEp.element;\n\n                      if (proxiedElement === _el || _this8.isElementDescendant(proxiedElement, _el)) {\n                        _this8._expandConnection(c, index, actualGroup);\n                      }\n                    }\n                  }\n                }\n              }\n            };\n\n            _expandSet(actualGroup.connections.source.slice(), 0);\n\n            _expandSet(actualGroup.connections.target.slice(), 1);\n          }\n\n          actualGroup.remove(_el, null, doNotFireEvent);\n\n          var entry = _this8.instance.getManagedElements()[_this8.instance.getId(_el)];\n\n          if (entry) {\n            delete entry.group;\n          }\n        };\n\n        for (var _len2 = arguments.length, el = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n          el[_key2 - 2] = arguments[_key2];\n        }\n\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.forEach)(el, _one);\n      }\n    }\n  }, {\n    key: \"getAncestors\",\n    value: function getAncestors(group) {\n      var ancestors = [];\n      var p = group.group;\n\n      while (p != null) {\n        ancestors.push(p);\n        p = p.group;\n      }\n\n      return ancestors;\n    }\n  }, {\n    key: \"isAncestor\",\n    value: function isAncestor(group, possibleAncestor) {\n      if (group == null || possibleAncestor == null) {\n        return false;\n      }\n\n      return this.getAncestors(group).indexOf(possibleAncestor) !== -1;\n    }\n  }, {\n    key: \"getDescendants\",\n    value: function getDescendants(group) {\n      var d = [];\n\n      var _one = function _one(g) {\n        var childGroups = g.getGroups();\n        d.push.apply(d, _toConsumableArray(childGroups));\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.forEach)(childGroups, _one);\n      };\n\n      _one(group);\n\n      return d;\n    }\n  }, {\n    key: \"isDescendant\",\n    value: function isDescendant(possibleDescendant, ancestor) {\n      if (possibleDescendant == null || ancestor == null) {\n        return false;\n      }\n\n      return this.getDescendants(ancestor).indexOf(possibleDescendant) !== -1;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._connectionSourceMap = {};\n      this._connectionTargetMap = {};\n      this.groupMap = {};\n    }\n  }]);\n\n  return GroupManager;\n}();\n\nvar SelectionBase = function () {\n  function SelectionBase(instance, entries) {\n    _classCallCheck(this, SelectionBase);\n\n    this.instance = instance;\n    this.entries = entries;\n  }\n\n  _createClass(SelectionBase, [{\n    key: \"length\",\n    get: function get() {\n      return this.entries.length;\n    }\n  }, {\n    key: \"each\",\n    value: function each(handler) {\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.forEach)(this.entries, function (e) {\n        return handler(e);\n      });\n      return this;\n    }\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      return this.entries[index];\n    }\n  }, {\n    key: \"addClass\",\n    value: function addClass(clazz, cascade) {\n      this.each(function (c) {\n        return c.addClass(clazz, cascade);\n      });\n      return this;\n    }\n  }, {\n    key: \"removeClass\",\n    value: function removeClass(clazz, cascade) {\n      this.each(function (c) {\n        return c.removeClass(clazz, cascade);\n      });\n      return this;\n    }\n  }, {\n    key: \"removeAllOverlays\",\n    value: function removeAllOverlays() {\n      this.each(function (c) {\n        return c.removeAllOverlays();\n      });\n      return this;\n    }\n  }, {\n    key: \"setLabel\",\n    value: function setLabel(label) {\n      this.each(function (c) {\n        return c.setLabel(label);\n      });\n      return this;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.entries.length = 0;\n      return this;\n    }\n  }, {\n    key: \"map\",\n    value: function map(fn) {\n      var a = [];\n      this.each(function (e) {\n        return a.push(fn(e));\n      });\n      return a;\n    }\n  }, {\n    key: \"addOverlay\",\n    value: function addOverlay(spec) {\n      this.each(function (c) {\n        return c.addOverlay(spec);\n      });\n      return this;\n    }\n  }, {\n    key: \"removeOverlay\",\n    value: function removeOverlay(id) {\n      this.each(function (c) {\n        return c.removeOverlay(id);\n      });\n      return this;\n    }\n  }, {\n    key: \"removeOverlays\",\n    value: function removeOverlays() {\n      this.each(function (c) {\n        return c.removeOverlays();\n      });\n      return this;\n    }\n  }, {\n    key: \"showOverlay\",\n    value: function showOverlay(id) {\n      this.each(function (c) {\n        return c.showOverlay(id);\n      });\n      return this;\n    }\n  }, {\n    key: \"hideOverlay\",\n    value: function hideOverlay(id) {\n      this.each(function (c) {\n        return c.hideOverlay(id);\n      });\n      return this;\n    }\n  }, {\n    key: \"setPaintStyle\",\n    value: function setPaintStyle(style) {\n      this.each(function (c) {\n        return c.setPaintStyle(style);\n      });\n      return this;\n    }\n  }, {\n    key: \"setHoverPaintStyle\",\n    value: function setHoverPaintStyle(style) {\n      this.each(function (c) {\n        return c.setHoverPaintStyle(style);\n      });\n      return this;\n    }\n  }, {\n    key: \"setSuspendEvents\",\n    value: function setSuspendEvents(suspend) {\n      this.each(function (c) {\n        return c.setSuspendEvents(suspend);\n      });\n      return this;\n    }\n  }, {\n    key: \"setParameter\",\n    value: function setParameter(name, value) {\n      this.each(function (c) {\n        return c.parameters[name] = value;\n      });\n      return this;\n    }\n  }, {\n    key: \"setParameters\",\n    value: function setParameters(p) {\n      this.each(function (c) {\n        return c.parameters = p;\n      });\n      return this;\n    }\n  }, {\n    key: \"setVisible\",\n    value: function setVisible(v) {\n      this.each(function (c) {\n        return c.setVisible(v);\n      });\n      return this;\n    }\n  }, {\n    key: \"addType\",\n    value: function addType(name) {\n      this.each(function (c) {\n        return c.addType(name);\n      });\n      return this;\n    }\n  }, {\n    key: \"toggleType\",\n    value: function toggleType(name) {\n      this.each(function (c) {\n        return c.toggleType(name);\n      });\n      return this;\n    }\n  }, {\n    key: \"removeType\",\n    value: function removeType(name) {\n      this.each(function (c) {\n        return c.removeType(name);\n      });\n      return this;\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(evt, handler) {\n      this.each(function (c) {\n        return c.bind(evt, handler);\n      });\n      return this;\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind(evt, handler) {\n      this.each(function (c) {\n        return c.unbind(evt, handler);\n      });\n      return this;\n    }\n  }, {\n    key: \"setHover\",\n    value: function setHover(h) {\n      var _this = this;\n\n      this.each(function (c) {\n        return _this.instance.setHover(c, h);\n      });\n      return this;\n    }\n  }]);\n\n  return SelectionBase;\n}();\n\nvar EndpointSelection = function (_SelectionBase) {\n  _inherits(EndpointSelection, _SelectionBase);\n\n  var _super = _createSuper(EndpointSelection);\n\n  function EndpointSelection() {\n    _classCallCheck(this, EndpointSelection);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(EndpointSelection, [{\n    key: \"setEnabled\",\n    value: function setEnabled(e) {\n      this.each(function (ep) {\n        return ep.enabled = e;\n      });\n      return this;\n    }\n  }, {\n    key: \"setAnchor\",\n    value: function setAnchor(a) {\n      this.each(function (ep) {\n        return ep.setAnchor(a);\n      });\n      return this;\n    }\n  }, {\n    key: \"deleteEveryConnection\",\n    value: function deleteEveryConnection() {\n      this.each(function (ep) {\n        return ep.deleteEveryConnection();\n      });\n      return this;\n    }\n  }, {\n    key: \"deleteAll\",\n    value: function deleteAll() {\n      var _this = this;\n\n      this.each(function (ep) {\n        return _this.instance.deleteEndpoint(ep);\n      });\n      this.clear();\n      return this;\n    }\n  }]);\n\n  return EndpointSelection;\n}(SelectionBase);\n\nvar ConnectionSelection = function (_SelectionBase) {\n  _inherits(ConnectionSelection, _SelectionBase);\n\n  var _super = _createSuper(ConnectionSelection);\n\n  function ConnectionSelection() {\n    _classCallCheck(this, ConnectionSelection);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ConnectionSelection, [{\n    key: \"setDetachable\",\n    value: function setDetachable(d) {\n      this.each(function (c) {\n        return c.setDetachable(d);\n      });\n      return this;\n    }\n  }, {\n    key: \"setReattach\",\n    value: function setReattach(d) {\n      this.each(function (c) {\n        return c.setReattach(d);\n      });\n      return this;\n    }\n  }, {\n    key: \"setConnector\",\n    value: function setConnector(spec) {\n      this.each(function (c) {\n        return c.setConnector(spec);\n      });\n      return this;\n    }\n  }, {\n    key: \"deleteAll\",\n    value: function deleteAll() {\n      var _this = this;\n\n      this.each(function (c) {\n        return _this.instance.deleteConnection(c);\n      });\n      this.clear();\n    }\n  }, {\n    key: \"repaint\",\n    value: function repaint() {\n      var _this2 = this;\n\n      this.each(function (c) {\n        return _this2.instance._paintConnection(c);\n      });\n      return this;\n    }\n  }]);\n\n  return ConnectionSelection;\n}(SelectionBase);\n\nvar Transaction = function Transaction() {\n  _classCallCheck(this, Transaction);\n\n  _defineProperty(this, \"affectedElements\", new Set());\n};\n\nfunction EMPTY_POSITION() {\n  return {\n    x: 0,\n    y: 0,\n    w: 0,\n    h: 0,\n    r: 0,\n    c: {\n      x: 0,\n      y: 0\n    },\n    x2: 0,\n    y2: 0,\n    t: {\n      x: 0,\n      y: 0,\n      c: {\n        x: 0,\n        y: 0\n      },\n      w: 0,\n      h: 0,\n      r: 0,\n      x2: 0,\n      y2: 0,\n      cr: 0,\n      sr: 0\n    },\n    dirty: true\n  };\n}\n\nfunction rotate(x, y, w, h, r) {\n  var center = {\n    x: x + w / 2,\n    y: y + h / 2\n  },\n      cr = Math.cos(r / 360 * Math.PI * 2),\n      sr = Math.sin(r / 360 * Math.PI * 2),\n      _point = function _point(x, y) {\n    return {\n      x: center.x + Math.round((x - center.x) * cr - (y - center.y) * sr),\n      y: center.y + Math.round((y - center.y) * cr - (x - center.x) * sr)\n    };\n  };\n\n  var p1 = _point(x, y),\n      p2 = _point(x + w, y),\n      p3 = _point(x + w, y + h),\n      p4 = _point(x, y + h),\n      c = _point(x + w / 2, y + h / 2);\n\n  var xmin = Math.min(p1.x, p2.x, p3.x, p4.x),\n      xmax = Math.max(p1.x, p2.x, p3.x, p4.x),\n      ymin = Math.min(p1.y, p2.y, p3.y, p4.y),\n      ymax = Math.max(p1.y, p2.y, p3.y, p4.y);\n  return {\n    x: xmin,\n    y: ymin,\n    w: xmax - xmin,\n    h: ymax - ymin,\n    c: c,\n    r: r,\n    x2: xmax,\n    y2: ymax,\n    cr: cr,\n    sr: sr\n  };\n}\n\nvar entryComparator = function entryComparator(value, arrayEntry) {\n  var c = 0;\n\n  if (arrayEntry[1] > value[1]) {\n    c = -1;\n  } else if (arrayEntry[1] < value[1]) {\n    c = 1;\n  }\n\n  return c;\n};\n\nvar reverseEntryComparator = function reverseEntryComparator(value, arrayEntry) {\n  return entryComparator(value, arrayEntry) * -1;\n};\n\nfunction _updateElementIndex(id, value, array, sortDescending) {\n  (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.insertSorted)([id, value], array, entryComparator, sortDescending);\n}\n\nfunction _clearElementIndex(id, array) {\n  var idx = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.findWithFunction)(array, function (entry) {\n    return entry[0] === id;\n  });\n\n  if (idx > -1) {\n    array.splice(idx, 1);\n  }\n}\n\nvar Viewport = function (_EventGenerator) {\n  _inherits(Viewport, _EventGenerator);\n\n  var _super = _createSuper(Viewport);\n\n  function Viewport(instance) {\n    var _this;\n\n    _classCallCheck(this, Viewport);\n\n    _this = _super.call(this);\n    _this.instance = instance;\n\n    _defineProperty(_assertThisInitialized(_this), \"_currentTransaction\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"_sortedElements\", {\n      xmin: [],\n      xmax: [],\n      ymin: [],\n      ymax: []\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_elementMap\", new Map());\n\n    _defineProperty(_assertThisInitialized(_this), \"_transformedElementMap\", new Map());\n\n    _defineProperty(_assertThisInitialized(_this), \"_bounds\", {\n      minx: 0,\n      maxx: 0,\n      miny: 0,\n      maxy: 0\n    });\n\n    return _this;\n  }\n\n  _createClass(Viewport, [{\n    key: \"_updateBounds\",\n    value: function _updateBounds(id, updatedElement, doNotRecalculateBounds) {\n      if (updatedElement != null) {\n        _clearElementIndex(id, this._sortedElements.xmin);\n\n        _clearElementIndex(id, this._sortedElements.xmax);\n\n        _clearElementIndex(id, this._sortedElements.ymin);\n\n        _clearElementIndex(id, this._sortedElements.ymax);\n\n        _updateElementIndex(id, updatedElement.t.x, this._sortedElements.xmin, false);\n\n        _updateElementIndex(id, updatedElement.t.x + updatedElement.t.w, this._sortedElements.xmax, true);\n\n        _updateElementIndex(id, updatedElement.t.y, this._sortedElements.ymin, false);\n\n        _updateElementIndex(id, updatedElement.t.y + updatedElement.t.h, this._sortedElements.ymax, true);\n\n        if (doNotRecalculateBounds !== true) {\n          this._recalculateBounds();\n        }\n      }\n    }\n  }, {\n    key: \"_recalculateBounds\",\n    value: function _recalculateBounds() {\n      this._bounds.minx = this._sortedElements.xmin.length > 0 ? this._sortedElements.xmin[0][1] : 0;\n      this._bounds.maxx = this._sortedElements.xmax.length > 0 ? this._sortedElements.xmax[0][1] : 0;\n      this._bounds.miny = this._sortedElements.ymin.length > 0 ? this._sortedElements.ymin[0][1] : 0;\n      this._bounds.maxy = this._sortedElements.ymax.length > 0 ? this._sortedElements.ymax[0][1] : 0;\n    }\n  }, {\n    key: \"recomputeBounds\",\n    value: function recomputeBounds() {\n      var _this2 = this;\n\n      this._sortedElements.xmin.length = 0;\n      this._sortedElements.xmax.length = 0;\n      this._sortedElements.ymin.length = 0;\n      this._sortedElements.ymax.length = 0;\n\n      this._elementMap.forEach(function (vp, id) {\n        _this2._sortedElements.xmin.push([id, vp.t.x]);\n\n        _this2._sortedElements.xmax.push([id, vp.t.x + vp.t.w]);\n\n        _this2._sortedElements.ymin.push([id, vp.t.y]);\n\n        _this2._sortedElements.ymax.push([id, vp.t.y + vp.t.h]);\n      });\n\n      this._sortedElements.xmin.sort(entryComparator);\n\n      this._sortedElements.ymin.sort(entryComparator);\n\n      this._sortedElements.xmax.sort(reverseEntryComparator);\n\n      this._sortedElements.ymax.sort(reverseEntryComparator);\n\n      this._recalculateBounds();\n    }\n  }, {\n    key: \"_finaliseUpdate\",\n    value: function _finaliseUpdate(id, e, doNotRecalculateBounds) {\n      e.t = rotate(e.x, e.y, e.w, e.h, e.r);\n\n      this._transformedElementMap.set(id, e.t);\n\n      if (doNotRecalculateBounds !== true) {\n        this._updateBounds(id, e, doNotRecalculateBounds);\n      }\n    }\n  }, {\n    key: \"shouldFireEvent\",\n    value: function shouldFireEvent(event, value, originalEvent) {\n      return true;\n    }\n  }, {\n    key: \"startTransaction\",\n    value: function startTransaction() {\n      if (this._currentTransaction != null) {\n        throw new Error(\"Viewport: cannot start transaction; a transaction is currently active.\");\n      }\n\n      this._currentTransaction = new Transaction();\n    }\n  }, {\n    key: \"endTransaction\",\n    value: function endTransaction() {\n      var _this3 = this;\n\n      if (this._currentTransaction != null) {\n        this._currentTransaction.affectedElements.forEach(function (id) {\n          var entry = _this3.getPosition(id);\n\n          _this3._finaliseUpdate(id, entry, true);\n        });\n\n        this.recomputeBounds();\n        this._currentTransaction = null;\n      }\n    }\n  }, {\n    key: \"updateElements\",\n    value: function updateElements(entries) {\n      var _this4 = this;\n\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.forEach)(entries, function (e) {\n        return _this4.updateElement(e.id, e.x, e.y, e.width, e.height, e.rotation);\n      });\n    }\n  }, {\n    key: \"updateElement\",\n    value: function updateElement(id, x, y, width, height, rotation, doNotRecalculateBounds) {\n      var e = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.getsert)(this._elementMap, id, EMPTY_POSITION);\n      e.dirty = x == null && e.x == null || y == null && e.y == null || width == null && e.w == null || height == null && e.h == null;\n\n      if (x != null) {\n        e.x = x;\n      }\n\n      if (y != null) {\n        e.y = y;\n      }\n\n      if (width != null) {\n        e.w = width;\n      }\n\n      if (height != null) {\n        e.h = height;\n      }\n\n      if (rotation != null) {\n        e.r = rotation || 0;\n      }\n\n      e.c.x = e.x + e.w / 2;\n      e.c.y = e.y + e.h / 2;\n      e.x2 = e.x + e.w;\n      e.y2 = e.y + e.h;\n\n      if (this._currentTransaction == null) {\n        this._finaliseUpdate(id, e, doNotRecalculateBounds);\n      } else {\n        this._currentTransaction.affectedElements.add(id);\n      }\n\n      return e;\n    }\n  }, {\n    key: \"refreshElement\",\n    value: function refreshElement(elId, doNotRecalculateBounds) {\n      var me = this.instance.getManagedElements();\n      var s = me[elId] ? me[elId].el : null;\n\n      if (s != null) {\n        var size = this.getSize(s);\n        var offset = this.getOffset(s);\n        return this.updateElement(elId, offset.x, offset.y, size.w, size.h, null, doNotRecalculateBounds);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"getSize\",\n    value: function getSize(el) {\n      return this.instance.getSize(el);\n    }\n  }, {\n    key: \"getOffset\",\n    value: function getOffset(el) {\n      return this.instance.getOffset(el);\n    }\n  }, {\n    key: \"registerElement\",\n    value: function registerElement(id, doNotRecalculateBounds) {\n      return this.updateElement(id, 0, 0, 0, 0, 0, doNotRecalculateBounds);\n    }\n  }, {\n    key: \"addElement\",\n    value: function addElement(id, x, y, width, height, rotation) {\n      return this.updateElement(id, x, y, width, height, rotation);\n    }\n  }, {\n    key: \"rotateElement\",\n    value: function rotateElement(id, rotation) {\n      var e = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.getsert)(this._elementMap, id, EMPTY_POSITION);\n      e.r = rotation || 0;\n\n      this._finaliseUpdate(id, e);\n\n      return e;\n    }\n  }, {\n    key: \"getBoundsWidth\",\n    value: function getBoundsWidth() {\n      return this._bounds.maxx - this._bounds.minx;\n    }\n  }, {\n    key: \"getBoundsHeight\",\n    value: function getBoundsHeight() {\n      return this._bounds.maxy - this._bounds.miny;\n    }\n  }, {\n    key: \"getX\",\n    value: function getX() {\n      return this._bounds.minx;\n    }\n  }, {\n    key: \"getY\",\n    value: function getY() {\n      return this._bounds.miny;\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(id, w, h) {\n      if (this._elementMap.has(id)) {\n        return this.updateElement(id, null, null, w, h, null);\n      }\n    }\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(id, x, y) {\n      if (this._elementMap.has(id)) {\n        return this.updateElement(id, x, y, null, null, null);\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._sortedElements.xmin.length = 0;\n      this._sortedElements.xmax.length = 0;\n      this._sortedElements.ymin.length = 0;\n      this._sortedElements.ymax.length = 0;\n\n      this._elementMap.clear();\n\n      this._transformedElementMap.clear();\n\n      this._recalculateBounds();\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(id) {\n      _clearElementIndex(id, this._sortedElements.xmin);\n\n      _clearElementIndex(id, this._sortedElements.xmax);\n\n      _clearElementIndex(id, this._sortedElements.ymin);\n\n      _clearElementIndex(id, this._sortedElements.ymax);\n\n      this._elementMap[\"delete\"](id);\n\n      this._transformedElementMap[\"delete\"](id);\n\n      this._recalculateBounds();\n    }\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(id) {\n      return this._elementMap.get(id);\n    }\n  }, {\n    key: \"getElements\",\n    value: function getElements() {\n      return this._elementMap;\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this._elementMap.size === 0;\n    }\n  }]);\n\n  return Viewport;\n}(_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.EventGenerator);\n\nvar ConnectionDragSelector = function () {\n  function ConnectionDragSelector(selector, def) {\n    var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    _classCallCheck(this, ConnectionDragSelector);\n\n    this.selector = selector;\n    this.def = def;\n    this.exclude = exclude;\n\n    _defineProperty(this, \"id\", void 0);\n\n    this.id = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.uuid)();\n  }\n\n  _createClass(ConnectionDragSelector, [{\n    key: \"setEnabled\",\n    value: function setEnabled(enabled) {\n      this.def.enabled = enabled;\n    }\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      return this.def.enabled !== false;\n    }\n  }]);\n\n  return ConnectionDragSelector;\n}();\n\nvar REDROP_POLICY_STRICT = \"strict\";\nvar REDROP_POLICY_ANY = \"any\";\n\nvar SourceSelector = function (_ConnectionDragSelect) {\n  _inherits(SourceSelector, _ConnectionDragSelect);\n\n  var _super = _createSuper(SourceSelector);\n\n  function SourceSelector(selector, def, exclude) {\n    var _this;\n\n    _classCallCheck(this, SourceSelector);\n\n    _this = _super.call(this, selector, def, exclude);\n    _this.def = def;\n\n    _defineProperty(_assertThisInitialized(_this), \"redrop\", void 0);\n\n    _this.redrop = def.def.redrop || REDROP_POLICY_STRICT;\n    return _this;\n  }\n\n  return SourceSelector;\n}(ConnectionDragSelector);\n\nvar TargetSelector = function (_ConnectionDragSelect2) {\n  _inherits(TargetSelector, _ConnectionDragSelect2);\n\n  var _super2 = _createSuper(TargetSelector);\n\n  function TargetSelector(selector, def, exclude) {\n    var _this2;\n\n    _classCallCheck(this, TargetSelector);\n\n    _this2 = _super2.call(this, selector, def, exclude);\n    _this2.def = def;\n    return _this2;\n  }\n\n  return TargetSelector;\n}(ConnectionDragSelector);\n\nvar _edgeSortFunctions;\n\nfunction _placeAnchorsOnLine(element, connections, horizontal, otherMultiplier, reverse) {\n  var sizeInAxis = horizontal ? element.w : element.h;\n  var sizeInOtherAxis = horizontal ? element.h : element.w;\n  var a = [],\n      step = sizeInAxis / (connections.length + 1);\n\n  for (var i = 0; i < connections.length; i++) {\n    var val = (i + 1) * step,\n        other = otherMultiplier * sizeInOtherAxis;\n\n    if (reverse) {\n      val = sizeInAxis - val;\n    }\n\n    var dx = horizontal ? val : other,\n        x = element.x + dx,\n        xp = dx / element.w;\n    var dy = horizontal ? other : val,\n        y = element.y + dy,\n        yp = dy / element.h;\n\n    if (element.r !== 0 && element.r != null) {\n      var rotated = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.rotatePoint)({\n        x: x,\n        y: y\n      }, element.c, element.r);\n      x = rotated.x;\n      y = rotated.y;\n    }\n\n    a.push({\n      x: x,\n      y: y,\n      xLoc: xp,\n      yLoc: yp,\n      c: connections[i].c\n    });\n  }\n\n  return a;\n}\n\nfunction _rightAndBottomSort(a, b) {\n  return b.theta - a.theta;\n}\n\nfunction _leftAndTopSort(a, b) {\n  var p1 = a.theta < 0 ? -Math.PI - a.theta : Math.PI - a.theta,\n      p2 = b.theta < 0 ? -Math.PI - b.theta : Math.PI - b.theta;\n  return p1 - p2;\n}\n\nvar edgeSortFunctions = (_edgeSortFunctions = {}, _defineProperty(_edgeSortFunctions, TOP, _leftAndTopSort), _defineProperty(_edgeSortFunctions, RIGHT, _rightAndBottomSort), _defineProperty(_edgeSortFunctions, BOTTOM, _rightAndBottomSort), _defineProperty(_edgeSortFunctions, LEFT, _leftAndTopSort), _edgeSortFunctions);\n\nfunction isContinuous(a) {\n  return a.isContinuous === true;\n}\n\nfunction _isFloating(a) {\n  return a.isContinuous === true;\n}\n\nfunction isDynamic(a) {\n  return a.locations.length > 1;\n}\n\nfunction getCurrentLocation(anchor) {\n  return [anchor.currentLocation, anchor.locations[anchor.currentLocation]];\n}\n\nvar LightweightRouter = function () {\n  function LightweightRouter(instance) {\n    var _this = this;\n\n    _classCallCheck(this, LightweightRouter);\n\n    this.instance = instance;\n\n    _defineProperty(this, \"anchorLists\", new Map());\n\n    _defineProperty(this, \"anchorLocations\", new Map());\n\n    instance.bind(EVENT_INTERNAL_CONNECTION_DETACHED, function (p) {\n      if (p.sourceEndpoint._anchor.isContinuous) {\n        _this._removeEndpointFromAnchorLists(p.sourceEndpoint);\n      }\n\n      if (p.targetEndpoint._anchor.isContinuous) {\n        _this._removeEndpointFromAnchorLists(p.targetEndpoint);\n      }\n    });\n    instance.bind(EVENT_INTERNAL_ENDPOINT_UNREGISTERED, function (ep) {\n      _this._removeEndpointFromAnchorLists(ep);\n    });\n  }\n\n  _createClass(LightweightRouter, [{\n    key: \"getAnchorOrientation\",\n    value: function getAnchorOrientation(anchor) {\n      var loc = this.anchorLocations.get(anchor.id);\n      return loc ? [loc.ox, loc.oy] : [0, 0];\n    }\n  }, {\n    key: \"_distance\",\n    value: function _distance(anchor, cx, cy, xy, wh, rotation, targetRotation) {\n      var ax = xy.x + anchor.x * wh.w,\n          ay = xy.y + anchor.y * wh.h,\n          acx = xy.x + wh.w / 2,\n          acy = xy.y + wh.h / 2;\n\n      if (rotation != null && rotation.length > 0) {\n        var rotated = this.instance._applyRotations([ax, ay, 0, 0], rotation);\n\n        ax = rotated.x;\n        ay = rotated.y;\n      }\n\n      return Math.sqrt(Math.pow(cx - ax, 2) + Math.pow(cy - ay, 2)) + Math.sqrt(Math.pow(acx - ax, 2) + Math.pow(acy - ay, 2));\n    }\n  }, {\n    key: \"_anchorSelector\",\n    value: function _anchorSelector(xy, wh, txy, twh, rotation, targetRotation, locations) {\n      var cx = txy.x + twh.w / 2,\n          cy = txy.y + twh.h / 2;\n      var minIdx = -1,\n          minDist = Infinity;\n\n      for (var i = 0; i < locations.length; i++) {\n        var d = this._distance(locations[i], cx, cy, xy, wh, rotation, targetRotation);\n\n        if (d < minDist) {\n          minIdx = i + 0;\n          minDist = d;\n        }\n      }\n\n      return [minIdx, locations[minIdx]];\n    }\n  }, {\n    key: \"_floatingAnchorCompute\",\n    value: function _floatingAnchorCompute(anchor, params) {\n      var xy = params.xy;\n      var pos = {\n        curX: xy.x + anchor.size.w / 2,\n        curY: xy.y + anchor.size.h / 2,\n        x: 0,\n        y: 0,\n        ox: 0,\n        oy: 0\n      };\n      return this._setComputedPosition(anchor, pos);\n    }\n  }, {\n    key: \"_setComputedPosition\",\n    value: function _setComputedPosition(anchor, pos, timestamp) {\n      this.anchorLocations.set(anchor.id, pos);\n      anchor.computedPosition = pos;\n\n      if (timestamp) {\n        anchor.timestamp = timestamp;\n      }\n\n      return pos;\n    }\n  }, {\n    key: \"_computeSingleLocation\",\n    value: function _computeSingleLocation(loc, xy, wh, params) {\n      var candidate = {\n        curX: xy.x + loc.x * wh.w + loc.offx,\n        curY: xy.y + loc.y * wh.h + loc.offy,\n        x: loc.x,\n        y: loc.y,\n        ox: 0,\n        oy: 0\n      };\n      var pos;\n      var rotation = params.rotation;\n\n      if (rotation != null && rotation.length > 0) {\n        var o = [loc.iox, loc.ioy],\n            current = {\n          x: candidate.curX,\n          y: candidate.curY,\n          cr: 0,\n          sr: 0\n        };\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.forEach)(rotation, function (r) {\n          current = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.rotatePoint)(current, r.c, r.r);\n          var _o = [Math.round(o[0] * current.cr - o[1] * current.sr), Math.round(o[1] * current.cr + o[0] * current.sr)];\n          o = _o.slice();\n        });\n        loc.ox = o[0];\n        loc.oy = o[1];\n        pos = {\n          curX: current.x,\n          curY: current.y,\n          x: loc.x,\n          y: loc.y,\n          ox: o[0],\n          oy: o[1]\n        };\n      } else {\n        loc.ox = loc.iox;\n        loc.oy = loc.ioy;\n        pos = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)({\n          ox: loc.iox,\n          oy: loc.ioy\n        }, candidate);\n      }\n\n      return pos;\n    }\n  }, {\n    key: \"_singleAnchorCompute\",\n    value: function _singleAnchorCompute(anchor, params) {\n      var xy = params.xy,\n          wh = params.wh,\n          timestamp = params.timestamp,\n          pos = this.anchorLocations.get(anchor.id);\n\n      if (pos != null && timestamp && timestamp === anchor.timestamp) {\n        return pos;\n      }\n\n      var _getCurrentLocation = getCurrentLocation(anchor),\n          _getCurrentLocation2 = _slicedToArray(_getCurrentLocation, 2);\n\n      _getCurrentLocation2[0];\n      var currentLoc = _getCurrentLocation2[1];\n      pos = this._computeSingleLocation(currentLoc, xy, wh, params);\n      return this._setComputedPosition(anchor, pos, timestamp);\n    }\n  }, {\n    key: \"_defaultAnchorCompute\",\n    value: function _defaultAnchorCompute(anchor, params) {\n      var pos;\n\n      if (anchor.locations.length === 1) {\n        return this._singleAnchorCompute(anchor, params);\n      }\n\n      var xy = params.xy,\n          wh = params.wh,\n          txy = params.txy,\n          twh = params.twh;\n\n      var _getCurrentLocation3 = getCurrentLocation(anchor),\n          _getCurrentLocation4 = _slicedToArray(_getCurrentLocation3, 2),\n          currentIdx = _getCurrentLocation4[0],\n          currentLoc = _getCurrentLocation4[1];\n\n      if (anchor.locked || txy == null || twh == null) {\n        pos = this._computeSingleLocation(currentLoc, xy, wh, params);\n      } else {\n        var _this$_anchorSelector = this._anchorSelector(xy, wh, txy, twh, params.rotation, params.tRotation, anchor.locations),\n            _this$_anchorSelector2 = _slicedToArray(_this$_anchorSelector, 2),\n            newIdx = _this$_anchorSelector2[0],\n            newLoc = _this$_anchorSelector2[1];\n\n        anchor.currentLocation = newIdx;\n\n        if (newIdx !== currentIdx) {\n          anchor.cssClass = newLoc.cls || anchor.cssClass;\n\n          params.element._anchorLocationChanged(anchor);\n        }\n\n        pos = this._computeSingleLocation(newLoc, xy, wh, params);\n      }\n\n      return this._setComputedPosition(anchor, pos, params.timestamp);\n    }\n  }, {\n    key: \"_placeAnchors\",\n    value: function _placeAnchors(elementId, _anchorLists) {\n      var _this2 = this;\n\n      var cd = this.instance.viewport.getPosition(elementId),\n          placeSomeAnchors = function placeSomeAnchors(desc, element, unsortedConnections, isHorizontal, otherMultiplier, orientation) {\n        if (unsortedConnections.length > 0) {\n          var sc = unsortedConnections.sort(edgeSortFunctions[desc]),\n              reverse = desc === RIGHT || desc === TOP,\n              anchors = _placeAnchorsOnLine(cd, sc, isHorizontal, otherMultiplier, reverse);\n\n          for (var i = 0; i < anchors.length; i++) {\n            var c = anchors[i].c,\n                weAreSource = c.endpoints[0].elementId === elementId,\n                ep = weAreSource ? c.endpoints[0] : c.endpoints[1];\n\n            _this2._setComputedPosition(ep._anchor, {\n              curX: anchors[i].x,\n              curY: anchors[i].y,\n              x: anchors[i].xLoc,\n              y: anchors[i].yLoc,\n              ox: orientation[0],\n              oy: orientation[1]\n            });\n          }\n        }\n      };\n\n      placeSomeAnchors(BOTTOM, cd, _anchorLists.bottom, true, 1, [0, 1]);\n      placeSomeAnchors(TOP, cd, _anchorLists.top, true, 0, [0, -1]);\n      placeSomeAnchors(LEFT, cd, _anchorLists.left, false, 0, [-1, 0]);\n      placeSomeAnchors(RIGHT, cd, _anchorLists.right, false, 1, [1, 0]);\n    }\n  }, {\n    key: \"_updateAnchorList\",\n    value: function _updateAnchorList(lists, theta, order, conn, aBoolean, otherElId, idx, reverse, edgeId, connsToPaint, endpointsToPaint) {\n      var endpoint = conn.endpoints[idx],\n          endpointId = endpoint.id,\n          oIdx = [1, 0][idx],\n          values = {\n        theta: theta,\n        order: order,\n        c: conn,\n        b: aBoolean,\n        elId: otherElId,\n        epId: endpointId\n      },\n          listToAddTo = lists[edgeId],\n          listToRemoveFrom = endpoint._continuousAnchorEdge ? lists[endpoint._continuousAnchorEdge] : null,\n          candidate;\n\n      if (listToRemoveFrom) {\n        var rIdx = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.findWithFunction)(listToRemoveFrom, function (e) {\n          return e.epId === endpointId;\n        });\n\n        if (rIdx !== -1) {\n          listToRemoveFrom.splice(rIdx, 1);\n\n          for (var i = 0; i < listToRemoveFrom.length; i++) {\n            candidate = listToRemoveFrom[i].c;\n\n            if (candidate.placeholder !== true) {\n              connsToPaint.add(candidate);\n            }\n\n            endpointsToPaint.add(listToRemoveFrom[i].c.endpoints[idx]);\n            endpointsToPaint.add(listToRemoveFrom[i].c.endpoints[oIdx]);\n          }\n        }\n      }\n\n      for (var _i = 0; _i < listToAddTo.length; _i++) {\n        candidate = listToAddTo[_i].c;\n\n        if (candidate.placeholder !== true) {\n          connsToPaint.add(candidate);\n        }\n\n        endpointsToPaint.add(listToAddTo[_i].c.endpoints[idx]);\n        endpointsToPaint.add(listToAddTo[_i].c.endpoints[oIdx]);\n      }\n\n      {\n        var insertIdx = reverse ? 0 : listToAddTo.length;\n        listToAddTo.splice(insertIdx, 0, values);\n      }\n      endpoint._continuousAnchorEdge = edgeId;\n    }\n  }, {\n    key: \"_removeEndpointFromAnchorLists\",\n    value: function _removeEndpointFromAnchorLists(endpoint) {\n      var listsForElement = this.anchorLists.get(endpoint.elementId);\n      var total = 0;\n\n      (function (list, eId) {\n        if (list) {\n          var f = function f(e) {\n            return e.epId === eId;\n          };\n\n          (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.removeWithFunction)(list.top, f);\n          (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.removeWithFunction)(list.left, f);\n          (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.removeWithFunction)(list.bottom, f);\n          (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.removeWithFunction)(list.right, f);\n          total += list.top.length;\n          total += list.left.length;\n          total += list.bottom.length;\n          total += list.right.length;\n        }\n      })(listsForElement, endpoint.id);\n\n      if (total === 0) {\n        this.anchorLists[\"delete\"](endpoint.elementId);\n      }\n\n      this.anchorLocations[\"delete\"](endpoint._anchor.id);\n    }\n  }, {\n    key: \"computeAnchorLocation\",\n    value: function computeAnchorLocation(anchor, params) {\n      var pos;\n\n      if (isContinuous(anchor)) {\n        pos = this.anchorLocations.get(anchor.id) || {\n          curX: 0,\n          curY: 0,\n          x: 0,\n          y: 0,\n          ox: 0,\n          oy: 0\n        };\n      } else if (_isFloating(anchor)) {\n        pos = this._floatingAnchorCompute(anchor, params);\n      } else {\n        pos = this._defaultAnchorCompute(anchor, params);\n      }\n\n      anchor.timestamp = params.timestamp;\n      return pos;\n    }\n  }, {\n    key: \"computePath\",\n    value: function computePath(connection, timestamp) {\n      var sourceInfo = this.instance.viewport.getPosition(connection.sourceId),\n          targetInfo = this.instance.viewport.getPosition(connection.targetId),\n          sE = connection.endpoints[0],\n          tE = connection.endpoints[1];\n      var sAnchorP = this.getEndpointLocation(sE, {\n        xy: sourceInfo,\n        wh: sourceInfo,\n        element: sE,\n        timestamp: timestamp,\n        rotation: this.instance._getRotations(connection.sourceId)\n      }),\n          tAnchorP = this.getEndpointLocation(tE, {\n        xy: targetInfo,\n        wh: targetInfo,\n        element: tE,\n        timestamp: timestamp,\n        rotation: this.instance._getRotations(connection.targetId)\n      });\n      connection.connector.resetBounds();\n      connection.connector.compute({\n        sourcePos: sAnchorP,\n        targetPos: tAnchorP,\n        sourceEndpoint: connection.endpoints[0],\n        targetEndpoint: connection.endpoints[1],\n        strokeWidth: connection.paintStyleInUse.strokeWidth,\n        sourceInfo: sourceInfo,\n        targetInfo: targetInfo\n      });\n    }\n  }, {\n    key: \"getEndpointLocation\",\n    value: function getEndpointLocation(endpoint, params) {\n      params = params || {};\n      var anchor = endpoint._anchor;\n      var pos = this.anchorLocations.get(anchor.id);\n\n      if (pos == null || params.timestamp != null && anchor.timestamp !== params.timestamp) {\n        pos = this.computeAnchorLocation(anchor, params);\n\n        this._setComputedPosition(anchor, pos, params.timestamp);\n      }\n\n      return pos;\n    }\n  }, {\n    key: \"getEndpointOrientation\",\n    value: function getEndpointOrientation(ep) {\n      return ep._anchor ? this.getAnchorOrientation(ep._anchor) : [0, 0];\n    }\n  }, {\n    key: \"setAnchorOrientation\",\n    value: function setAnchorOrientation(anchor, orientation) {\n      var anchorLoc = this.anchorLocations.get(anchor.id);\n\n      if (anchorLoc != null) {\n        anchorLoc.ox = orientation[0];\n        anchorLoc.oy = orientation[1];\n      }\n    }\n  }, {\n    key: \"isDynamicAnchor\",\n    value: function isDynamicAnchor(ep) {\n      return ep._anchor ? !isContinuous(ep._anchor) && ep._anchor.locations.length > 1 : false;\n    }\n  }, {\n    key: \"isFloating\",\n    value: function isFloating(ep) {\n      return ep._anchor ? _isFloating(ep._anchor) : false;\n    }\n  }, {\n    key: \"prepareAnchor\",\n    value: function prepareAnchor(params) {\n      return makeLightweightAnchorFromSpec(params);\n    }\n  }, {\n    key: \"redraw\",\n    value: function redraw(elementId, timestamp, offsetToUI) {\n      var _this3 = this;\n\n      var connectionsToPaint = new Set(),\n          endpointsToPaint = new Set(),\n          anchorsToUpdate = new Set();\n\n      if (!this.instance._suspendDrawing) {\n        var ep = this.instance.endpointsByElement[elementId] || [];\n        timestamp = timestamp || (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.uuid)();\n        var orientationCache = {},\n            a,\n            anEndpoint;\n\n        for (var i = 0; i < ep.length; i++) {\n          anEndpoint = ep[i];\n          endpointsToPaint.add(anEndpoint);\n          a = anEndpoint._anchor;\n\n          if (anEndpoint.connections.length === 0) {\n            if (isContinuous(a)) {\n              if (!this.anchorLists.has(elementId)) {\n                this.anchorLists.set(elementId, {\n                  top: [],\n                  right: [],\n                  bottom: [],\n                  left: []\n                });\n              }\n\n              this._updateAnchorList(this.anchorLists.get(elementId), -Math.PI / 2, 0, {\n                endpoints: [anEndpoint, anEndpoint],\n                placeholder: true\n              }, false, elementId, 0, false, getDefaultFace(a), connectionsToPaint, endpointsToPaint);\n\n              anchorsToUpdate.add(elementId);\n            }\n          } else {\n            for (var _i2 = 0; _i2 < anEndpoint.connections.length; _i2++) {\n              var conn = anEndpoint.connections[_i2],\n                  sourceId = conn.sourceId,\n                  targetId = conn.targetId,\n                  sourceContinuous = isContinuous(conn.endpoints[0]._anchor),\n                  targetContinuous = isContinuous(conn.endpoints[1]._anchor);\n\n              if (sourceContinuous || targetContinuous) {\n                var c1 = (conn.endpoints[0]._anchor.faces || []).join(\"-\"),\n                    c2 = (conn.endpoints[1]._anchor.faces || []).join(\"-\"),\n                    oKey = [sourceId, c1, targetId, c2].join(\"-\"),\n                    o = orientationCache[oKey],\n                    oIdx = conn.sourceId === elementId ? 1 : 0;\n\n                if (sourceContinuous && !this.anchorLists.has(sourceId)) {\n                  this.anchorLists.set(sourceId, {\n                    top: [],\n                    right: [],\n                    bottom: [],\n                    left: []\n                  });\n                }\n\n                if (targetContinuous && !this.anchorLists.has(targetId)) {\n                  this.anchorLists.set(targetId, {\n                    top: [],\n                    right: [],\n                    bottom: [],\n                    left: []\n                  });\n                }\n\n                var td = this.instance.viewport.getPosition(targetId),\n                    sd = this.instance.viewport.getPosition(sourceId);\n\n                if (targetId === sourceId && (sourceContinuous || targetContinuous)) {\n                  this._updateAnchorList(this.anchorLists.get(sourceId), -Math.PI / 2, 0, conn, false, targetId, 0, false, TOP, connectionsToPaint, endpointsToPaint);\n\n                  this._updateAnchorList(this.anchorLists.get(targetId), -Math.PI / 2, 0, conn, false, sourceId, 1, false, TOP, connectionsToPaint, endpointsToPaint);\n                } else {\n                  var sourceRotation = this.instance._getRotations(sourceId);\n\n                  var targetRotation = this.instance._getRotations(targetId);\n\n                  if (!o) {\n                    o = this._calculateOrientation(sourceId, targetId, sd, td, conn.endpoints[0]._anchor, conn.endpoints[1]._anchor, sourceRotation, targetRotation);\n                    orientationCache[oKey] = o;\n                  }\n\n                  if (sourceContinuous) {\n                    this._updateAnchorList(this.anchorLists.get(sourceId), o.theta, 0, conn, false, targetId, 0, false, o.a[0], connectionsToPaint, endpointsToPaint);\n                  }\n\n                  if (targetContinuous) {\n                    this._updateAnchorList(this.anchorLists.get(targetId), o.theta2, -1, conn, true, sourceId, 1, true, o.a[1], connectionsToPaint, endpointsToPaint);\n                  }\n                }\n\n                if (sourceContinuous) {\n                  anchorsToUpdate.add(sourceId);\n                }\n\n                if (targetContinuous) {\n                  anchorsToUpdate.add(targetId);\n                }\n\n                connectionsToPaint.add(conn);\n\n                if (sourceContinuous && oIdx === 0 || targetContinuous && oIdx === 1) {\n                  endpointsToPaint.add(conn.endpoints[oIdx]);\n                }\n              } else {\n                var otherEndpoint = anEndpoint.connections[_i2].endpoints[conn.sourceId === elementId ? 1 : 0],\n                    otherAnchor = otherEndpoint._anchor;\n\n                if (isDynamic(otherAnchor)) {\n                  this.instance._paintEndpoint(otherEndpoint, {\n                    elementWithPrecedence: elementId,\n                    timestamp: timestamp\n                  });\n\n                  connectionsToPaint.add(anEndpoint.connections[_i2]);\n\n                  for (var k = 0; k < otherEndpoint.connections.length; k++) {\n                    if (otherEndpoint.connections[k] !== anEndpoint.connections[_i2]) {\n                      connectionsToPaint.add(otherEndpoint.connections[k]);\n                    }\n                  }\n                } else {\n                  connectionsToPaint.add(anEndpoint.connections[_i2]);\n                }\n              }\n            }\n          }\n        }\n\n        anchorsToUpdate.forEach(function (anchor) {\n          _this3._placeAnchors(anchor, _this3.anchorLists.get(anchor));\n        });\n        endpointsToPaint.forEach(function (ep) {\n          var cd = _this3.instance.viewport.getPosition(ep.elementId);\n\n          _this3.instance._paintEndpoint(ep, {\n            timestamp: timestamp,\n            offset: cd\n          });\n        });\n        connectionsToPaint.forEach(function (c) {\n          _this3.instance._paintConnection(c, {\n            timestamp: timestamp\n          });\n        });\n      }\n\n      return {\n        c: connectionsToPaint,\n        e: endpointsToPaint\n      };\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.anchorLocations.clear();\n      this.anchorLists.clear();\n    }\n  }, {\n    key: \"setAnchor\",\n    value: function setAnchor(endpoint, anchor) {\n      if (anchor != null) {\n        endpoint._anchor = anchor;\n      }\n    }\n  }, {\n    key: \"setConnectionAnchors\",\n    value: function setConnectionAnchors(conn, anchors) {\n      conn.endpoints[0]._anchor = anchors[0];\n      conn.endpoints[1]._anchor = anchors[1];\n    }\n  }, {\n    key: \"_calculateOrientation\",\n    value: function _calculateOrientation(sourceId, targetId, sd, td, sourceAnchor, targetAnchor, sourceRotation, targetRotation) {\n      var _this4 = this;\n\n      var Orientation = {\n        HORIZONTAL: \"horizontal\",\n        VERTICAL: \"vertical\",\n        DIAGONAL: \"diagonal\",\n        IDENTITY: \"identity\"\n      };\n\n      if (sourceId === targetId) {\n        return {\n          orientation: Orientation.IDENTITY,\n          a: [TOP, TOP]\n        };\n      }\n\n      var theta = Math.atan2(td.c.y - sd.c.y, td.c.x - sd.c.x),\n          theta2 = Math.atan2(sd.c.y - td.c.y, sd.c.x - td.c.x);\n      var candidates = [],\n          midpoints = {};\n\n      (function (types, dim) {\n        for (var i = 0; i < types.length; i++) {\n          var _midpoints$types$i;\n\n          midpoints[types[i]] = (_midpoints$types$i = {}, _defineProperty(_midpoints$types$i, LEFT, {\n            x: dim[i][0].x,\n            y: dim[i][0].c.y\n          }), _defineProperty(_midpoints$types$i, RIGHT, {\n            x: dim[i][0].x + dim[i][0].w,\n            y: dim[i][0].c.y\n          }), _defineProperty(_midpoints$types$i, TOP, {\n            x: dim[i][0].c.x,\n            y: dim[i][0].y\n          }), _defineProperty(_midpoints$types$i, BOTTOM, {\n            x: dim[i][0].c.x,\n            y: dim[i][0].y + dim[i][0].h\n          }), _midpoints$types$i);\n\n          if (dim[i][1] != null && dim[i][1].length > 0) {\n            for (var axis in midpoints[types[i]]) {\n              midpoints[types[i]][axis] = _this4.instance._applyRotationsXY(midpoints[types[i]][axis], dim[i][1]);\n            }\n          }\n        }\n      })([SOURCE, TARGET], [[sd, sourceRotation], [td, targetRotation]]);\n\n      var FACES = [TOP, LEFT, RIGHT, BOTTOM];\n\n      for (var sf = 0; sf < FACES.length; sf++) {\n        for (var tf = 0; tf < FACES.length; tf++) {\n          candidates.push({\n            source: FACES[sf],\n            target: FACES[tf],\n            dist: (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.lineLength)(midpoints.source[FACES[sf]], midpoints.target[FACES[tf]])\n          });\n        }\n      }\n\n      candidates.sort(function (a, b) {\n        if (a.dist < b.dist) {\n          return -1;\n        } else if (b.dist < a.dist) {\n          return 1;\n        } else {\n          var _axisIndices;\n\n          var axisIndices = (_axisIndices = {}, _defineProperty(_axisIndices, LEFT, 0), _defineProperty(_axisIndices, TOP, 1), _defineProperty(_axisIndices, RIGHT, 2), _defineProperty(_axisIndices, BOTTOM, 3), _axisIndices),\n              ais = axisIndices[a.source],\n              bis = axisIndices[b.source],\n              ait = axisIndices[a.target],\n              bit = axisIndices[b.target];\n          return ais < bis ? -1 : bis < ais ? 1 : ait < bit ? -1 : bit < ait ? 1 : 0;\n        }\n      });\n      var sourceEdge = candidates[0].source,\n          targetEdge = candidates[0].target;\n\n      for (var i = 0; i < candidates.length; i++) {\n        if (isContinuous(sourceAnchor) && sourceAnchor.locked) {\n          sourceEdge = sourceAnchor.currentFace;\n        } else if (!sourceAnchor.isContinuous || isEdgeSupported(sourceAnchor, candidates[i].source)) {\n          sourceEdge = candidates[i].source;\n        } else {\n          sourceEdge = null;\n        }\n\n        if (targetAnchor.isContinuous && targetAnchor.locked) {\n          targetEdge = targetAnchor.currentFace;\n        } else if (!targetAnchor.isContinuous || isEdgeSupported(targetAnchor, candidates[i].target)) {\n          targetEdge = candidates[i].target;\n        } else {\n          targetEdge = null;\n        }\n\n        if (sourceEdge != null && targetEdge != null) {\n          break;\n        }\n      }\n\n      if (sourceAnchor.isContinuous) {\n        this.setCurrentFace(sourceAnchor, sourceEdge);\n      }\n\n      if (targetAnchor.isContinuous) {\n        this.setCurrentFace(targetAnchor, targetEdge);\n      }\n\n      return {\n        a: [sourceEdge, targetEdge],\n        theta: theta,\n        theta2: theta2\n      };\n    }\n  }, {\n    key: \"setCurrentFace\",\n    value: function setCurrentFace(a, face, overrideLock) {\n      a.currentFace = face;\n\n      if (overrideLock && a.lockedFace != null) {\n        a.lockedFace = a.currentFace;\n      }\n    }\n  }, {\n    key: \"lock\",\n    value: function lock(a) {\n      a.locked = true;\n\n      if (isContinuous(a)) {\n        a.lockedFace = a.currentFace;\n      }\n    }\n  }, {\n    key: \"unlock\",\n    value: function unlock(a) {\n      a.locked = false;\n\n      if (isContinuous(a)) {\n        a.lockedFace = null;\n      }\n    }\n  }, {\n    key: \"selectAnchorLocation\",\n    value: function selectAnchorLocation(a, coords) {\n      var idx = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.findWithFunction)(a.locations, function (loc) {\n        return loc.x === coords.x && loc.y === coords.y;\n      });\n\n      if (idx !== -1) {\n        a.currentLocation = idx;\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"lockCurrentAxis\",\n    value: function lockCurrentAxis(a) {\n      if (a.currentFace != null) {\n        a.lockedAxis = a.currentFace === LEFT || a.currentFace === RIGHT ? X_AXIS_FACES : Y_AXIS_FACES;\n      }\n    }\n  }, {\n    key: \"unlockCurrentAxis\",\n    value: function unlockCurrentAxis(a) {\n      a.lockedAxis = null;\n    }\n  }, {\n    key: \"anchorsEqual\",\n    value: function anchorsEqual(a1, a2) {\n      if (!a1 || !a2) {\n        return false;\n      }\n\n      var l1 = a1.locations[a1.currentLocation],\n          l2 = a2.locations[a2.currentLocation];\n      return l1.x === l2.x && l1.y === l2.y && l1.offx === l2.offx && l1.offy === l2.offy && l1.ox === l2.ox && l1.oy === l2.oy;\n    }\n  }]);\n\n  return LightweightRouter;\n}();\n\nfunction _scopeMatch(e1, e2) {\n  var s1 = e1.scope.split(/\\s/),\n      s2 = e2.scope.split(/\\s/);\n\n  for (var i = 0; i < s1.length; i++) {\n    for (var j = 0; j < s2.length; j++) {\n      if (s2[j] === s1[i]) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction prepareList(instance, input, doNotGetIds) {\n  var r = [];\n\n  var _resolveId = function _resolveId(i) {\n    if ((0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.isString)(i)) {\n      return i;\n    } else {\n      return instance.getId(i);\n    }\n  };\n\n  if (input) {\n    if (typeof input === 'string') {\n      if (input === \"*\") {\n        return input;\n      }\n\n      r.push(input);\n    } else {\n      if (doNotGetIds) {\n        r = input;\n      } else {\n        if (input.length != null) {\n          var _r;\n\n          (_r = r).push.apply(_r, _toConsumableArray(_toConsumableArray(input).map(_resolveId)));\n        } else {\n          r.push(_resolveId(input));\n        }\n      }\n    }\n  }\n\n  return r;\n}\n\nfunction addManagedEndpoint(managedElement, ep) {\n  if (managedElement != null) {\n    managedElement.endpoints.push(ep);\n  }\n}\n\nfunction removeManagedEndpoint(managedElement, endpoint) {\n  if (managedElement != null) {\n    (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.removeWithFunction)(managedElement.endpoints, function (ep) {\n      return ep === endpoint;\n    });\n  }\n}\n\nfunction addManagedConnection(connection, sourceEl, targetEl) {\n  if (sourceEl != null) {\n    sourceEl.connections.push(connection);\n\n    if (sourceEl.connections.length === 1) {\n      connection.instance.addClass(connection.source, connection.instance.connectedClass);\n    }\n  }\n\n  if (targetEl != null) {\n    if (sourceEl == null || connection.sourceId !== connection.targetId) {\n      targetEl.connections.push(connection);\n\n      if (targetEl.connections.length === 1) {\n        connection.instance.addClass(connection.target, connection.instance.connectedClass);\n      }\n    }\n  }\n}\n\nfunction removeManagedConnection(connection, sourceEl, targetEl) {\n  if (sourceEl != null) {\n    var sourceCount = sourceEl.connections.length;\n    (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.removeWithFunction)(sourceEl.connections, function (_c) {\n      return connection.id === _c.id;\n    });\n\n    if (sourceCount > 0 && sourceEl.connections.length === 0) {\n      connection.instance.removeClass(connection.source, connection.instance.connectedClass);\n    }\n  }\n\n  if (targetEl != null) {\n    var targetCount = targetEl.connections.length;\n\n    if (sourceEl == null || connection.sourceId !== connection.targetId) {\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.removeWithFunction)(targetEl.connections, function (_c) {\n        return connection.id === _c.id;\n      });\n    }\n\n    if (targetCount > 0 && targetEl.connections.length === 0) {\n      connection.instance.removeClass(connection.target, connection.instance.connectedClass);\n    }\n  }\n}\n\nvar JsPlumbInstance = function (_EventGenerator) {\n  _inherits(JsPlumbInstance, _EventGenerator);\n\n  var _super = _createSuper(JsPlumbInstance);\n\n  function JsPlumbInstance(_instanceIndex, defaults) {\n    var _this;\n\n    _classCallCheck(this, JsPlumbInstance);\n\n    _this = _super.call(this);\n    _this._instanceIndex = _instanceIndex;\n\n    _defineProperty(_assertThisInitialized(_this), \"defaults\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_initialDefaults\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"isConnectionBeingDragged\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"currentlyDragging\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"hoverSuspended\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"_suspendDrawing\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"_suspendedAt\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"connectorClass\", CLASS_CONNECTOR);\n\n    _defineProperty(_assertThisInitialized(_this), \"connectorOutlineClass\", CLASS_CONNECTOR_OUTLINE);\n\n    _defineProperty(_assertThisInitialized(_this), \"connectedClass\", CLASS_CONNECTED);\n\n    _defineProperty(_assertThisInitialized(_this), \"endpointClass\", CLASS_ENDPOINT);\n\n    _defineProperty(_assertThisInitialized(_this), \"endpointConnectedClass\", CLASS_ENDPOINT_CONNECTED);\n\n    _defineProperty(_assertThisInitialized(_this), \"endpointFullClass\", CLASS_ENDPOINT_FULL);\n\n    _defineProperty(_assertThisInitialized(_this), \"endpointDropAllowedClass\", CLASS_ENDPOINT_DROP_ALLOWED);\n\n    _defineProperty(_assertThisInitialized(_this), \"endpointDropForbiddenClass\", CLASS_ENDPOINT_DROP_FORBIDDEN);\n\n    _defineProperty(_assertThisInitialized(_this), \"endpointAnchorClassPrefix\", CLASS_ENDPOINT_ANCHOR_PREFIX);\n\n    _defineProperty(_assertThisInitialized(_this), \"overlayClass\", CLASS_OVERLAY);\n\n    _defineProperty(_assertThisInitialized(_this), \"connections\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"endpointsByElement\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"endpointsByUUID\", new Map());\n\n    _defineProperty(_assertThisInitialized(_this), \"sourceSelectors\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"targetSelectors\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"allowNestedGroups\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_curIdStamp\", 1);\n\n    _defineProperty(_assertThisInitialized(_this), \"viewport\", new Viewport(_assertThisInitialized(_this)));\n\n    _defineProperty(_assertThisInitialized(_this), \"router\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"groupManager\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_connectionTypes\", new Map());\n\n    _defineProperty(_assertThisInitialized(_this), \"_endpointTypes\", new Map());\n\n    _defineProperty(_assertThisInitialized(_this), \"_container\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_managedElements\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"DEFAULT_SCOPE\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_zoom\", 1);\n\n    _this.defaults = {\n      anchor: _jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.AnchorLocations.Bottom,\n      anchors: [null, null],\n      connectionsDetachable: true,\n      connectionOverlays: [],\n      connector: StraightConnector.type,\n      container: null,\n      endpoint: DotEndpoint.type,\n      endpointOverlays: [],\n      endpoints: [null, null],\n      endpointStyle: {\n        fill: \"#456\"\n      },\n      endpointStyles: [null, null],\n      endpointHoverStyle: null,\n      endpointHoverStyles: [null, null],\n      hoverPaintStyle: null,\n      listStyle: {},\n      maxConnections: 1,\n      paintStyle: {\n        strokeWidth: 2,\n        stroke: \"#456\"\n      },\n      reattachConnections: false,\n      scope: \"jsplumb_defaultscope\",\n      allowNestedGroups: true\n    };\n\n    if (defaults) {\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)(_this.defaults, defaults);\n    }\n\n    (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)(_this._initialDefaults, _this.defaults);\n    _this.DEFAULT_SCOPE = _this.defaults.scope;\n    _this.allowNestedGroups = _this._initialDefaults.allowNestedGroups !== false;\n    _this.router = new LightweightRouter(_assertThisInitialized(_this));\n    _this.groupManager = new GroupManager(_assertThisInitialized(_this));\n\n    _this.setContainer(_this._initialDefaults.container);\n\n    return _this;\n  }\n\n  _createClass(JsPlumbInstance, [{\n    key: \"defaultScope\",\n    get: function get() {\n      return this.DEFAULT_SCOPE;\n    }\n  }, {\n    key: \"currentZoom\",\n    get: function get() {\n      return this._zoom;\n    }\n  }, {\n    key: \"areDefaultAnchorsSet\",\n    value: function areDefaultAnchorsSet() {\n      return this.validAnchorsSpec(this.defaults.anchors);\n    }\n  }, {\n    key: \"validAnchorsSpec\",\n    value: function validAnchorsSpec(anchors) {\n      return anchors != null && anchors[0] != null && anchors[1] != null;\n    }\n  }, {\n    key: \"getContainer\",\n    value: function getContainer() {\n      return this._container;\n    }\n  }, {\n    key: \"setZoom\",\n    value: function setZoom(z, repaintEverything) {\n      this._zoom = z;\n      this.fire(EVENT_ZOOM, this._zoom);\n\n      if (repaintEverything) {\n        this.repaintEverything();\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_idstamp\",\n    value: function _idstamp() {\n      return \"\" + this._curIdStamp++;\n    }\n  }, {\n    key: \"checkCondition\",\n    value: function checkCondition(conditionName, args) {\n      var l = this.getListener(conditionName),\n          r = true;\n\n      if (l && l.length > 0) {\n        var values = Array.prototype.slice.call(arguments, 1);\n\n        try {\n          for (var i = 0, j = l.length; i < j; i++) {\n            r = r && l[i].apply(l[i], values);\n          }\n        } catch (e) {\n          (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.log)(\"cannot check condition [\" + conditionName + \"]\" + e);\n        }\n      }\n\n      return r;\n    }\n  }, {\n    key: \"getId\",\n    value: function getId(element, uuid) {\n      if (element == null) {\n        return null;\n      }\n\n      var id = this.getAttribute(element, ATTRIBUTE_MANAGED);\n\n      if (!id || id === \"undefined\") {\n        if (arguments.length === 2 && arguments[1] !== undefined) {\n          id = uuid;\n        } else if (arguments.length === 1 || arguments.length === 3 && !arguments[2]) {\n          id = \"jsplumb-\" + this._instanceIndex + \"-\" + this._idstamp();\n        }\n\n        this.setAttribute(element, ATTRIBUTE_MANAGED, id);\n      }\n\n      return id;\n    }\n  }, {\n    key: \"getConnections\",\n    value: function getConnections(options, flat) {\n      if (!options) {\n        options = {};\n      } else if (options.constructor === String) {\n        options = {\n          \"scope\": options\n        };\n      }\n\n      var scope = options.scope || this.defaultScope,\n          scopes = prepareList(this, scope, true),\n          sources = prepareList(this, options.source),\n          targets = prepareList(this, options.target),\n          results = !flat && scopes.length > 1 ? {} : [],\n          _addOne = function _addOne(scope, obj) {\n        if (!flat && scopes.length > 1) {\n          var ss = results[scope];\n\n          if (ss == null) {\n            ss = results[scope] = [];\n          }\n\n          ss.push(obj);\n        } else {\n          results.push(obj);\n        }\n      };\n\n      for (var j = 0, jj = this.connections.length; j < jj; j++) {\n        var _c2 = this.connections[j],\n            sourceId = _c2.proxies && _c2.proxies[0] ? _c2.proxies[0].originalEp.elementId : _c2.sourceId,\n            targetId = _c2.proxies && _c2.proxies[1] ? _c2.proxies[1].originalEp.elementId : _c2.targetId;\n\n        if ((0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.filterList)(scopes, _c2.scope) && (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.filterList)(sources, sourceId) && (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.filterList)(targets, targetId)) {\n          _addOne(_c2.scope, _c2);\n        }\n      }\n\n      return results;\n    }\n  }, {\n    key: \"select\",\n    value: function select(params) {\n      params = params || {};\n      params.scope = params.scope || \"*\";\n      return new ConnectionSelection(this, params.connections || this.getConnections(params, true));\n    }\n  }, {\n    key: \"selectEndpoints\",\n    value: function selectEndpoints(params) {\n      params = params || {};\n      params.scope = params.scope || _jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.WILDCARD;\n      var noElementFilters = !params.element && !params.source && !params.target,\n          elements = noElementFilters ? _jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.WILDCARD : prepareList(this, params.element),\n          sources = noElementFilters ? _jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.WILDCARD : prepareList(this, params.source),\n          targets = noElementFilters ? _jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.WILDCARD : prepareList(this, params.target),\n          scopes = prepareList(this, params.scope, true);\n      var ep = [];\n\n      for (var _el2 in this.endpointsByElement) {\n        var either = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.filterList)(elements, _el2, true),\n            source = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.filterList)(sources, _el2, true),\n            sourceMatchExact = sources !== \"*\",\n            target = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.filterList)(targets, _el2, true),\n            targetMatchExact = targets !== \"*\";\n\n        if (either || source || target) {\n          inner: for (var i = 0, ii = this.endpointsByElement[_el2].length; i < ii; i++) {\n            var _ep = this.endpointsByElement[_el2][i];\n\n            if ((0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.filterList)(scopes, _ep.scope, true)) {\n              var noMatchSource = sourceMatchExact && sources.length > 0 && !_ep.isSource,\n                  noMatchTarget = targetMatchExact && targets.length > 0 && !_ep.isTarget;\n\n              if (noMatchSource || noMatchTarget) {\n                continue inner;\n              }\n\n              ep.push(_ep);\n            }\n          }\n        }\n      }\n\n      return new EndpointSelection(this, ep);\n    }\n  }, {\n    key: \"setContainer\",\n    value: function setContainer(c) {\n      this._container = c;\n      this.fire(EVENT_CONTAINER_CHANGE, this._container);\n    }\n  }, {\n    key: \"_set\",\n    value: function _set(c, el, idx) {\n      var stTypes = [{\n        el: \"source\",\n        elId: \"sourceId\"\n      }, {\n        el: \"target\",\n        elId: \"targetId\"\n      }];\n      var ep,\n          _st = stTypes[idx],\n          cId = c[_st.elId],\n          sid,\n          oldEndpoint = c.endpoints[idx];\n      var evtParams = {\n        index: idx,\n        originalEndpoint: oldEndpoint,\n        originalSourceId: idx === 0 ? cId : c.sourceId,\n        newSourceId: c.sourceId,\n        originalTargetId: idx === 1 ? cId : c.targetId,\n        newTargetId: c.targetId,\n        connection: c,\n        newEndpoint: oldEndpoint\n      };\n\n      if (el instanceof Endpoint) {\n        ep = el;\n        ep.addConnection(c);\n      } else {\n        sid = this.getId(el);\n\n        if (sid === c[_st.elId]) {\n          ep = null;\n        } else {\n          ep = c.makeEndpoint(idx === 0, el, sid);\n        }\n      }\n\n      if (ep != null) {\n        evtParams.newEndpoint = ep;\n        oldEndpoint.detachFromConnection(c);\n        c.endpoints[idx] = ep;\n        c[_st.el] = ep.element;\n        c[_st.elId] = ep.elementId;\n        evtParams[idx === 0 ? \"newSourceId\" : \"newTargetId\"] = ep.elementId;\n        this.fireMoveEvent(evtParams);\n\n        this._paintConnection(c);\n      }\n\n      return evtParams;\n    }\n  }, {\n    key: \"setSource\",\n    value: function setSource(connection, el) {\n      removeManagedConnection(connection, this._managedElements[connection.sourceId]);\n\n      var p = this._set(connection, el, 0);\n\n      addManagedConnection(connection, this._managedElements[p.newSourceId]);\n    }\n  }, {\n    key: \"setTarget\",\n    value: function setTarget(connection, el) {\n      removeManagedConnection(connection, this._managedElements[connection.targetId]);\n\n      var p = this._set(connection, el, 1);\n\n      addManagedConnection(connection, this._managedElements[p.newTargetId]);\n    }\n  }, {\n    key: \"isHoverSuspended\",\n    value: function isHoverSuspended() {\n      return this.hoverSuspended;\n    }\n  }, {\n    key: \"setSuspendDrawing\",\n    value: function setSuspendDrawing(val, repaintAfterwards) {\n      var curVal = this._suspendDrawing;\n      this._suspendDrawing = val;\n\n      if (val) {\n        this._suspendedAt = \"\" + new Date().getTime();\n      } else {\n        this._suspendedAt = null;\n        this.viewport.recomputeBounds();\n      }\n\n      if (repaintAfterwards) {\n        this.repaintEverything();\n      }\n\n      return curVal;\n    }\n  }, {\n    key: \"getSuspendedAt\",\n    value: function getSuspendedAt() {\n      return this._suspendedAt;\n    }\n  }, {\n    key: \"batch\",\n    value: function batch(fn, doNotRepaintAfterwards) {\n      var _wasSuspended = this._suspendDrawing === true;\n\n      if (!_wasSuspended) {\n        this.setSuspendDrawing(true);\n      }\n\n      fn();\n\n      if (!_wasSuspended) {\n        this.setSuspendDrawing(false, !doNotRepaintAfterwards);\n      }\n    }\n  }, {\n    key: \"each\",\n    value: function each(spec, fn) {\n      if (spec == null) {\n        return;\n      }\n\n      if (spec.length != null) {\n        for (var i = 0; i < spec.length; i++) {\n          fn(spec[i]);\n        }\n      } else {\n        fn(spec);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"updateOffset\",\n    value: function updateOffset(params) {\n      var elId = params.elId;\n\n      if (params.recalc) {\n        return this.viewport.refreshElement(elId);\n      } else {\n        return this.viewport.getPosition(elId);\n      }\n    }\n  }, {\n    key: \"deleteConnection\",\n    value: function deleteConnection(connection, params) {\n      if (connection != null && connection.deleted !== true) {\n        params = params || {};\n\n        if (params.force || (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.functionChain)(true, false, [[connection.endpoints[0], IS_DETACH_ALLOWED, [connection]], [connection.endpoints[1], IS_DETACH_ALLOWED, [connection]], [connection, IS_DETACH_ALLOWED, [connection]], [this, CHECK_CONDITION, [INTERCEPT_BEFORE_DETACH, connection]]])) {\n          removeManagedConnection(connection, this._managedElements[connection.sourceId], this._managedElements[connection.targetId]);\n          this.fireDetachEvent(connection, !connection.pending && params.fireEvent !== false, params.originalEvent);\n          var _sourceEndpoint = connection.endpoints[0];\n          var targetEndpoint = connection.endpoints[1];\n\n          if (_sourceEndpoint !== params.endpointToIgnore) {\n            _sourceEndpoint.detachFromConnection(connection, null, true);\n          }\n\n          if (targetEndpoint !== params.endpointToIgnore) {\n            targetEndpoint.detachFromConnection(connection, null, true);\n          }\n\n          (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.removeWithFunction)(this.connections, function (_c) {\n            return connection.id === _c.id;\n          });\n          connection.destroy();\n\n          if (_sourceEndpoint !== params.endpointToIgnore && _sourceEndpoint.deleteOnEmpty && _sourceEndpoint.connections.length === 0) {\n            this.deleteEndpoint(_sourceEndpoint);\n          }\n\n          if (targetEndpoint !== params.endpointToIgnore && targetEndpoint.deleteOnEmpty && targetEndpoint.connections.length === 0) {\n            this.deleteEndpoint(targetEndpoint);\n          }\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"deleteEveryConnection\",\n    value: function deleteEveryConnection(params) {\n      var _this2 = this;\n\n      params = params || {};\n      var count = this.connections.length,\n          deletedCount = 0;\n      this.batch(function () {\n        for (var i = 0; i < count; i++) {\n          deletedCount += _this2.deleteConnection(_this2.connections[0], params) ? 1 : 0;\n        }\n      });\n      return deletedCount;\n    }\n  }, {\n    key: \"deleteConnectionsForElement\",\n    value: function deleteConnectionsForElement(el, params) {\n      var id = this.getId(el),\n          m = this._managedElements[id];\n\n      if (m) {\n        var l = m.connections.length;\n\n        for (var i = 0; i < l; i++) {\n          this.deleteConnection(m.connections[0], params);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"fireDetachEvent\",\n    value: function fireDetachEvent(jpc, doFireEvent, originalEvent) {\n      var argIsConnection = jpc.id != null,\n          params = argIsConnection ? {\n        connection: jpc,\n        source: jpc.source,\n        target: jpc.target,\n        sourceId: jpc.sourceId,\n        targetId: jpc.targetId,\n        sourceEndpoint: jpc.endpoints[0],\n        targetEndpoint: jpc.endpoints[1]\n      } : jpc;\n\n      if (doFireEvent) {\n        this.fire(EVENT_CONNECTION_DETACHED, params, originalEvent);\n      }\n\n      this.fire(EVENT_INTERNAL_CONNECTION_DETACHED, params, originalEvent);\n    }\n  }, {\n    key: \"fireMoveEvent\",\n    value: function fireMoveEvent(params, evt) {\n      this.fire(EVENT_CONNECTION_MOVED, params, evt);\n    }\n  }, {\n    key: \"manageAll\",\n    value: function manageAll(elements, recalc) {\n      var nl = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.isString)(elements) ? this.getSelector(this.getContainer(), elements) : elements;\n\n      for (var i = 0; i < nl.length; i++) {\n        this.manage(nl[i], null, recalc);\n      }\n    }\n  }, {\n    key: \"manage\",\n    value: function manage(element, internalId, _recalc) {\n      if (this.getAttribute(element, ATTRIBUTE_MANAGED) == null) {\n        internalId = internalId || this.getAttribute(element, \"id\") || (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.uuid)();\n        this.setAttribute(element, ATTRIBUTE_MANAGED, internalId);\n      }\n\n      var elId = this.getId(element);\n\n      if (!this._managedElements[elId]) {\n        var obj = {\n          el: element,\n          endpoints: [],\n          connections: [],\n          rotation: 0,\n          data: {}\n        };\n        this._managedElements[elId] = obj;\n\n        if (this._suspendDrawing) {\n          obj.viewportElement = this.viewport.registerElement(elId, true);\n        } else {\n          obj.viewportElement = this.updateOffset({\n            elId: elId,\n            recalc: true\n          });\n        }\n\n        this.fire(EVENT_MANAGE_ELEMENT, {\n          el: element\n        });\n      } else {\n        if (_recalc) {\n          this._managedElements[elId].viewportElement = this.updateOffset({\n            elId: elId,\n            timestamp: null,\n            recalc: true\n          });\n        }\n      }\n\n      return this._managedElements[elId];\n    }\n  }, {\n    key: \"getManagedData\",\n    value: function getManagedData(elementId, dataIdentifier, key) {\n      if (this._managedElements[elementId]) {\n        var data = this._managedElements[elementId].data[dataIdentifier];\n        return data != null ? data[key] : null;\n      }\n    }\n  }, {\n    key: \"setManagedData\",\n    value: function setManagedData(elementId, dataIdentifier, key, data) {\n      if (this._managedElements[elementId]) {\n        this._managedElements[elementId].data[dataIdentifier] = this._managedElements[elementId].data[dataIdentifier] || {};\n        this._managedElements[elementId].data[dataIdentifier][key] = data;\n      }\n    }\n  }, {\n    key: \"getManagedElement\",\n    value: function getManagedElement(id) {\n      return this._managedElements[id] ? this._managedElements[id].el : null;\n    }\n  }, {\n    key: \"unmanage\",\n    value: function unmanage(el, removeElement) {\n      var _this3 = this;\n\n      this.removeAllEndpoints(el, true);\n\n      var _one = function _one(_el) {\n        var id = _this3.getId(_el);\n\n        _this3.removeAttribute(_el, ATTRIBUTE_MANAGED);\n\n        delete _this3._managedElements[id];\n\n        _this3.viewport.remove(id);\n\n        _this3.fire(EVENT_UNMANAGE_ELEMENT, {\n          el: _el\n        });\n\n        if (_el && removeElement) {\n          _this3._removeElement(_el);\n        }\n      };\n\n      this._getAssociatedElements(el).map(_one);\n\n      _one(el);\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(element, rotation, _doNotRepaint) {\n      var elementId = this.getId(element);\n\n      if (this._managedElements[elementId]) {\n        this._managedElements[elementId].rotation = rotation;\n        this.viewport.rotateElement(elementId, rotation);\n\n        if (_doNotRepaint !== true) {\n          return this.revalidate(element);\n        }\n      }\n\n      return {\n        c: new Set(),\n        e: new Set()\n      };\n    }\n  }, {\n    key: \"_getRotation\",\n    value: function _getRotation(elementId) {\n      var entry = this._managedElements[elementId];\n\n      if (entry != null) {\n        return entry.rotation || 0;\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: \"_getRotations\",\n    value: function _getRotations(elementId) {\n      var _this4 = this;\n\n      var rotations = [];\n      var entry = this._managedElements[elementId];\n\n      var _oneLevel = function _oneLevel(e) {\n        if (e.group != null) {\n          var gEntry = _this4._managedElements[e.group];\n\n          if (gEntry != null) {\n            rotations.push({\n              r: gEntry.viewportElement.r,\n              c: gEntry.viewportElement.c\n            });\n\n            _oneLevel(gEntry);\n          }\n        }\n      };\n\n      if (entry != null) {\n        rotations.push({\n          r: entry.viewportElement.r || 0,\n          c: entry.viewportElement.c\n        });\n\n        _oneLevel(entry);\n      }\n\n      return rotations;\n    }\n  }, {\n    key: \"_applyRotations\",\n    value: function _applyRotations(point, rotations) {\n      var sl = point.slice();\n      var current = {\n        x: sl[0],\n        y: sl[1],\n        cr: 0,\n        sr: 0\n      };\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.forEach)(rotations, function (rotation) {\n        current = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.rotatePoint)(current, rotation.c, rotation.r);\n      });\n      return current;\n    }\n  }, {\n    key: \"_applyRotationsXY\",\n    value: function _applyRotationsXY(point, rotations) {\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.forEach)(rotations, function (rotation) {\n        point = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.rotatePoint)(point, rotation.c, rotation.r);\n      });\n      return point;\n    }\n  }, {\n    key: \"_internal_newEndpoint\",\n    value: function _internal_newEndpoint(params) {\n      var _p = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, params);\n\n      var managedElement = this.manage(_p.element);\n      _p.elementId = this.getId(_p.element);\n      _p.id = \"ep_\" + this._idstamp();\n      var ep = new Endpoint(this, _p);\n      addManagedEndpoint(managedElement, ep);\n\n      if (params.uuid) {\n        this.endpointsByUUID.set(params.uuid, ep);\n      }\n\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.addToDictionary)(this.endpointsByElement, ep.elementId, ep);\n\n      if (!this._suspendDrawing) {\n        this._paintEndpoint(ep, {\n          timestamp: this._suspendedAt\n        });\n      }\n\n      return ep;\n    }\n  }, {\n    key: \"_deriveEndpointAndAnchorSpec\",\n    value: function _deriveEndpointAndAnchorSpec(type, dontPrependDefault) {\n      var bits = ((dontPrependDefault ? \"\" : \"default \") + type).split(/[\\s]/),\n          eps = null,\n          ep = null,\n          a = null,\n          as = null;\n\n      for (var i = 0; i < bits.length; i++) {\n        var _t = this.getConnectionType(bits[i]);\n\n        if (_t) {\n          if (_t.endpoints) {\n            eps = _t.endpoints;\n          }\n\n          if (_t.endpoint) {\n            ep = _t.endpoint;\n          }\n\n          if (_t.anchors) {\n            as = _t.anchors;\n          }\n\n          if (_t.anchor) {\n            a = _t.anchor;\n          }\n        }\n      }\n\n      return {\n        endpoints: eps ? eps : [ep, ep],\n        anchors: as ? as : [a, a]\n      };\n    }\n  }, {\n    key: \"revalidate\",\n    value: function revalidate(el, timestamp) {\n      var elId = this.getId(el);\n      this.updateOffset({\n        elId: elId,\n        recalc: true,\n        timestamp: timestamp\n      });\n      return this.repaint(el);\n    }\n  }, {\n    key: \"repaintEverything\",\n    value: function repaintEverything() {\n      var timestamp = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.uuid)(),\n          elId;\n\n      for (elId in this._managedElements) {\n        this.viewport.refreshElement(elId, true);\n      }\n\n      this.viewport.recomputeBounds();\n\n      for (elId in this._managedElements) {\n        this.repaint(this._managedElements[elId].el, timestamp, true);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"setElementPosition\",\n    value: function setElementPosition(el, x, y) {\n      var id = this.getId(el);\n      this.viewport.setPosition(id, x, y);\n      return this.repaint(el);\n    }\n  }, {\n    key: \"repaint\",\n    value: function repaint(el, timestamp, offsetsWereJustCalculated) {\n      var r = {\n        c: new Set(),\n        e: new Set()\n      };\n\n      var _mergeRedraw = function _mergeRedraw(r2) {\n        r2.c.forEach(function (c) {\n          return r.c.add(c);\n        });\n        r2.e.forEach(function (e) {\n          return r.e.add(e);\n        });\n      };\n\n      if (!this._suspendDrawing) {\n        var id = this.getId(el);\n\n        if (el != null) {\n          var repaintEls = this._getAssociatedElements(el);\n\n          if (timestamp == null) {\n            timestamp = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.uuid)();\n          }\n\n          if (!offsetsWereJustCalculated) {\n            for (var i = 0; i < repaintEls.length; i++) {\n              this.updateOffset({\n                elId: this.getId(repaintEls[i]),\n                recalc: true,\n                timestamp: timestamp\n              });\n            }\n          }\n\n          _mergeRedraw(this.router.redraw(id, timestamp, null));\n\n          if (repaintEls.length > 0) {\n            for (var j = 0; j < repaintEls.length; j++) {\n              _mergeRedraw(this.router.redraw(this.getId(repaintEls[j]), timestamp, null));\n            }\n          }\n        }\n      }\n\n      return r;\n    }\n  }, {\n    key: \"unregisterEndpoint\",\n    value: function unregisterEndpoint(endpoint) {\n      var uuid = endpoint.getUuid();\n\n      if (uuid) {\n        this.endpointsByUUID[\"delete\"](uuid);\n      }\n\n      removeManagedEndpoint(this._managedElements[endpoint.elementId], endpoint);\n      var ebe = this.endpointsByElement[endpoint.elementId];\n\n      if (ebe != null) {\n        if (ebe.length > 1) {\n          this.endpointsByElement[endpoint.elementId] = ebe.filter(function (e) {\n            return e !== endpoint;\n          });\n        } else {\n          delete this.endpointsByElement[endpoint.elementId];\n        }\n      }\n\n      this.fire(EVENT_INTERNAL_ENDPOINT_UNREGISTERED, endpoint);\n    }\n  }, {\n    key: \"_maybePruneEndpoint\",\n    value: function _maybePruneEndpoint(endpoint) {\n      if (endpoint.deleteOnEmpty && endpoint.connections.length === 0) {\n        this.deleteEndpoint(endpoint);\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"deleteEndpoint\",\n    value: function deleteEndpoint(object) {\n      var _this5 = this;\n\n      var endpoint = typeof object === \"string\" ? this.endpointsByUUID.get(object) : object;\n\n      if (endpoint) {\n        var proxy = endpoint.proxiedBy;\n        var connectionsToDelete = endpoint.connections.slice();\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.forEach)(connectionsToDelete, function (connection) {\n          endpoint.detachFromConnection(connection, null, true);\n        });\n        this.unregisterEndpoint(endpoint);\n        endpoint.destroy();\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.forEach)(connectionsToDelete, function (connection) {\n          _this5.deleteConnection(connection, {\n            force: true,\n            endpointToIgnore: endpoint\n          });\n        });\n\n        if (proxy != null) {\n          this.deleteEndpoint(proxy);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"addEndpoint\",\n    value: function addEndpoint(el, params, referenceParams) {\n      referenceParams = referenceParams || {};\n      var p = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, referenceParams);\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)(p, params || {});\n\n      var _p = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)({\n        element: el\n      }, p);\n\n      return this._internal_newEndpoint(_p);\n    }\n  }, {\n    key: \"addEndpoints\",\n    value: function addEndpoints(el, endpoints, referenceParams) {\n      var results = [];\n\n      for (var i = 0, j = endpoints.length; i < j; i++) {\n        results.push(this.addEndpoint(el, endpoints[i], referenceParams));\n      }\n\n      return results;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var _this6 = this;\n\n      this.silently(function () {\n        _this6.endpointsByElement = {};\n        _this6._managedElements = {};\n\n        _this6.endpointsByUUID.clear();\n\n        _this6.viewport.reset();\n\n        _this6.router.reset();\n\n        _this6.groupManager.reset();\n\n        _this6.connections.length = 0;\n      });\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.reset();\n      this.unbind();\n      this.sourceSelectors.length = 0;\n      this.targetSelectors.length = 0;\n\n      this._connectionTypes.clear();\n\n      this._endpointTypes.clear();\n    }\n  }, {\n    key: \"getEndpoints\",\n    value: function getEndpoints(el) {\n      return this.endpointsByElement[this.getId(el)] || [];\n    }\n  }, {\n    key: \"getEndpoint\",\n    value: function getEndpoint(uuid) {\n      return this.endpointsByUUID.get(uuid);\n    }\n  }, {\n    key: \"setEndpointUuid\",\n    value: function setEndpointUuid(endpoint, uuid) {\n      if (endpoint.uuid) {\n        this.endpointsByUUID[\"delete\"](endpoint.uuid);\n      }\n\n      endpoint.uuid = uuid;\n      this.endpointsByUUID.set(uuid, endpoint);\n    }\n  }, {\n    key: \"connect\",\n    value: function connect(params, referenceParams) {\n      try {\n        var _p = this._prepareConnectionParams(params, referenceParams),\n            jpc = this._newConnection(_p);\n\n        this._finaliseConnection(jpc, _p);\n\n        return jpc;\n      } catch (errorMessage) {\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.log)(errorMessage);\n        return;\n      }\n    }\n  }, {\n    key: \"_prepareConnectionParams\",\n    value: function _prepareConnectionParams(params, referenceParams) {\n      var temp = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, params);\n\n      if (referenceParams) {\n        (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)(temp, referenceParams);\n      }\n\n      var _p = temp;\n\n      if (_p.source) {\n        if (_p.source.endpoint) {\n          _p.sourceEndpoint = _p.source;\n        }\n      }\n\n      if (_p.target) {\n        if (_p.target.endpoint) {\n          _p.targetEndpoint = _p.target;\n        }\n      }\n\n      if (params.uuids) {\n        _p.sourceEndpoint = this.getEndpoint(params.uuids[0]);\n        _p.targetEndpoint = this.getEndpoint(params.uuids[1]);\n      }\n\n      if (_p.sourceEndpoint != null) {\n        if (_p.sourceEndpoint.isFull()) {\n          throw ERROR_SOURCE_ENDPOINT_FULL;\n        }\n\n        if (!_p.type) {\n          _p.type = _p.sourceEndpoint.edgeType;\n        }\n\n        if (_p.sourceEndpoint.connectorOverlays) {\n          _p.overlays = _p.overlays || [];\n\n          for (var i = 0, j = _p.sourceEndpoint.connectorOverlays.length; i < j; i++) {\n            _p.overlays.push(_p.sourceEndpoint.connectorOverlays[i]);\n          }\n        }\n\n        if (_p.sourceEndpoint.scope) {\n          _p.scope = _p.sourceEndpoint.scope;\n        }\n      } else {\n        if (_p.source == null) {\n          throw ERROR_SOURCE_DOES_NOT_EXIST;\n        }\n      }\n\n      if (_p.targetEndpoint != null) {\n        if (_p.targetEndpoint.isFull()) {\n          throw ERROR_TARGET_ENDPOINT_FULL;\n        }\n      } else {\n        if (_p.target == null) {\n          throw ERROR_TARGET_DOES_NOT_EXIST;\n        }\n      }\n\n      if (_p.sourceEndpoint && _p.targetEndpoint) {\n        if (!_scopeMatch(_p.sourceEndpoint, _p.targetEndpoint)) {\n          throw \"Cannot establish connection: scopes do not match\";\n        }\n      }\n\n      return _p;\n    }\n  }, {\n    key: \"_newConnection\",\n    value: function _newConnection(params) {\n      params.id = \"con_\" + this._idstamp();\n      var c = new Connection(this, params);\n      addManagedConnection(c, this._managedElements[c.sourceId], this._managedElements[c.targetId]);\n\n      this._paintConnection(c);\n\n      return c;\n    }\n  }, {\n    key: \"_finaliseConnection\",\n    value: function _finaliseConnection(jpc, params, originalEvent) {\n      params = params || {};\n\n      if (!jpc.suspendedEndpoint) {\n        this.connections.push(jpc);\n      }\n\n      jpc.pending = null;\n      jpc.endpoints[0].isTemporarySource = false;\n      this.repaint(jpc.source);\n      var payload = {\n        connection: jpc,\n        source: jpc.source,\n        target: jpc.target,\n        sourceId: jpc.sourceId,\n        targetId: jpc.targetId,\n        sourceEndpoint: jpc.endpoints[0],\n        targetEndpoint: jpc.endpoints[1]\n      };\n      this.fire(EVENT_INTERNAL_CONNECTION, payload, originalEvent);\n\n      if (!params.doNotFireConnectionEvent && params.fireEvent !== false) {\n        this.fire(EVENT_CONNECTION, payload, originalEvent);\n      }\n    }\n  }, {\n    key: \"removeAllEndpoints\",\n    value: function removeAllEndpoints(el, recurse) {\n      var _this7 = this;\n\n      var _one = function _one(_el) {\n        var id = _this7.getId(_el),\n            ebe = _this7.endpointsByElement[id],\n            i,\n            ii;\n\n        if (ebe) {\n          for (i = 0, ii = ebe.length; i < ii; i++) {\n            _this7.deleteEndpoint(ebe[i]);\n          }\n        }\n\n        delete _this7.endpointsByElement[id];\n      };\n\n      if (recurse) {\n        this._getAssociatedElements(el).map(_one);\n      }\n\n      _one(el);\n\n      return this;\n    }\n  }, {\n    key: \"_createSourceDefinition\",\n    value: function _createSourceDefinition(params, referenceParams) {\n      var p = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, referenceParams);\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)(p, params);\n      p.edgeType = p.edgeType || _jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.DEFAULT;\n\n      var aae = this._deriveEndpointAndAnchorSpec(p.edgeType);\n\n      p.endpoint = p.endpoint || aae.endpoints[0];\n      p.anchor = p.anchor || aae.anchors[0];\n      var maxConnections = p.maxConnections || -1;\n      var _def = {\n        def: (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, p),\n        uniqueEndpoint: p.uniqueEndpoint,\n        maxConnections: maxConnections,\n        enabled: true,\n        endpoint: null\n      };\n      return _def;\n    }\n  }, {\n    key: \"addSourceSelector\",\n    value: function addSourceSelector(selector, params) {\n      var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var _def = this._createSourceDefinition(params);\n\n      var sel = new SourceSelector(selector, _def, exclude);\n      this.sourceSelectors.push(sel);\n      return sel;\n    }\n  }, {\n    key: \"removeSourceSelector\",\n    value: function removeSourceSelector(selector) {\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.removeWithFunction)(this.sourceSelectors, function (s) {\n        return s === selector;\n      });\n    }\n  }, {\n    key: \"removeTargetSelector\",\n    value: function removeTargetSelector(selector) {\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.removeWithFunction)(this.targetSelectors, function (s) {\n        return s === selector;\n      });\n    }\n  }, {\n    key: \"addTargetSelector\",\n    value: function addTargetSelector(selector, params) {\n      var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var _def = this._createTargetDefinition(params);\n\n      var sel = new TargetSelector(selector, _def, exclude);\n      this.targetSelectors.push(sel);\n      return sel;\n    }\n  }, {\n    key: \"_createTargetDefinition\",\n    value: function _createTargetDefinition(params, referenceParams) {\n      var p = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, referenceParams);\n      (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)(p, params);\n      p.edgeType = p.edgeType || _jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.DEFAULT;\n      var maxConnections = p.maxConnections || -1;\n      var _def = {\n        def: (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, p),\n        uniqueEndpoint: p.uniqueEndpoint,\n        maxConnections: maxConnections,\n        enabled: true,\n        endpoint: null\n      };\n      return _def;\n    }\n  }, {\n    key: \"show\",\n    value: function show(el, changeEndpoints) {\n      return this._setVisible(el, BLOCK, changeEndpoints);\n    }\n  }, {\n    key: \"hide\",\n    value: function hide(el, changeEndpoints) {\n      return this._setVisible(el, NONE, changeEndpoints);\n    }\n  }, {\n    key: \"_setVisible\",\n    value: function _setVisible(el, state, alsoChangeEndpoints) {\n      var visible = state === BLOCK;\n      var endpointFunc = null;\n\n      if (alsoChangeEndpoints) {\n        endpointFunc = function endpointFunc(ep) {\n          ep.setVisible(visible, true, true);\n        };\n      }\n\n      var id = this.getId(el);\n\n      this._operation(el, function (jpc) {\n        if (visible && alsoChangeEndpoints) {\n          var oidx = jpc.sourceId === id ? 1 : 0;\n\n          if (jpc.endpoints[oidx].isVisible()) {\n            jpc.setVisible(true);\n          }\n        } else {\n          jpc.setVisible(visible);\n        }\n      }, endpointFunc);\n\n      return this;\n    }\n  }, {\n    key: \"toggleVisible\",\n    value: function toggleVisible(el, changeEndpoints) {\n      var endpointFunc = null;\n\n      if (changeEndpoints) {\n        endpointFunc = function endpointFunc(ep) {\n          var state = ep.isVisible();\n          ep.setVisible(!state);\n        };\n      }\n\n      this._operation(el, function (jpc) {\n        var state = jpc.isVisible();\n        jpc.setVisible(!state);\n      }, endpointFunc);\n    }\n  }, {\n    key: \"_operation\",\n    value: function _operation(el, func, endpointFunc) {\n      var elId = this.getId(el);\n      var endpoints = this.endpointsByElement[elId];\n\n      if (endpoints && endpoints.length) {\n        for (var i = 0, ii = endpoints.length; i < ii; i++) {\n          for (var j = 0, jj = endpoints[i].connections.length; j < jj; j++) {\n            var retVal = func(endpoints[i].connections[j]);\n\n            if (retVal) {\n              return;\n            }\n          }\n\n          if (endpointFunc) {\n            endpointFunc(endpoints[i]);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"registerConnectionType\",\n    value: function registerConnectionType(id, type) {\n      this._connectionTypes.set(id, (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, type));\n\n      if (type.overlays) {\n        var to = {};\n\n        for (var i = 0; i < type.overlays.length; i++) {\n          var fo = convertToFullOverlaySpec(type.overlays[i]);\n          to[fo.options.id] = fo;\n        }\n\n        this._connectionTypes.get(id).overlays = to;\n      }\n    }\n  }, {\n    key: \"registerConnectionTypes\",\n    value: function registerConnectionTypes(types) {\n      for (var i in types) {\n        this.registerConnectionType(i, types[i]);\n      }\n    }\n  }, {\n    key: \"registerEndpointType\",\n    value: function registerEndpointType(id, type) {\n      this._endpointTypes.set(id, (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, type));\n\n      if (type.overlays) {\n        var to = {};\n\n        for (var i = 0; i < type.overlays.length; i++) {\n          var fo = convertToFullOverlaySpec(type.overlays[i]);\n          to[fo.options.id] = fo;\n        }\n\n        this._endpointTypes.get(id).overlays = to;\n      }\n    }\n  }, {\n    key: \"registerEndpointTypes\",\n    value: function registerEndpointTypes(types) {\n      for (var i in types) {\n        this.registerEndpointType(i, types[i]);\n      }\n    }\n  }, {\n    key: \"getType\",\n    value: function getType(id, typeDescriptor) {\n      return typeDescriptor === \"connection\" ? this.getConnectionType(id) : this.getEndpointType(id);\n    }\n  }, {\n    key: \"getConnectionType\",\n    value: function getConnectionType(id) {\n      return this._connectionTypes.get(id);\n    }\n  }, {\n    key: \"getEndpointType\",\n    value: function getEndpointType(id) {\n      return this._endpointTypes.get(id);\n    }\n  }, {\n    key: \"importDefaults\",\n    value: function importDefaults(d) {\n      for (var i in d) {\n        this.defaults[i] = d[i];\n      }\n\n      if (d.container) {\n        this.setContainer(d.container);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"restoreDefaults\",\n    value: function restoreDefaults() {\n      this.defaults = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, this._initialDefaults);\n      return this;\n    }\n  }, {\n    key: \"getManagedElements\",\n    value: function getManagedElements() {\n      return this._managedElements;\n    }\n  }, {\n    key: \"proxyConnection\",\n    value: function proxyConnection(connection, index, proxyEl, endpointGenerator, anchorGenerator) {\n      var alreadyProxied = connection.proxies[index] != null,\n          proxyEp,\n          originalElementId = alreadyProxied ? connection.proxies[index].originalEp.elementId : connection.endpoints[index].elementId,\n          originalEndpoint = alreadyProxied ? connection.proxies[index].originalEp : connection.endpoints[index],\n          proxyElId = this.getId(proxyEl);\n\n      if (connection.proxies[index]) {\n        if (connection.proxies[index].ep.elementId === proxyElId) {\n          proxyEp = connection.proxies[index].ep;\n        } else {\n          connection.proxies[index].ep.detachFromConnection(connection, index);\n          proxyEp = this._internal_newEndpoint({\n            element: proxyEl,\n            endpoint: endpointGenerator(connection, index),\n            anchor: anchorGenerator(connection, index),\n            parameters: {\n              isProxyEndpoint: true\n            }\n          });\n        }\n      } else {\n        proxyEp = this._internal_newEndpoint({\n          element: proxyEl,\n          endpoint: endpointGenerator(connection, index),\n          anchor: anchorGenerator(connection, index),\n          parameters: {\n            isProxyEndpoint: true\n          }\n        });\n      }\n\n      proxyEp.deleteOnEmpty = true;\n      connection.proxies[index] = {\n        ep: proxyEp,\n        originalEp: originalEndpoint\n      };\n      this.sourceOrTargetChanged(originalElementId, proxyElId, connection, proxyEl, index);\n      originalEndpoint.detachFromConnection(connection, null, true);\n      proxyEp.connections = [connection];\n      connection.endpoints[index] = proxyEp;\n      originalEndpoint.proxiedBy = proxyEp;\n      originalEndpoint.setVisible(false);\n      connection.setVisible(true);\n      this.revalidate(proxyEl);\n    }\n  }, {\n    key: \"unproxyConnection\",\n    value: function unproxyConnection(connection, index) {\n      if (connection.proxies == null || connection.proxies[index] == null) {\n        return;\n      }\n\n      var originalElement = connection.proxies[index].originalEp.element,\n          originalElementId = connection.proxies[index].originalEp.elementId,\n          proxyElId = connection.proxies[index].ep.elementId;\n      connection.endpoints[index] = connection.proxies[index].originalEp;\n      delete connection.proxies[index].originalEp.proxiedBy;\n      this.sourceOrTargetChanged(proxyElId, originalElementId, connection, originalElement, index);\n      connection.proxies[index].ep.detachFromConnection(connection, null);\n      connection.proxies[index].originalEp.addConnection(connection);\n\n      if (connection.isVisible()) {\n        connection.proxies[index].originalEp.setVisible(true);\n      }\n\n      connection.proxies[index] = null;\n\n      if ((0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.findWithFunction)(connection.proxies, function (p) {\n        return p != null;\n      }) === -1) {\n        connection.proxies.length = 0;\n      }\n    }\n  }, {\n    key: \"sourceOrTargetChanged\",\n    value: function sourceOrTargetChanged(originalId, newId, connection, newElement, index) {\n      if (originalId !== newId) {\n        if (index === 0) {\n          connection.sourceId = newId;\n          connection.source = newElement;\n        } else if (index === 1) {\n          connection.targetId = newId;\n          connection.target = newElement;\n        }\n\n        removeManagedConnection(connection, this._managedElements[originalId]);\n        addManagedConnection(connection, this._managedElements[newId]);\n      }\n    }\n  }, {\n    key: \"getGroup\",\n    value: function getGroup(groupId) {\n      return this.groupManager.getGroup(groupId);\n    }\n  }, {\n    key: \"getGroupFor\",\n    value: function getGroupFor(el) {\n      return this.groupManager.getGroupFor(el);\n    }\n  }, {\n    key: \"addGroup\",\n    value: function addGroup(params) {\n      return this.groupManager.addGroup(params);\n    }\n  }, {\n    key: \"addToGroup\",\n    value: function addToGroup(group) {\n      var _this$groupManager;\n\n      for (var _len = arguments.length, el = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        el[_key - 1] = arguments[_key];\n      }\n\n      return (_this$groupManager = this.groupManager).addToGroup.apply(_this$groupManager, [group, false].concat(el));\n    }\n  }, {\n    key: \"collapseGroup\",\n    value: function collapseGroup(group) {\n      this.groupManager.collapseGroup(group);\n    }\n  }, {\n    key: \"expandGroup\",\n    value: function expandGroup(group) {\n      this.groupManager.expandGroup(group);\n    }\n  }, {\n    key: \"toggleGroup\",\n    value: function toggleGroup(group) {\n      this.groupManager.toggleGroup(group);\n    }\n  }, {\n    key: \"removeGroup\",\n    value: function removeGroup(group, deleteMembers, manipulateView, doNotFireEvent) {\n      return this.groupManager.removeGroup(group, deleteMembers, manipulateView, doNotFireEvent);\n    }\n  }, {\n    key: \"removeAllGroups\",\n    value: function removeAllGroups(deleteMembers, manipulateView) {\n      this.groupManager.removeAllGroups(deleteMembers, manipulateView, false);\n    }\n  }, {\n    key: \"removeFromGroup\",\n    value: function removeFromGroup(group, el, doNotFireEvent) {\n      this.groupManager.removeFromGroup(group, doNotFireEvent, el);\n\n      this._appendElement(el, this.getContainer());\n\n      this.updateOffset({\n        recalc: true,\n        elId: this.getId(el)\n      });\n    }\n  }, {\n    key: \"_paintEndpoint\",\n    value: function _paintEndpoint(endpoint, params) {\n      function findConnectionToUseForDynamicAnchor(ep) {\n        var idx = 0;\n\n        if (params.elementWithPrecedence != null) {\n          for (var i = 0; i < ep.connections.length; i++) {\n            if (ep.connections[i].sourceId === params.elementWithPrecedence || ep.connections[i].targetId === params.elementWithPrecedence) {\n              idx = i;\n              break;\n            }\n          }\n        }\n\n        return ep.connections[idx];\n      }\n\n      params = params || {};\n      var timestamp = params.timestamp,\n          recalc = !(params.recalc === false);\n\n      if (!timestamp || endpoint.timestamp !== timestamp) {\n        var info = this.viewport.getPosition(endpoint.elementId);\n        var xy = params.offset ? {\n          x: params.offset.x,\n          y: params.offset.y\n        } : {\n          x: info.x,\n          y: info.y\n        };\n\n        if (xy != null) {\n          var ap = params.anchorLoc;\n\n          if (ap == null) {\n            var anchorParams = {\n              xy: xy,\n              wh: info,\n              element: endpoint,\n              timestamp: timestamp\n            };\n\n            if (recalc && this.router.isDynamicAnchor(endpoint) && endpoint.connections.length > 0) {\n              var _c3 = findConnectionToUseForDynamicAnchor(endpoint),\n                  oIdx = _c3.endpoints[0] === endpoint ? 1 : 0,\n                  oId = oIdx === 0 ? _c3.sourceId : _c3.targetId,\n                  oInfo = this.viewport.getPosition(oId);\n\n              anchorParams.index = oIdx === 0 ? 1 : 0;\n              anchorParams.connection = _c3;\n              anchorParams.txy = oInfo;\n              anchorParams.twh = oInfo;\n              anchorParams.tElement = _c3.endpoints[oIdx];\n              anchorParams.tRotation = this._getRotations(oId);\n            } else if (endpoint.connections.length > 0) {\n              anchorParams.connection = endpoint.connections[0];\n            }\n\n            anchorParams.rotation = this._getRotations(endpoint.elementId);\n            ap = this.router.computeAnchorLocation(endpoint._anchor, anchorParams);\n          }\n\n          endpoint.endpoint.compute(ap, this.router.getEndpointOrientation(endpoint), endpoint.paintStyleInUse);\n          this.renderEndpoint(endpoint, endpoint.paintStyleInUse);\n          endpoint.timestamp = timestamp;\n\n          for (var i in endpoint.overlays) {\n            if (endpoint.overlays.hasOwnProperty(i)) {\n              var _o = endpoint.overlays[i];\n\n              if (_o.isVisible()) {\n                endpoint.overlayPlacements[i] = this.drawOverlay(_o, endpoint.endpoint, endpoint.paintStyleInUse, endpoint.getAbsoluteOverlayPosition(_o));\n\n                this._paintOverlay(_o, endpoint.overlayPlacements[i], {\n                  xmin: 0,\n                  ymin: 0\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_paintConnection\",\n    value: function _paintConnection(connection, params) {\n      if (!this._suspendDrawing && connection.visible !== false) {\n        params = params || {};\n        var timestamp = params.timestamp;\n\n        if (timestamp != null && timestamp === connection.lastPaintedAt) {\n          return;\n        }\n\n        if (timestamp == null || timestamp !== connection.lastPaintedAt) {\n          this.router.computePath(connection, timestamp);\n          var overlayExtents = {\n            xmin: Infinity,\n            ymin: Infinity,\n            xmax: -Infinity,\n            ymax: -Infinity\n          };\n\n          for (var i in connection.overlays) {\n            if (connection.overlays.hasOwnProperty(i)) {\n              var _o2 = connection.overlays[i];\n\n              if (_o2.isVisible()) {\n                connection.overlayPlacements[i] = this.drawOverlay(_o2, connection.connector, connection.paintStyleInUse, connection.getAbsoluteOverlayPosition(_o2));\n                overlayExtents.xmin = Math.min(overlayExtents.xmin, connection.overlayPlacements[i].xmin);\n                overlayExtents.xmax = Math.max(overlayExtents.xmax, connection.overlayPlacements[i].xmax);\n                overlayExtents.ymin = Math.min(overlayExtents.ymin, connection.overlayPlacements[i].ymin);\n                overlayExtents.ymax = Math.max(overlayExtents.ymax, connection.overlayPlacements[i].ymax);\n              }\n            }\n          }\n\n          var lineWidth = parseFloat(\"\" + connection.paintStyleInUse.strokeWidth || \"1\") / 2,\n              outlineWidth = parseFloat(\"\" + connection.paintStyleInUse.strokeWidth || \"0\"),\n              _extents = {\n            xmin: Math.min(connection.connector.bounds.xmin - (lineWidth + outlineWidth), overlayExtents.xmin),\n            ymin: Math.min(connection.connector.bounds.ymin - (lineWidth + outlineWidth), overlayExtents.ymin),\n            xmax: Math.max(connection.connector.bounds.xmax + (lineWidth + outlineWidth), overlayExtents.xmax),\n            ymax: Math.max(connection.connector.bounds.ymax + (lineWidth + outlineWidth), overlayExtents.ymax)\n          };\n          this.paintConnector(connection.connector, connection.paintStyleInUse, _extents);\n\n          for (var j in connection.overlays) {\n            if (connection.overlays.hasOwnProperty(j)) {\n              var _p2 = connection.overlays[j];\n\n              if (_p2.isVisible()) {\n                this._paintOverlay(_p2, connection.overlayPlacements[j], _extents);\n              }\n            }\n          }\n        }\n\n        connection.lastPaintedAt = timestamp;\n      }\n    }\n  }, {\n    key: \"_refreshEndpoint\",\n    value: function _refreshEndpoint(endpoint) {\n      if (endpoint.connections.length > 0) {\n        this.addEndpointClass(endpoint, this.endpointConnectedClass);\n      } else {\n        this.removeEndpointClass(endpoint, this.endpointConnectedClass);\n      }\n\n      if (endpoint.isFull()) {\n        this.addEndpointClass(endpoint, this.endpointFullClass);\n      } else {\n        this.removeEndpointClass(endpoint, this.endpointFullClass);\n      }\n    }\n  }, {\n    key: \"_makeConnector\",\n    value: function _makeConnector(connection, name, args) {\n      return Connectors.get(connection, name, args);\n    }\n  }, {\n    key: \"addOverlay\",\n    value: function addOverlay(component, overlay, doNotRevalidate) {\n      component.addOverlay(overlay);\n\n      if (!doNotRevalidate) {\n        var relatedElement = component instanceof Endpoint ? component.element : component.source;\n        this.revalidate(relatedElement);\n      }\n    }\n  }, {\n    key: \"getPathData\",\n    value: function getPathData(connector) {\n      var p = \"\";\n\n      for (var i = 0; i < connector.segments.length; i++) {\n        p += connector.segments[i].getPath(i === 0);\n        p += \" \";\n      }\n\n      return p;\n    }\n  }]);\n\n  return JsPlumbInstance;\n}(_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.EventGenerator);\n\nvar VERY_SMALL_VALUE = 0.0000000001;\n\nfunction gentleRound(n) {\n  var f = Math.floor(n),\n      r = Math.ceil(n);\n\n  if (n - f < VERY_SMALL_VALUE) {\n    return f;\n  } else if (r - n < VERY_SMALL_VALUE) {\n    return r;\n  }\n\n  return n;\n}\n\nvar ArcSegment = function (_AbstractSegment) {\n  _inherits(ArcSegment, _AbstractSegment);\n\n  var _super = _createSuper(ArcSegment);\n\n  function ArcSegment(params) {\n    var _this;\n\n    _classCallCheck(this, ArcSegment);\n\n    _this = _super.call(this, params);\n\n    _defineProperty(_assertThisInitialized(_this), \"type\", ArcSegment.segmentType);\n\n    _defineProperty(_assertThisInitialized(_this), \"cx\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"cy\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"radius\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"anticlockwise\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"startAngle\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"endAngle\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"sweep\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"length\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"circumference\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"frac\", void 0);\n\n    _this.cx = params.cx;\n    _this.cy = params.cy;\n    _this.radius = params.r;\n    _this.anticlockwise = params.ac;\n\n    if (params.startAngle && params.endAngle) {\n      _this.startAngle = params.startAngle;\n      _this.endAngle = params.endAngle;\n      _this.x1 = _this.cx + _this.radius * Math.cos(_this.startAngle);\n      _this.y1 = _this.cy + _this.radius * Math.sin(_this.startAngle);\n      _this.x2 = _this.cx + _this.radius * Math.cos(_this.endAngle);\n      _this.y2 = _this.cy + _this.radius * Math.sin(_this.endAngle);\n    } else {\n      _this.startAngle = _this._calcAngle(_this.x1, _this.y1);\n      _this.endAngle = _this._calcAngle(_this.x2, _this.y2);\n    }\n\n    if (_this.endAngle < 0) {\n      _this.endAngle += _jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.TWO_PI;\n    }\n\n    if (_this.startAngle < 0) {\n      _this.startAngle += _jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.TWO_PI;\n    }\n\n    var ea = _this.endAngle < _this.startAngle ? _this.endAngle + _jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.TWO_PI : _this.endAngle;\n    _this.sweep = Math.abs(ea - _this.startAngle);\n\n    if (_this.anticlockwise) {\n      _this.sweep = _jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.TWO_PI - _this.sweep;\n    }\n\n    _this.circumference = 2 * Math.PI * _this.radius;\n    _this.frac = _this.sweep / _jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.TWO_PI;\n    _this.length = _this.circumference * _this.frac;\n    _this.extents = {\n      xmin: _this.cx - _this.radius,\n      xmax: _this.cx + _this.radius,\n      ymin: _this.cy - _this.radius,\n      ymax: _this.cy + _this.radius\n    };\n    return _this;\n  }\n\n  _createClass(ArcSegment, [{\n    key: \"_calcAngle\",\n    value: function _calcAngle(_x, _y) {\n      return (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.theta)({\n        x: this.cx,\n        y: this.cy\n      }, {\n        x: _x,\n        y: _y\n      });\n    }\n  }, {\n    key: \"_calcAngleForLocation\",\n    value: function _calcAngleForLocation(segment, location) {\n      if (segment.anticlockwise) {\n        var sa = segment.startAngle < segment.endAngle ? segment.startAngle + _jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.TWO_PI : segment.startAngle,\n            s = Math.abs(sa - segment.endAngle);\n        return sa - s * location;\n      } else {\n        var ea = segment.endAngle < segment.startAngle ? segment.endAngle + _jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.TWO_PI : segment.endAngle,\n            ss = Math.abs(ea - segment.startAngle);\n        return segment.startAngle + ss * location;\n      }\n    }\n  }, {\n    key: \"getPath\",\n    value: function getPath(isFirstSegment) {\n      var laf = this.sweep > Math.PI ? 1 : 0,\n          sf = this.anticlockwise ? 0 : 1;\n      return (isFirstSegment ? \"M\" + this.x1 + \" \" + this.y1 + \" \" : \"\") + \"A \" + this.radius + \" \" + this.radius + \" 0 \" + laf + \",\" + sf + \" \" + this.x2 + \" \" + this.y2;\n    }\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      return this.length;\n    }\n  }, {\n    key: \"pointOnPath\",\n    value: function pointOnPath(location, absolute) {\n      if (location === 0) {\n        return {\n          x: this.x1,\n          y: this.y1,\n          theta: this.startAngle\n        };\n      } else if (location === 1) {\n        return {\n          x: this.x2,\n          y: this.y2,\n          theta: this.endAngle\n        };\n      }\n\n      if (absolute) {\n        location = location / length;\n      }\n\n      var angle = this._calcAngleForLocation(this, location),\n          _x = this.cx + this.radius * Math.cos(angle),\n          _y = this.cy + this.radius * Math.sin(angle);\n\n      return {\n        x: gentleRound(_x),\n        y: gentleRound(_y),\n        theta: angle\n      };\n    }\n  }, {\n    key: \"gradientAtPoint\",\n    value: function gradientAtPoint(location, absolute) {\n      var p = this.pointOnPath(location, absolute);\n      var m = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.normal)({\n        x: this.cx,\n        y: this.cy\n      }, p);\n\n      if (!this.anticlockwise && (m === Infinity || m === -Infinity)) {\n        m *= -1;\n      }\n\n      return m;\n    }\n  }, {\n    key: \"pointAlongPathFrom\",\n    value: function pointAlongPathFrom(location, distance, absolute) {\n      var p = this.pointOnPath(location, absolute),\n          arcSpan = distance / this.circumference * 2 * Math.PI,\n          dir = this.anticlockwise ? -1 : 1,\n          startAngle = p.theta + dir * arcSpan,\n          startX = this.cx + this.radius * Math.cos(startAngle),\n          startY = this.cy + this.radius * Math.sin(startAngle);\n      return {\n        x: startX,\n        y: startY\n      };\n    }\n  }]);\n\n  return ArcSegment;\n}(_jsplumb_common__WEBPACK_IMPORTED_MODULE_1__.AbstractSegment);\n\n_defineProperty(ArcSegment, \"segmentType\", \"Arc\");\n\nvar DEFAULT_WIDTH = 20;\nvar DEFAULT_LENGTH = 20;\n\nvar ArrowOverlay = function (_Overlay) {\n  _inherits(ArrowOverlay, _Overlay);\n\n  var _super = _createSuper(ArrowOverlay);\n\n  function ArrowOverlay(instance, component, p) {\n    var _this;\n\n    _classCallCheck(this, ArrowOverlay);\n\n    _this = _super.call(this, instance, component, p);\n    _this.instance = instance;\n    _this.component = component;\n\n    _defineProperty(_assertThisInitialized(_this), \"width\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"length\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"foldback\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"direction\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"location\", 0.5);\n\n    _defineProperty(_assertThisInitialized(_this), \"paintStyle\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"type\", ArrowOverlay.type);\n\n    _defineProperty(_assertThisInitialized(_this), \"cachedDimensions\", void 0);\n\n    p = p || {};\n    _this.width = p.width || DEFAULT_WIDTH;\n    _this.length = p.length || DEFAULT_LENGTH;\n    _this.direction = (p.direction || 1) < 0 ? -1 : 1;\n    _this.foldback = p.foldback || 0.623;\n    _this.paintStyle = p.paintStyle || {\n      \"strokeWidth\": 1\n    };\n    _this.location = p.location == null ? _this.location : Array.isArray(p.location) ? p.location[0] : p.location;\n    return _this;\n  }\n\n  _createClass(ArrowOverlay, [{\n    key: \"draw\",\n    value: function draw(component, currentConnectionPaintStyle, absolutePosition) {\n      if (component instanceof AbstractConnector) {\n        var connector = component;\n        var hxy, mid, txy, tail, cxy;\n\n        if (this.location > 1 || this.location < 0) {\n          var fromLoc = this.location < 0 ? 1 : 0;\n          hxy = connector.pointAlongPathFrom(fromLoc, this.location, false);\n          mid = connector.pointAlongPathFrom(fromLoc, this.location - this.direction * this.length / 2, false);\n          txy = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.pointOnLine)(hxy, mid, this.length);\n        } else if (this.location === 1) {\n          hxy = connector.pointOnPath(this.location);\n          mid = connector.pointAlongPathFrom(this.location, -this.length);\n          txy = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.pointOnLine)(hxy, mid, this.length);\n\n          if (this.direction === -1) {\n            var _ = txy;\n            txy = hxy;\n            hxy = _;\n          }\n        } else if (this.location === 0) {\n          txy = connector.pointOnPath(this.location);\n          mid = connector.pointAlongPathFrom(this.location, this.length);\n          hxy = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.pointOnLine)(txy, mid, this.length);\n\n          if (this.direction === -1) {\n            var __ = txy;\n            txy = hxy;\n            hxy = __;\n          }\n        } else {\n          hxy = connector.pointAlongPathFrom(this.location, this.direction * this.length / 2);\n          mid = connector.pointOnPath(this.location);\n          txy = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.pointOnLine)(hxy, mid, this.length);\n        }\n\n        tail = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.perpendicularLineTo)(hxy, txy, this.width);\n        cxy = (0,_jsplumb_util__WEBPACK_IMPORTED_MODULE_0__.pointOnLine)(hxy, txy, this.foldback * this.length);\n        var d = {\n          hxy: hxy,\n          tail: tail,\n          cxy: cxy\n        },\n            stroke = this.paintStyle.stroke || currentConnectionPaintStyle.stroke,\n            fill = this.paintStyle.fill || currentConnectionPaintStyle.stroke,\n            lineWidth = this.paintStyle.strokeWidth || currentConnectionPaintStyle.strokeWidth;\n        return {\n          component: component,\n          d: d,\n          \"stroke-width\": lineWidth,\n          stroke: stroke,\n          fill: fill,\n          xmin: Math.min(hxy.x, tail[0].x, tail[1].x),\n          xmax: Math.max(hxy.x, tail[0].x, tail[1].x),\n          ymin: Math.min(hxy.y, tail[0].y, tail[1].y),\n          ymax: Math.max(hxy.y, tail[0].y, tail[1].y)\n        };\n      }\n    }\n  }, {\n    key: \"updateFrom\",\n    value: function updateFrom(d) {}\n  }]);\n\n  return ArrowOverlay;\n}(Overlay);\n\n_defineProperty(ArrowOverlay, \"type\", \"Arrow\");\n\nfunction isArrowOverlay(o) {\n  return o.type === ArrowOverlay.type;\n}\n\nOverlayFactory.register(ArrowOverlay.type, ArrowOverlay);\n\nvar PlainArrowOverlay = function (_ArrowOverlay) {\n  _inherits(PlainArrowOverlay, _ArrowOverlay);\n\n  var _super = _createSuper(PlainArrowOverlay);\n\n  function PlainArrowOverlay(instance, component, p) {\n    var _this;\n\n    _classCallCheck(this, PlainArrowOverlay);\n\n    _this = _super.call(this, instance, component, p);\n    _this.instance = instance;\n\n    _defineProperty(_assertThisInitialized(_this), \"type\", PlainArrowOverlay.type);\n\n    _this.foldback = 1;\n    return _this;\n  }\n\n  return PlainArrowOverlay;\n}(ArrowOverlay);\n\n_defineProperty(PlainArrowOverlay, \"type\", \"PlainArrow\");\n\nfunction isPlainArrowOverlay(o) {\n  return o.type === PlainArrowOverlay.type;\n}\n\nOverlayFactory.register(\"PlainArrow\", PlainArrowOverlay);\n\nvar DiamondOverlay = function (_ArrowOverlay) {\n  _inherits(DiamondOverlay, _ArrowOverlay);\n\n  var _super = _createSuper(DiamondOverlay);\n\n  function DiamondOverlay(instance, component, p) {\n    var _this;\n\n    _classCallCheck(this, DiamondOverlay);\n\n    _this = _super.call(this, instance, component, p);\n    _this.instance = instance;\n\n    _defineProperty(_assertThisInitialized(_this), \"type\", DiamondOverlay.type);\n\n    _this.length = _this.length / 2;\n    _this.foldback = 2;\n    return _this;\n  }\n\n  return DiamondOverlay;\n}(ArrowOverlay);\n\n_defineProperty(DiamondOverlay, \"type\", \"Diamond\");\n\nfunction isDiamondOverlay(o) {\n  return o.type === DiamondOverlay.type;\n}\n\nOverlayFactory.register(DiamondOverlay.type, DiamondOverlay);\n\nvar CustomOverlay = function (_Overlay) {\n  _inherits(CustomOverlay, _Overlay);\n\n  var _super = _createSuper(CustomOverlay);\n\n  function CustomOverlay(instance, component, p) {\n    var _this;\n\n    _classCallCheck(this, CustomOverlay);\n\n    _this = _super.call(this, instance, component, p);\n    _this.instance = instance;\n    _this.component = component;\n\n    _defineProperty(_assertThisInitialized(_this), \"create\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"type\", CustomOverlay.type);\n\n    _this.create = p.create;\n    return _this;\n  }\n\n  _createClass(CustomOverlay, [{\n    key: \"updateFrom\",\n    value: function updateFrom(d) {}\n  }]);\n\n  return CustomOverlay;\n}(Overlay);\n\n_defineProperty(CustomOverlay, \"type\", \"Custom\");\n\nfunction isCustomOverlay(o) {\n  return o.type === CustomOverlay.type;\n}\n\nOverlayFactory.register(CustomOverlay.type, CustomOverlay);\nEndpointFactory.registerHandler(DotEndpointHandler);\nEndpointFactory.registerHandler(RectangleEndpointHandler);\nEndpointFactory.registerHandler(BlankEndpointHandler);\nConnectors.register(StraightConnector.type, StraightConnector);\n\n\n//# sourceURL=webpack://questmaker/./node_modules/@jsplumb/core/js/jsplumb.core.es.js?");

/***/ }),

/***/ "./node_modules/@jsplumb/util/js/jsplumb.util.es.js":
/*!**********************************************************!*\
  !*** ./node_modules/@jsplumb/util/js/jsplumb.util.es.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EventGenerator\": () => (/* binding */ EventGenerator),\n/* harmony export */   \"OptimisticEventGenerator\": () => (/* binding */ OptimisticEventGenerator),\n/* harmony export */   \"TWO_PI\": () => (/* binding */ TWO_PI),\n/* harmony export */   \"add\": () => (/* binding */ add),\n/* harmony export */   \"addToDictionary\": () => (/* binding */ addToDictionary),\n/* harmony export */   \"addToList\": () => (/* binding */ addToList),\n/* harmony export */   \"addWithFunction\": () => (/* binding */ addWithFunction),\n/* harmony export */   \"arraysEqual\": () => (/* binding */ arraysEqual),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"each\": () => (/* binding */ each),\n/* harmony export */   \"encloses\": () => (/* binding */ encloses),\n/* harmony export */   \"extend\": () => (/* binding */ extend),\n/* harmony export */   \"fastTrim\": () => (/* binding */ fastTrim),\n/* harmony export */   \"filterList\": () => (/* binding */ filterList),\n/* harmony export */   \"filterNull\": () => (/* binding */ filterNull),\n/* harmony export */   \"findAllWithFunction\": () => (/* binding */ findAllWithFunction),\n/* harmony export */   \"findWithFunction\": () => (/* binding */ findWithFunction),\n/* harmony export */   \"forEach\": () => (/* binding */ forEach),\n/* harmony export */   \"fromArray\": () => (/* binding */ fromArray),\n/* harmony export */   \"functionChain\": () => (/* binding */ functionChain),\n/* harmony export */   \"getAllWithFunction\": () => (/* binding */ getAllWithFunction),\n/* harmony export */   \"getFromSetWithFunction\": () => (/* binding */ getFromSetWithFunction),\n/* harmony export */   \"getWithFunction\": () => (/* binding */ getWithFunction),\n/* harmony export */   \"getsert\": () => (/* binding */ getsert),\n/* harmony export */   \"gradient\": () => (/* binding */ gradient),\n/* harmony export */   \"insertSorted\": () => (/* binding */ insertSorted),\n/* harmony export */   \"intersects\": () => (/* binding */ intersects),\n/* harmony export */   \"isAssignableFrom\": () => (/* binding */ isAssignableFrom),\n/* harmony export */   \"isBoolean\": () => (/* binding */ isBoolean),\n/* harmony export */   \"isDate\": () => (/* binding */ isDate),\n/* harmony export */   \"isEmpty\": () => (/* binding */ isEmpty),\n/* harmony export */   \"isFunction\": () => (/* binding */ isFunction),\n/* harmony export */   \"isNamedFunction\": () => (/* binding */ isNamedFunction),\n/* harmony export */   \"isNumber\": () => (/* binding */ isNumber),\n/* harmony export */   \"isObject\": () => (/* binding */ isObject),\n/* harmony export */   \"isString\": () => (/* binding */ isString),\n/* harmony export */   \"lineIntersection\": () => (/* binding */ lineIntersection),\n/* harmony export */   \"lineLength\": () => (/* binding */ lineLength),\n/* harmony export */   \"lineRectangleIntersection\": () => (/* binding */ lineRectangleIntersection),\n/* harmony export */   \"log\": () => (/* binding */ log),\n/* harmony export */   \"logEnabled\": () => (/* binding */ logEnabled),\n/* harmony export */   \"map\": () => (/* binding */ map),\n/* harmony export */   \"merge\": () => (/* binding */ merge),\n/* harmony export */   \"normal\": () => (/* binding */ normal),\n/* harmony export */   \"objectsEqual\": () => (/* binding */ objectsEqual),\n/* harmony export */   \"perpendicularLineTo\": () => (/* binding */ perpendicularLineTo),\n/* harmony export */   \"pointOnLine\": () => (/* binding */ pointOnLine),\n/* harmony export */   \"populate\": () => (/* binding */ populate),\n/* harmony export */   \"quadrant\": () => (/* binding */ quadrant),\n/* harmony export */   \"remove\": () => (/* binding */ remove),\n/* harmony export */   \"removeWithFunction\": () => (/* binding */ removeWithFunction),\n/* harmony export */   \"replace\": () => (/* binding */ replace),\n/* harmony export */   \"rotateAnchorOrientation\": () => (/* binding */ rotateAnchorOrientation),\n/* harmony export */   \"rotatePoint\": () => (/* binding */ rotatePoint),\n/* harmony export */   \"setToArray\": () => (/* binding */ setToArray),\n/* harmony export */   \"sgn\": () => (/* binding */ sgn),\n/* harmony export */   \"snapToGrid\": () => (/* binding */ snapToGrid),\n/* harmony export */   \"subtract\": () => (/* binding */ subtract),\n/* harmony export */   \"suggest\": () => (/* binding */ suggest),\n/* harmony export */   \"theta\": () => (/* binding */ theta),\n/* harmony export */   \"uuid\": () => (/* binding */ uuid),\n/* harmony export */   \"wrap\": () => (/* binding */ wrap)\n/* harmony export */ });\nfunction filterList(list, value, missingIsFalse) {\n  if (list === \"*\") {\n    return true;\n  }\n\n  return list.length > 0 ? list.indexOf(value) !== -1 : !missingIsFalse;\n}\n\nfunction extend(o1, o2, keys) {\n  var i;\n  o1 = o1 || {};\n  o2 = o2 || {};\n  var _o1 = o1,\n      _o2 = o2;\n\n  if (keys) {\n    for (i = 0; i < keys.length; i++) {\n      _o1[keys[i]] = _o2[keys[i]];\n    }\n  } else {\n    for (i in _o2) {\n      _o1[i] = _o2[i];\n    }\n  }\n\n  return o1;\n}\n\nfunction isNumber(n) {\n  return Object.prototype.toString.call(n) === \"[object Number]\";\n}\n\nfunction isString(s) {\n  return typeof s === \"string\";\n}\n\nfunction isBoolean(s) {\n  return typeof s === \"boolean\";\n}\n\nfunction isObject(o) {\n  return o == null ? false : Object.prototype.toString.call(o) === \"[object Object]\";\n}\n\nfunction isDate(o) {\n  return Object.prototype.toString.call(o) === \"[object Date]\";\n}\n\nfunction isFunction(o) {\n  return Object.prototype.toString.call(o) === \"[object Function]\";\n}\n\nfunction isNamedFunction(o) {\n  return isFunction(o) && o.name != null && o.name.length > 0;\n}\n\nfunction isEmpty(o) {\n  for (var i in o) {\n    if (o.hasOwnProperty(i)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction clone(a) {\n  if (isString(a)) {\n    return \"\" + a;\n  } else if (isBoolean(a)) {\n    return !!a;\n  } else if (isDate(a)) {\n    return new Date(a.getTime());\n  } else if (isFunction(a)) {\n    return a;\n  } else if (Array.isArray(a)) {\n    var _b = [];\n\n    for (var i = 0; i < a.length; i++) {\n      _b.push(clone(a[i]));\n    }\n\n    return _b;\n  } else if (isObject(a)) {\n    var c = {};\n\n    for (var j in a) {\n      c[j] = clone(a[j]);\n    }\n\n    return c;\n  } else {\n    return a;\n  }\n}\n\nfunction filterNull(obj) {\n  var o = {};\n\n  for (var k in obj) {\n    if (obj[k] != null) {\n      o[k] = obj[k];\n    }\n  }\n\n  return o;\n}\n\nfunction merge(a, b, collations, overwrites) {\n  var cMap = {},\n      ar,\n      i,\n      oMap = {};\n  collations = collations || [];\n  overwrites = overwrites || [];\n\n  for (i = 0; i < collations.length; i++) {\n    cMap[collations[i]] = true;\n  }\n\n  for (i = 0; i < overwrites.length; i++) {\n    oMap[overwrites[i]] = true;\n  }\n\n  var c = clone(a);\n\n  for (i in b) {\n    if (c[i] == null || oMap[i]) {\n      c[i] = b[i];\n    } else if (cMap[i]) {\n      ar = [];\n      ar.push.apply(ar, Array.isArray(c[i]) ? c[i] : [c[i]]);\n      ar.push(b[i]);\n      c[i] = ar;\n    } else if (isString(b[i]) || isBoolean(b[i]) || isFunction(b[i]) || isNumber(b[i])) {\n      c[i] = b[i];\n    } else {\n      if (Array.isArray(b[i])) {\n        ar = [];\n\n        if (Array.isArray(c[i])) {\n          ar.push.apply(ar, c[i]);\n        }\n\n        ar.push.apply(ar, b[i]);\n        c[i] = ar;\n      } else if (isObject(b[i])) {\n        if (!isObject(c[i])) {\n          c[i] = {};\n        }\n\n        for (var j in b[i]) {\n          c[i][j] = b[i][j];\n        }\n      }\n    }\n  }\n\n  return c;\n}\n\nfunction _areEqual(a, b) {\n  if (a != null && b == null) {\n    return false;\n  } else {\n    if ((a == null || isString(a) || isBoolean(a) || isNumber(a)) && a !== b) {\n      return false;\n    } else {\n      if (Array.isArray(a)) {\n        if (!Array.isArray(b)) {\n          return false;\n        } else {\n          if (!arraysEqual(a, b)) {\n            return false;\n          }\n        }\n      } else if (isObject(a)) {\n        if (!isObject(a)) {\n          return false;\n        } else {\n          if (!objectsEqual(a, b)) {\n            return false;\n          }\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction arraysEqual(a, b) {\n  if (a == null && b == null) {\n    return true;\n  } else if (a == null && b != null) {\n    return false;\n  } else if (a != null && b == null) {\n    return false;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  } else {\n    for (var i = 0; i < a.length; i++) {\n      if (!_areEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction objectsEqual(a, b) {\n  if (a == null && b == null) {\n    return true;\n  } else if (a == null && b != null) {\n    return false;\n  } else if (a != null && b == null) {\n    return false;\n  }\n\n  for (var key in a) {\n    var va = a[key],\n        vb = b[key];\n\n    if (!_areEqual(va, vb)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction replace(inObj, path, value) {\n  if (inObj == null) {\n    return;\n  }\n\n  var q = inObj,\n      t = q;\n  path.replace(/([^\\.])+/g, function (term, lc, pos, str) {\n    var array = term.match(/([^\\[0-9]+){1}(\\[)([0-9+])/),\n        last = pos + term.length >= str.length,\n        _getArray = function _getArray() {\n      return t[array[1]] || function () {\n        t[array[1]] = [];\n        return t[array[1]];\n      }();\n    };\n\n    if (last) {\n      if (array) {\n        _getArray()[array[3]] = value;\n      } else {\n        t[term] = value;\n      }\n    } else {\n      if (array) {\n        var _a2 = _getArray();\n\n        t = _a2[array[3]] || function () {\n          _a2[array[3]] = {};\n          return _a2[array[3]];\n        }();\n      } else {\n        t = t[term] || function () {\n          t[term] = {};\n          return t[term];\n        }();\n      }\n    }\n\n    return \"\";\n  });\n  return inObj;\n}\n\nfunction functionChain(successValue, failValue, fns) {\n  for (var i = 0; i < fns.length; i++) {\n    var o = fns[i][0][fns[i][1]].apply(fns[i][0], fns[i][2]);\n\n    if (o === failValue) {\n      return o;\n    }\n  }\n\n  return successValue;\n}\n\nfunction populate(model, values, functionPrefix, doNotExpandFunctions) {\n  var getValue = function getValue(fromString) {\n    var matches = fromString.match(/(\\${.*?})/g);\n\n    if (matches != null) {\n      for (var i = 0; i < matches.length; i++) {\n        var val = values[matches[i].substring(2, matches[i].length - 1)] || \"\";\n\n        if (val != null) {\n          fromString = fromString.replace(matches[i], val);\n        }\n      }\n    }\n\n    return fromString;\n  };\n\n  var _one = function _one(d) {\n    if (d != null) {\n      if (isString(d)) {\n        return getValue(d);\n      } else if (isFunction(d) && !doNotExpandFunctions && (functionPrefix == null || (d.name || \"\").indexOf(functionPrefix) === 0)) {\n        return d(values);\n      } else if (Array.isArray(d)) {\n        var r = [];\n\n        for (var i = 0; i < d.length; i++) {\n          r.push(_one(d[i]));\n        }\n\n        return r;\n      } else if (isObject(d)) {\n        var s = {};\n\n        for (var j in d) {\n          s[j] = _one(d[j]);\n        }\n\n        return s;\n      } else {\n        return d;\n      }\n    }\n  };\n\n  return _one(model);\n}\n\nfunction forEach(a, f) {\n  if (a) {\n    for (var i = 0; i < a.length; i++) {\n      f(a[i]);\n    }\n  } else {\n    return null;\n  }\n}\n\nfunction findWithFunction(a, f) {\n  if (a) {\n    for (var i = 0; i < a.length; i++) {\n      if (f(a[i])) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n}\n\nfunction findAllWithFunction(a, predicate) {\n  var o = [];\n\n  if (a) {\n    for (var i = 0; i < a.length; i++) {\n      if (predicate(a[i])) {\n        o.push(i);\n      }\n    }\n  }\n\n  return o;\n}\n\nfunction getWithFunction(a, f) {\n  var idx = findWithFunction(a, f);\n  return idx === -1 ? null : a[idx];\n}\n\nfunction getAllWithFunction(a, f) {\n  var indexes = findAllWithFunction(a, f);\n  return indexes.map(function (i) {\n    return a[i];\n  });\n}\n\nfunction getFromSetWithFunction(s, f) {\n  var out = null;\n  s.forEach(function (t) {\n    if (f(t)) {\n      out = t;\n    }\n  });\n  return out;\n}\n\nfunction setToArray(s) {\n  var a = [];\n  s.forEach(function (t) {\n    a.push(t);\n  });\n  return a;\n}\n\nfunction removeWithFunction(a, f) {\n  var idx = findWithFunction(a, f);\n\n  if (idx > -1) {\n    a.splice(idx, 1);\n  }\n\n  return idx !== -1;\n}\n\nfunction fromArray(a) {\n  if (Array.fromArray != null) {\n    return Array.from(a);\n  } else {\n    var arr = [];\n    Array.prototype.push.apply(arr, a);\n    return arr;\n  }\n}\n\nfunction remove(l, v) {\n  var idx = l.indexOf(v);\n\n  if (idx > -1) {\n    l.splice(idx, 1);\n  }\n\n  return idx !== -1;\n}\n\nfunction addWithFunction(list, item, hashFunction) {\n  if (findWithFunction(list, hashFunction) === -1) {\n    list.push(item);\n  }\n}\n\nfunction addToDictionary(map, key, value, insertAtStart) {\n  var l = map[key];\n\n  if (l == null) {\n    l = [];\n    map[key] = l;\n  }\n\n  l[insertAtStart ? \"unshift\" : \"push\"](value);\n  return l;\n}\n\nfunction addToList(map, key, value, insertAtStart) {\n  var l = map.get(key);\n\n  if (l == null) {\n    l = [];\n    map.set(key, l);\n  }\n\n  l[insertAtStart ? \"unshift\" : \"push\"](value);\n  return l;\n}\n\nfunction suggest(list, item, insertAtHead) {\n  if (list.indexOf(item) === -1) {\n    if (insertAtHead) {\n      list.unshift(item);\n    } else {\n      list.push(item);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nvar lut = [];\n\nfor (var i = 0; i < 256; i++) {\n  lut[i] = (i < 16 ? '0' : '') + i.toString(16);\n}\n\nfunction uuid() {\n  var d0 = Math.random() * 0xffffffff | 0;\n  var d1 = Math.random() * 0xffffffff | 0;\n  var d2 = Math.random() * 0xffffffff | 0;\n  var d3 = Math.random() * 0xffffffff | 0;\n  return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];\n}\n\nfunction rotatePoint(point, center, rotation) {\n  var radial = {\n    x: point.x - center.x,\n    y: point.y - center.y\n  },\n      cr = Math.cos(rotation / 360 * Math.PI * 2),\n      sr = Math.sin(rotation / 360 * Math.PI * 2);\n  return {\n    x: radial.x * cr - radial.y * sr + center.x,\n    y: radial.y * cr + radial.x * sr + center.y,\n    cr: cr,\n    sr: sr\n  };\n}\n\nfunction rotateAnchorOrientation(orientation, rotation) {\n  var r = rotatePoint({\n    x: orientation[0],\n    y: orientation[1]\n  }, {\n    x: 0,\n    y: 0\n  }, rotation);\n  return [Math.round(r.x), Math.round(r.y)];\n}\n\nfunction fastTrim(s) {\n  if (s == null) {\n    return null;\n  }\n\n  var str = s.replace(/^\\s\\s*/, ''),\n      ws = /\\s/,\n      i = str.length;\n\n  while (ws.test(str.charAt(--i))) {}\n\n  return str.slice(0, i + 1);\n}\n\nfunction each(obj, fn) {\n  obj = obj.length == null || typeof obj === \"string\" ? [obj] : obj;\n\n  for (var _i = 0; _i < obj.length; _i++) {\n    fn(obj[_i]);\n  }\n}\n\nfunction map(obj, fn) {\n  var o = [];\n\n  for (var _i2 = 0; _i2 < obj.length; _i2++) {\n    o.push(fn(obj[_i2]));\n  }\n\n  return o;\n}\n\nvar logEnabled = true;\n\nfunction log() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (typeof console !== \"undefined\") {\n    try {\n      var msg = arguments[arguments.length - 1];\n      console.log(msg);\n    } catch (e) {}\n  }\n}\n\nfunction sgn(x) {\n  return x < 0 ? -1 : x > 0 ? 1 : 0;\n}\n\nfunction wrap(wrappedFunction, newFunction, returnOnThisValue) {\n  return function () {\n    var r = null;\n\n    try {\n      if (newFunction != null) {\n        r = newFunction.apply(this, arguments);\n      }\n    } catch (e) {\n      log(\"jsPlumb function failed : \" + e);\n    }\n\n    if (wrappedFunction != null && (returnOnThisValue == null || r !== returnOnThisValue)) {\n      try {\n        r = wrappedFunction.apply(this, arguments);\n      } catch (e) {\n        log(\"wrapped function failed : \" + e);\n      }\n    }\n\n    return r;\n  };\n}\n\nfunction getsert(map, key, valueGenerator) {\n  if (!map.has(key)) {\n    map.set(key, valueGenerator());\n  }\n\n  return map.get(key);\n}\n\nfunction isAssignableFrom(object, cls) {\n  var proto = object.__proto__;\n\n  while (proto != null) {\n    if (proto instanceof cls) {\n      return true;\n    } else {\n      proto = proto.__proto__;\n    }\n  }\n\n  return false;\n}\n\nfunction insertSorted(value, array, comparator, sortDescending) {\n  if (array.length === 0) {\n    array.push(value);\n  } else {\n    var flip = sortDescending ? -1 : 1;\n    var min = 0;\n    var max = array.length;\n    var index = Math.floor((min + max) / 2);\n\n    while (max > min) {\n      var c = comparator(value, array[index]) * flip;\n\n      if (c < 0) {\n        max = index;\n      } else {\n        min = index + 1;\n      }\n\n      index = Math.floor((min + max) / 2);\n    }\n\n    array.splice(index, 0, value);\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar EventGenerator = function () {\n  function EventGenerator() {\n    _classCallCheck(this, EventGenerator);\n\n    _defineProperty(this, \"_listeners\", {});\n\n    _defineProperty(this, \"eventsSuspended\", false);\n\n    _defineProperty(this, \"tick\", false);\n\n    _defineProperty(this, \"eventsToDieOn\", {\n      \"ready\": true\n    });\n\n    _defineProperty(this, \"queue\", []);\n  }\n\n  _createClass(EventGenerator, [{\n    key: \"fire\",\n    value: function fire(event, value, originalEvent) {\n      var ret = null;\n\n      if (!this.tick) {\n        this.tick = true;\n\n        if (!this.eventsSuspended && this._listeners[event]) {\n          var l = this._listeners[event].length,\n              i = 0,\n              _gone = false;\n\n          if (!this.shouldFireEvent || this.shouldFireEvent(event, value, originalEvent)) {\n            while (!_gone && i < l && ret !== false) {\n              if (this.eventsToDieOn[event]) {\n                this._listeners[event][i].apply(this, [value, originalEvent]);\n              } else {\n                try {\n                  ret = this._listeners[event][i].apply(this, [value, originalEvent]);\n                } catch (e) {\n                  log(\"jsPlumb: fire failed for event \" + event + \" : \" + (e.message || e));\n                }\n              }\n\n              i++;\n\n              if (this._listeners == null || this._listeners[event] == null) {\n                _gone = true;\n              }\n            }\n          }\n        }\n\n        this.tick = false;\n\n        this._drain();\n      } else {\n        this.queue.unshift(arguments);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"_drain\",\n    value: function _drain() {\n      var n = this.queue.pop();\n\n      if (n) {\n        this.fire.apply(this, n);\n      }\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind(eventOrListener, listener) {\n      if (arguments.length === 0) {\n        this._listeners = {};\n      } else if (arguments.length === 1) {\n        if (typeof eventOrListener === \"string\") {\n          delete this._listeners[eventOrListener];\n        } else if (eventOrListener.__jsPlumb) {\n          var evt;\n\n          for (var i in eventOrListener.__jsPlumb) {\n            evt = eventOrListener.__jsPlumb[i];\n            remove(this._listeners[evt] || [], eventOrListener);\n          }\n        }\n      } else if (arguments.length === 2) {\n        remove(this._listeners[eventOrListener] || [], listener);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"getListener\",\n    value: function getListener(forEvent) {\n      return this._listeners[forEvent] || [];\n    }\n  }, {\n    key: \"isSuspendEvents\",\n    value: function isSuspendEvents() {\n      return this.eventsSuspended;\n    }\n  }, {\n    key: \"setSuspendEvents\",\n    value: function setSuspendEvents(val) {\n      this.eventsSuspended = val;\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(event, listener, insertAtStart) {\n      var _this = this;\n\n      var _one = function _one(evt) {\n        addToDictionary(_this._listeners, evt, listener, insertAtStart);\n        listener.__jsPlumb = listener.__jsPlumb || {};\n        listener.__jsPlumb[uuid()] = evt;\n      };\n\n      if (typeof event === \"string\") {\n        _one(event);\n      } else if (event.length != null) {\n        for (var i = 0; i < event.length; i++) {\n          _one(event[i]);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"silently\",\n    value: function silently(fn) {\n      this.setSuspendEvents(true);\n\n      try {\n        fn();\n      } catch (e) {\n        log(\"Cannot execute silent function \" + e);\n      }\n\n      this.setSuspendEvents(false);\n    }\n  }]);\n\n  return EventGenerator;\n}();\n\nvar OptimisticEventGenerator = function (_EventGenerator) {\n  _inherits(OptimisticEventGenerator, _EventGenerator);\n\n  var _super = _createSuper(OptimisticEventGenerator);\n\n  function OptimisticEventGenerator() {\n    _classCallCheck(this, OptimisticEventGenerator);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(OptimisticEventGenerator, [{\n    key: \"shouldFireEvent\",\n    value: function shouldFireEvent(event, value, originalEvent) {\n      return true;\n    }\n  }]);\n\n  return OptimisticEventGenerator;\n}(EventGenerator);\n\nvar segmentMultipliers = [null, [1, -1], [1, 1], [-1, 1], [-1, -1]];\nvar inverseSegmentMultipliers = [null, [-1, -1], [-1, 1], [1, 1], [1, -1]];\nvar TWO_PI = 2 * Math.PI;\n\nfunction add(p1, p2) {\n  return {\n    x: p1.x + p2.x,\n    y: p1.y + p2.y\n  };\n}\n\nfunction subtract(p1, p2) {\n  return {\n    x: p1.x - p2.x,\n    y: p1.y - p2.y\n  };\n}\n\nfunction gradient(p1, p2) {\n  if (p2.x === p1.x) return p2.y > p1.y ? Infinity : -Infinity;else if (p2.y === p1.y) return p2.x > p1.x ? 0 : -0;else return (p2.y - p1.y) / (p2.x - p1.x);\n}\n\nfunction normal(p1, p2) {\n  return -1 / gradient(p1, p2);\n}\n\nfunction lineLength(p1, p2) {\n  return Math.sqrt(Math.pow(p2.y - p1.y, 2) + Math.pow(p2.x - p1.x, 2));\n}\n\nfunction quadrant(p1, p2) {\n  if (p2.x > p1.x) {\n    return p2.y > p1.y ? 2 : 1;\n  } else if (p2.x == p1.x) {\n    return p2.y > p1.y ? 2 : 1;\n  } else {\n    return p2.y > p1.y ? 3 : 4;\n  }\n}\n\nfunction theta(p1, p2) {\n  var m = gradient(p1, p2),\n      t = Math.atan(m),\n      s = quadrant(p1, p2);\n  if (s == 4 || s == 3) t += Math.PI;\n  if (t < 0) t += 2 * Math.PI;\n  return t;\n}\n\nfunction intersects(r1, r2) {\n  var x1 = r1.x,\n      x2 = r1.x + r1.w,\n      y1 = r1.y,\n      y2 = r1.y + r1.h,\n      a1 = r2.x,\n      a2 = r2.x + r2.w,\n      b1 = r2.y,\n      b2 = r2.y + r2.h;\n  return x1 <= a1 && a1 <= x2 && y1 <= b1 && b1 <= y2 || x1 <= a2 && a2 <= x2 && y1 <= b1 && b1 <= y2 || x1 <= a1 && a1 <= x2 && y1 <= b2 && b2 <= y2 || x1 <= a2 && a1 <= x2 && y1 <= b2 && b2 <= y2 || a1 <= x1 && x1 <= a2 && b1 <= y1 && y1 <= b2 || a1 <= x2 && x2 <= a2 && b1 <= y1 && y1 <= b2 || a1 <= x1 && x1 <= a2 && b1 <= y2 && y2 <= b2 || a1 <= x2 && x1 <= a2 && b1 <= y2 && y2 <= b2;\n}\n\nfunction toABC(line) {\n  var A = line[1].y - line[0].y;\n  var B = line[0].x - line[1].x;\n  return {\n    A: A,\n    B: B,\n    C: A * line[0].x + B * line[0].y\n  };\n}\n\nfunction lineIntersection(l1, l2) {\n  var abc1 = toABC(l1),\n      abc2 = toABC(l2),\n      det = abc1.A * abc2.B - abc2.A * abc1.B;\n\n  if (det == 0) {\n    return null;\n  } else {\n    var candidate = {\n      x: (abc2.B * abc1.C - abc1.B * abc2.C) / det,\n      y: (abc1.A * abc2.C - abc2.A * abc1.C) / det\n    },\n        l1xmin = Math.min(l1[0].x, l1[1].x),\n        l1xmax = Math.max(l1[0].x, l1[1].x),\n        l1ymin = Math.min(l1[0].y, l1[1].y),\n        l1ymax = Math.max(l1[0].y, l1[1].y),\n        l2xmin = Math.min(l2[0].x, l2[1].x),\n        l2xmax = Math.max(l2[0].x, l2[1].x),\n        l2ymin = Math.min(l2[0].y, l2[1].y),\n        l2ymax = Math.max(l2[0].y, l2[1].y);\n\n    if (candidate.x >= l1xmin && candidate.x <= l1xmax && candidate.y >= l1ymin && candidate.y <= l1ymax && candidate.x >= l2xmin && candidate.x <= l2xmax && candidate.y >= l2ymin && candidate.y <= l2ymax) {\n      return candidate;\n    } else {\n      return null;\n    }\n  }\n}\n\nfunction lineRectangleIntersection(line, r) {\n  var out = [],\n      rectangleLines = [[{\n    x: r.x,\n    y: r.y\n  }, {\n    x: r.x + r.w,\n    y: r.y\n  }], [{\n    x: r.x + r.w,\n    y: r.y\n  }, {\n    x: r.x + r.w,\n    y: r.y + r.h\n  }], [{\n    x: r.x,\n    y: r.y\n  }, {\n    x: r.x,\n    y: r.y + r.h\n  }], [{\n    x: r.x,\n    y: r.y + r.h\n  }, {\n    x: r.x + r.w,\n    y: r.y + r.h\n  }]];\n  forEach(rectangleLines, function (rLine) {\n    var intersection = lineIntersection(line, rLine);\n\n    if (intersection != null) {\n      out.push(intersection);\n    }\n  });\n  return out;\n}\n\nfunction encloses(r1, r2, allowSharedEdges) {\n  var x1 = r1.x,\n      x2 = r1.x + r1.w,\n      y1 = r1.y,\n      y2 = r1.y + r1.h,\n      a1 = r2.x,\n      a2 = r2.x + r2.w,\n      b1 = r2.y,\n      b2 = r2.y + r2.h,\n      c = function c(v1, v2, v3, v4) {\n    return allowSharedEdges ? v1 <= v2 && v3 >= v4 : v1 < v2 && v3 > v4;\n  };\n\n  return c(x1, a1, x2, a2) && c(y1, b1, y2, b2);\n}\n\nfunction pointOnLine(fromPoint, toPoint, distance) {\n  var m = gradient(fromPoint, toPoint),\n      s = quadrant(fromPoint, toPoint),\n      segmentMultiplier = distance > 0 ? segmentMultipliers[s] : inverseSegmentMultipliers[s],\n      theta = Math.atan(m),\n      y = Math.abs(distance * Math.sin(theta)) * segmentMultiplier[1],\n      x = Math.abs(distance * Math.cos(theta)) * segmentMultiplier[0];\n  return {\n    x: fromPoint.x + x,\n    y: fromPoint.y + y\n  };\n}\n\nfunction perpendicularLineTo(fromPoint, toPoint, length) {\n  var m = gradient(fromPoint, toPoint),\n      theta2 = Math.atan(-1 / m),\n      y = length / 2 * Math.sin(theta2),\n      x = length / 2 * Math.cos(theta2);\n  return [{\n    x: toPoint.x + x,\n    y: toPoint.y + y\n  }, {\n    x: toPoint.x - x,\n    y: toPoint.y - y\n  }];\n}\n\nfunction snapToGrid(pos, grid, thresholdX, thresholdY) {\n  thresholdX = thresholdX == null ? grid.thresholdX == null ? grid.w / 2 : grid.thresholdX : thresholdX;\n  thresholdY = thresholdY == null ? grid.thresholdY == null ? grid.h / 2 : grid.thresholdY : thresholdY;\n\n  var _dx = Math.floor(pos.x / grid.w),\n      _dxl = grid.w * _dx,\n      _dxt = _dxl + grid.w,\n      x = Math.abs(pos.x - _dxl) <= thresholdX ? _dxl : Math.abs(_dxt - pos.x) <= thresholdX ? _dxt : pos.x;\n\n  var _dy = Math.floor(pos.y / grid.h),\n      _dyl = grid.h * _dy,\n      _dyt = _dyl + grid.h,\n      y = Math.abs(pos.y - _dyl) <= thresholdY ? _dyl : Math.abs(_dyt - pos.y) <= thresholdY ? _dyt : pos.y;\n\n  return {\n    x: x,\n    y: y\n  };\n}\n\n\n\n//# sourceURL=webpack://questmaker/./node_modules/@jsplumb/util/js/jsplumb.util.es.js?");

/***/ }),

/***/ "./assets/img/favicon.ico":
/*!********************************!*\
  !*** ./assets/img/favicon.ico ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"img/favicon.3c12d881b58b8d3c3a244b67e5c425b4.ico\");\n\n//# sourceURL=webpack://questmaker/./assets/img/favicon.ico?");

/***/ }),

/***/ "./assets/img/img1.jpg":
/*!*****************************!*\
  !*** ./assets/img/img1.jpg ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"img/img1.d726711a429f6db14fb54fa81420ccaa.jpg\");\n\n//# sourceURL=webpack://questmaker/./assets/img/img1.jpg?");

/***/ }),

/***/ "./assets/img/profile_defolt.png":
/*!***************************************!*\
  !*** ./assets/img/profile_defolt.png ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"img/profile_defolt.7058d8507900218215d7f274f23fa4f9.png\");\n\n//# sourceURL=webpack://questmaker/./assets/img/profile_defolt.png?");

/***/ }),

/***/ "./assets/img/telegram_scrin_on_phone.jpg":
/*!************************************************!*\
  !*** ./assets/img/telegram_scrin_on_phone.jpg ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"img/telegram_scrin_on_phone.c8d918b54cc9a541a09f523b33beeca3.jpg\");\n\n//# sourceURL=webpack://questmaker/./assets/img/telegram_scrin_on_phone.jpg?");

/***/ }),

/***/ "./assets/css/index.css":
/*!******************************!*\
  !*** ./assets/css/index.css ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://questmaker/./assets/css/index.css?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "http://192.168.1.198:2992/static/";
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./assets/js/constructor.js");
/******/ 	
/******/ })()
;